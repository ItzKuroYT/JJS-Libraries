<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>JJS Library â€” Search & Share</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&family=General+Sans:wght@400;500;600&display=swap');
    :root{
      --bg-top:#030616;
      --bg-bottom:#160636;
      --aurora-left:#73efff;
      --aurora-right:#8a64ff;
      --surface:rgba(8,12,30,0.95);
      --surface-alt:rgba(12,18,42,0.92);
      --card:rgba(10,16,38,0.98);
      --panel:rgba(7,12,28,0.92);
      --panel-soft:rgba(255,255,255,0.05);
      --border:rgba(255,255,255,0.08);
      --muted:#9caecb;
      --text:#f5f7ff;
      --accent:#7ef9c2;
      --accent-strong:#7b5bff;
      --accent-fade:rgba(126,249,194,0.18);
      --glow:0 32px 90px rgba(18, 15, 101, 0.65);
      --ratingPositive:#46f0a2;
      --ratingNeutral:#ffd166;
      --ratingNegative:#ff7b7b;
      --glass:rgba(255,255,255,0.08);
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;font-family:'Space Grotesk','General Sans',sans-serif;background:var(--bg-bottom);color:var(--text)}
    body{
      min-height:100vh;
      background-image:
        radial-gradient(circle at 18% 22%,rgba(84,224,199,0.22),transparent 50%),
        radial-gradient(circle at 80% 10%,rgba(138,100,255,0.28),transparent 48%),
        linear-gradient(180deg,var(--bg-top) 0%,var(--bg-bottom) 100%);
    }
    body::before{
      content:'';
      position:fixed;
      inset:0;
      pointer-events:none;
      background:radial-gradient(circle at 60% 12%,rgba(255,255,255,0.08),transparent 55%);
      mix-blend-mode:screen;
      opacity:0.6;
    }
    .container{
      width:min(95vw,1400px);
      margin:34px auto 64px;
      padding:48px 52px;
      background:var(--surface);
      border:1px solid var(--border);
      border-radius:36px;
      box-shadow:var(--glow);
      position:relative;
      overflow:hidden;
    }
    .container::after{
      content:'';
      position:absolute;
      inset:18px;
      border-radius:24px;
      border:1px solid rgba(255,255,255,0.03);
      pointer-events:none;
    }
    header{display:flex;gap:20px;align-items:flex-start;justify-content:space-between}
    h1{font-size:34px;font-weight:600;margin:0;letter-spacing:-0.02em}
    .credits{font-size:15px;color:var(--muted);margin-top:4px;max-width:440px}
    .small{font-size:13px;color:var(--muted)}
    .controls{display:flex;flex-direction:column;gap:18px;margin-top:26px;padding:22px;background:var(--panel);border-radius:26px;border:1px solid rgba(255,255,255,0.06);box-shadow:0 20px 45px rgba(5,8,25,0.55)}
    .controlRow{display:flex;gap:14px;flex-wrap:wrap;align-items:center;width:100%}
    .controlRow--primary{align-items:flex-start}
    .controlRow--actions{justify-content:flex-end}
    input,textarea,select{font-family:inherit;font-size:15px;color:var(--text);background:rgba(8,17,40,0.85);border:1px solid rgba(255,255,255,0.08);border-radius:14px;padding:12px 14px;outline:none;transition:border-color 0.2s ease,box-shadow 0.2s ease}
    input:focus,textarea:focus{border-color:var(--accent);box-shadow:0 0 0 2px rgba(126,249,194,0.2)}
    input::placeholder,textarea::placeholder{color:rgba(230,238,246,0.55)}
    input.search{flex:1 1 260px;min-width:240px;background:rgba(10,20,46,0.92)}
    #authBox{display:flex;gap:10px;flex-wrap:wrap;align-items:center;background:rgba(255,255,255,0.02);padding:10px 12px;border-radius:18px;border:1px solid rgba(255,255,255,0.05)}
    #authBox input{flex:1 1 140px;min-width:140px}
    #userLabel{min-width:130px;text-align:right;color:var(--muted)}
    button{background:linear-gradient(115deg,var(--accent-strong),#1cc9ff);border:1px solid rgba(255,255,255,0.08);color:#050914;padding:10px 18px;border-radius:14px;cursor:pointer;font-weight:600;letter-spacing:0.01em;box-shadow:0 10px 24px rgba(12,8,35,0.5);transition:transform 0.2s ease,box-shadow 0.2s ease}
    button:hover{transform:translateY(-2px);box-shadow:0 16px 28px rgba(12,8,35,0.65)}
    button:active{transform:translateY(1px)}
    button.ghost{background:rgba(12,20,46,0.96);color:var(--text);border:1px solid rgba(255,255,255,0.16);box-shadow:0 6px 16px rgba(3,8,22,0.45)}
    button.ghost:hover{color:var(--accent);border-color:var(--accent);background:rgba(16,28,62,0.98)}
    .tagBar{margin-top:16px;padding:18px;background:var(--panel);border-radius:22px;border:1px solid rgba(255,255,255,0.05);display:flex;flex-direction:column;gap:12px}
    .tagPicker{display:flex;gap:10px;flex-wrap:wrap}
    .tagInput{display:flex;gap:10px;flex-wrap:wrap}
    .communityStrip{margin:10px 0;padding:10px;border-radius:20px;background:linear-gradient(120deg,rgba(123,91,255,0.14),rgba(8,19,42,0.8));border:1px solid rgba(255,255,255,0.07);display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:14px;align-items:stretch}
    .statBlock{display:flex;flex-direction:column;gap:4px;padding:10px 12px;border-radius:14px;background:rgba(7,12,30,0.48);border:1px solid rgba(255,255,255,0.04);position:relative;overflow:hidden}
    .statBlock::after{content:'';position:absolute;inset:0;border-radius:10px;border:1px solid rgba(255,255,255,0.025);pointer-events:none}
    .statLabel{font-size:9px;letter-spacing:0.16em;text-transform:uppercase;color:var(--muted)}
    .statValue{font-size:21px;font-weight:600}
    .staffPanel{display:flex;flex-direction:column;gap:12px}
    .staffBlock{display:flex;flex-direction:column;gap:6px}
    .staffPills{display:flex;flex-wrap:wrap;gap:8px;min-height:30px}
    .staffPill{padding:6px 14px;border-radius:999px;background:rgba(255,255,255,0.08);font-size:13px;font-weight:500;border:1px solid rgba(255,255,255,0.06)}
    .staffPill--owner{background:var(--accent-fade);color:var(--accent)}
    .list{margin-top:26px;display:grid;grid-template-columns:repeat(auto-fit,minmax(320px,1fr));gap:20px;transition:opacity 0.28s ease,transform 0.28s ease;will-change:opacity,transform}
    .list.list--fading{opacity:0;transform:translateY(12px)}
    .paginationBar{margin-top:28px;display:flex;justify-content:center;align-items:center;gap:8px;flex-wrap:wrap}
    .paginationBar--hidden{display:none}
    .pageBtn{min-width:44px;padding:8px 14px;border-radius:12px;border:1px solid rgba(255,255,255,0.12);background:rgba(255,255,255,0.04);color:var(--text);font-weight:500;cursor:pointer;transition:background 0.2s ease,color 0.2s ease,transform 0.2s ease}
    .pageBtn--nav{font-size:13px}
    .pageBtn--active{background:linear-gradient(115deg,var(--accent-strong),#1cc9ff);color:#050914;border-color:transparent}
    .pageBtn:disabled{opacity:0.35;cursor:not-allowed}
    .pageBtn:not(:disabled):hover{background:rgba(255,255,255,0.12);transform:translateY(-1px)}
    .pageEllipsis{padding:6px 4px;color:var(--muted);font-size:13px}
    .card{position:relative;background:var(--surface-alt);padding:22px;border-radius:22px;border:1px solid rgba(255,255,255,0.05);box-shadow:0 18px 44px rgba(6,8,27,0.55);backdrop-filter:blur(14px);transition:transform 0.25s ease,border-color 0.25s ease}
    .card::before{content:'';position:absolute;inset:0;border-radius:22px;border:1px solid rgba(126,249,194,0.08);opacity:0;pointer-events:none;transition:opacity 0.2s ease}
    .card:hover{transform:translateY(-6px) scale(1.012);border-color:rgba(126,249,194,0.35)}
    .card:hover::before{opacity:1}
    .card h3{margin:0;font-size:18px}
    .cardAvatarWrap{width:58px;height:58px;min-width:58px;border-radius:50%;overflow:hidden;background:rgba(255,255,255,0.08);display:inline-flex;align-items:center;justify-content:center;flex-shrink:0;border:1px solid rgba(255,255,255,0.04)}
    .cardAvatar{width:100%;height:100%;object-fit:cover;display:block}
    .meta{font-size:13px;color:var(--muted);margin-top:6px;display:flex;gap:8px;align-items:center}
    .actions{margin-top:14px;display:flex;gap:10px;flex-wrap:wrap}
    .cardBadges{display:flex;gap:6px;flex-wrap:wrap;justify-content:flex-end;max-width:220px}
    .postBadge{display:inline-flex;align-items:center;gap:4px;padding:3px 8px;border-radius:999px;font-size:10px;letter-spacing:.08em;text-transform:uppercase;border:1px solid rgba(255,255,255,0.15);background:rgba(255,255,255,0.05);color:var(--text)}
    .postBadge--private{border-color:rgba(255,196,196,0.45);background:rgba(255,89,89,0.12)}
    .postBadge--public{border-color:rgba(126,249,194,0.45);background:rgba(126,249,194,0.13)}
    .postBadge--pinned{border-color:rgba(255,223,133,0.5);background:rgba(255,194,77,0.16)}
    .postBadge--top{border-color:rgba(255,225,102,0.52);background:rgba(255,224,102,0.16)}
    .quickActions{position:absolute;top:12px;right:12px;display:flex;gap:6px;opacity:0;transform:translateY(-4px);pointer-events:none;transition:opacity .2s ease,transform .2s ease}
    .card:hover .quickActions{opacity:1;transform:translateY(0);pointer-events:auto}
    .quickActionBtn{min-width:34px;height:34px;padding:0 8px;border-radius:10px;display:inline-flex;align-items:center;justify-content:center;font-size:14px}
    .tagChips{display:flex;flex-wrap:wrap;gap:6px;margin-top:8px}
    .tagChip{display:inline-flex;align-items:center;padding:3px 8px;border-radius:999px;border:1px solid rgba(255,255,255,0.14);font-size:11px;color:var(--muted);cursor:pointer;background:rgba(255,255,255,0.03)}
    .tagChip:hover{color:var(--accent);border-color:var(--accent)}
    .reactionRow{display:flex;flex-wrap:wrap;gap:6px;margin-top:8px}
    .reactionBtn{padding:4px 8px;border-radius:999px;border:1px solid rgba(255,255,255,0.15);background:rgba(255,255,255,0.02);font-size:12px;color:var(--text);cursor:pointer}
    .reactionBtn.active{border-color:var(--accent);background:rgba(126,249,194,0.16)}
    .reactionBtn:disabled{opacity:.45;cursor:not-allowed}
    .hoverLift{transition:transform .2s ease,box-shadow .2s ease}
    .hoverLift:hover{transform:translateY(-2px)}
    .roleBadges{display:inline-flex;align-items:center;gap:5px;margin-left:6px;vertical-align:middle;flex-wrap:wrap}
    .roleBadge{display:inline-flex;align-items:center;justify-content:center;gap:4px;min-height:18px;padding:0 7px;border-radius:999px;border:1px solid rgba(255,255,255,0.2);font-size:10px;line-height:1;color:var(--text);background:rgba(255,255,255,0.06);white-space:nowrap}
    .roleBadgeIcon{font-size:10px;line-height:1}
    .roleBadgeName{font-size:10px;line-height:1;letter-spacing:.03em}
    .roleBadge--named{padding:3px 8px;min-height:20px}
    .roleBadge--owner{border-color:rgba(255,196,107,0.5);background:rgba(255,196,107,0.2)}
    .roleBadge--moderator{border-color:rgba(133,198,255,0.5);background:rgba(133,198,255,0.18)}
    .roleBadge--verified{border-color:rgba(126,249,194,0.5);background:rgba(126,249,194,0.18)}
    .roleBadge--og{border-color:rgba(208,167,255,0.5);background:rgba(208,167,255,0.18)}
    .roleBadge--custom{border-color:var(--badge-color, rgba(255,255,255,0.35));background:color-mix(in srgb, var(--badge-color, #ffffff) 25%, transparent);color:var(--text)}
    .ownerPanelOverlay{position:fixed;inset:0;background:rgba(0,0,0,0.58);z-index:10000;display:flex;align-items:center;justify-content:center;padding:18px}
    .ownerPanelCard{width:min(1100px,96vw);max-height:90vh;overflow:hidden;background:var(--card);border:1px solid rgba(255,255,255,0.09);border-radius:18px;box-shadow:0 28px 60px rgba(5,8,25,0.72);display:grid;grid-template-columns:220px minmax(0,1fr)}
    .ownerPanelSide{padding:14px;border-right:1px solid rgba(255,255,255,0.08);background:rgba(8,15,34,0.95);display:flex;flex-direction:column;gap:8px}
    .ownerPanelTab{width:100%;text-align:left;border-radius:10px;padding:10px 12px;background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.07);color:var(--text);font-size:13px}
    .ownerPanelTab.active{border-color:var(--accent);color:var(--accent);background:rgba(126,249,194,0.12)}
    .ownerPanelBody{padding:16px;overflow:auto;display:flex;flex-direction:column;gap:12px}
    .ownerGrid{display:grid;grid-template-columns:repeat(auto-fit,minmax(250px,1fr));gap:10px}
    .ownerCard{padding:12px;border-radius:12px;border:1px solid rgba(255,255,255,0.08);background:rgba(255,255,255,0.03)}
    .ownerRow{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .ownerRow input,.ownerRow select{flex:1 1 140px;min-width:120px}
    .ownerList{display:flex;flex-direction:column;gap:8px;margin-top:8px}
    .ownerListItem{display:flex;align-items:center;justify-content:space-between;gap:10px;padding:8px 10px;border-radius:10px;border:1px solid rgba(255,255,255,0.06);background:rgba(255,255,255,0.02)}
    .ownerListMeta{display:flex;align-items:center;gap:8px;min-width:0}
    .ownerListMeta b{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;max-width:200px}
    .ownerDot{width:10px;height:10px;border-radius:999px;flex:none;background:var(--dot-color,#fff)}
    .ownerStatus{font-size:12px;color:var(--muted)}
    .ownerCommands{padding:8px;border-radius:10px;border:1px solid rgba(255,255,255,0.07);background:rgba(255,255,255,0.02);font-size:12px;line-height:1.5}
    .ownerSearchResults{max-height:210px;overflow:auto;border-radius:10px;border:1px solid rgba(255,255,255,0.07);padding:8px;background:rgba(5,12,30,0.7)}
    .ownerSearchResult{padding:7px 8px;border:1px solid rgba(255,255,255,0.06);border-radius:9px;cursor:pointer;background:rgba(255,255,255,0.03)}
    .ownerSearchResult + .ownerSearchResult{margin-top:6px}
    .ownerSearchResult:hover{border-color:var(--accent)}
    @media(max-width:900px){
      .ownerPanelCard{grid-template-columns:1fr}
      .ownerPanelSide{border-right:none;border-bottom:1px solid rgba(255,255,255,0.08)}
    }
    .globalSearchPanel{margin-top:10px;padding:12px;border-radius:14px;border:1px solid rgba(255,255,255,0.08);background:rgba(5,12,30,0.82);max-height:280px;overflow:auto}
    .globalSearchPanel mark{background:rgba(255,224,102,0.35);color:var(--text);padding:0 2px;border-radius:3px}
    .globalSearchGroup{margin-bottom:12px}
    .globalSearchItem{padding:7px 8px;border-radius:10px;border:1px solid rgba(255,255,255,0.05);background:rgba(255,255,255,0.03);margin-top:6px;cursor:pointer}
    .globalSearchItem:hover{border-color:var(--accent)}
    .cardVideoWrap{margin-top:14px;border-radius:18px;overflow:hidden;background:rgba(0,0,0,0.65);border:1px solid rgba(255,255,255,0.05);box-shadow:0 14px 30px rgba(4,6,18,0.6)}
    .cardVideoWrap video{width:100%;display:block;max-height:320px;background:#000}
    .cardVideoMeta{padding:8px 12px;font-size:11px;letter-spacing:0.08em;text-transform:uppercase;color:var(--muted);background:rgba(0,0,0,0.35);border-top:1px solid rgba(255,255,255,0.04)}
    pre.code{background:linear-gradient(160deg,rgba(5,10,25,0.94),rgba(3,6,18,0.85));color:#dff0ff;padding:14px;border-radius:16px;overflow:auto;max-height:280px;margin:12px 0;border:1px solid rgba(255,255,255,0.04)}
    .link{color:var(--accent);text-decoration:none}
    .ratingRow{display:flex;align-items:center;gap:10px;margin-top:10px;font-size:13px;position:relative}
    .ratingRow.ratingRowFlash{animation:ratingRowPulse 0.6s ease}
    .ratingStars{display:flex;gap:6px}
    .ratingStars button{background:transparent;border:none;padding:0;font-size:20px;line-height:1;color:rgba(255,255,255,0.3);cursor:pointer;transition:color 0.18s ease,transform 0.18s ease;will-change:color,transform}
    .ratingStars button.filled{color:#ffe066;text-shadow:0 0 12px rgba(255,224,102,0.35);transform:scale(1)}
    .ratingStars button:not(:disabled):hover{color:#fff3b0;transform:translateY(-1px)}
    .ratingStars button:not(:disabled):active{transform:scale(0.9)}
    .ratingStars button:disabled{opacity:0.35;cursor:not-allowed}
    .ratingStars button:focus-visible{outline:1px dashed var(--accent);outline-offset:2px}
    .ratingPercent{font-size:12px;color:var(--muted);transition:color 0.2s ease,transform 0.2s ease}
    .ratingPercent--positive{color:var(--ratingPositive)}
    .ratingPercent--neutral{color:var(--ratingNeutral)}
    .ratingPercent--negative{color:var(--ratingNegative)}
    .ratingRow.ratingRowFlash .ratingPercent{transform:scale(1.06)}
    @keyframes ratingRowPulse{0%{transform:scale(0.96);opacity:0.6;}60%{transform:scale(1.04);opacity:1;}100%{transform:scale(1);opacity:1;}}
    @media (prefers-reduced-motion:reduce){.ratingRow.ratingRowFlash{animation:none}.ratingPercent{transition:none}.ratingStars button{transition:none}}
    @media(max-width:960px){
      .container{padding:32px 26px}
      header{flex-direction:column;align-items:flex-start}
      .controls{padding:18px}
    }
    @media(max-width:640px){
      .container{padding:22px 16px;border-radius:24px}
      .communityStrip{grid-template-columns:1fr}
      .controlRow--actions{justify-content:flex-start}
      #authBox{flex-direction:column;width:100%}
      #userLabel{text-align:left}
    }
  </style>
</head>
<body>
  <div class="container">

    <style>
      .layout{display:grid;grid-template-columns:minmax(0,1fr);gap:36px;margin-top:30px;align-items:flex-start}
      .sidebar{display:none !important}
      .sidebar .profile{display:flex;gap:16px;align-items:center;padding-bottom:12px;border-bottom:1px solid rgba(255,255,255,0.05)}
      .avatar{width:100px;height:100px;border-radius:100%;background:linear-gradient(135deg,rgba(126,249,194,0.3),rgba(123,91,255,0.35));display:inline-block;overflow:hidden;border:1px solid rgba(255,255,255,0.08)}
      .avatar img{width:100%;height:100%;object-fit:cover;display:block}
      .smallMuted{font-size:12px;color:var(--muted)}
      .sideSection{padding:18px;border-radius:20px;background:rgba(6,12,29,0.78);border:1px solid rgba(255,255,255,0.05);box-shadow:inset 0 0 0 1px rgba(255,255,255,0.02)}
      .sideSection + .sideSection{margin-top:6px}
      .sideSection > .smallMuted{font-size:11px;letter-spacing:0.12em;text-transform:uppercase;color:rgba(156,174,203,0.9)}
      .profileLinksList{display:flex;flex-direction:column;gap:6px;margin-top:6px}
      .profileLinkRow{display:flex;justify-content:space-between;align-items:center;padding:6px 10px;border-radius:10px;background:rgba(255,255,255,0.04);border:1px solid rgba(255,255,255,0.05);font-size:12px}
      .profileLinkRow button{margin-left:8px}
      .ownerPanelShortcut{margin-top:10px}
      .libItem{padding:8px 10px;border-radius:12px;border:1px solid rgba(255,255,255,0.05);margin-bottom:8px;background:rgba(255,255,255,0.02)}
      .notifications,.dmList{max-height:190px;overflow:auto;margin-top:12px;padding-right:6px}
      .postsCard{width:100%;padding:48px;background:var(--panel);border-radius:34px;border:1px solid rgba(255,255,255,0.06);box-shadow:0 30px 64px rgba(7,10,30,0.72);color:inherit;backdrop-filter:blur(20px)}
      @media(max-width:900px){
        .layout{grid-template-columns:1fr;gap:22px}
      }
    </style>

    <div class="layout">
      <aside class="sidebar" id="sidebar">
        <div class="profile">
          <div class="avatar" id="avatarWrap"><img id="avatarImg" src="" alt="avatar"/></div>
          <div>
            <div id="sideUsername" class="small"></div>
            <div class="smallMuted">My account</div>
            <div class="smallMuted" id="sideFollowSummary"></div>
          </div>
        </div>
        <div style="margin-top:8px">
          <input id="avatarFile" type="file" accept="image/*" style="width:100%" />
        </div>

        <div class="sideSection">
          <div class="smallMuted">My libraries (<span id="myLibCount">0</span>)</div>
          <div id="myLibs"></div>
        </div>

        <div class="sideSection">
          <div class="smallMuted">Notifications</div>
          <div id="notifications" class="notifications small"></div>
        </div>

        <div class="sideSection">
          <div class="smallMuted">Friend Requests</div>
          <div id="friendRequests"></div>
        </div>

        <div class="sideSection">
          <div class="smallMuted">Direct Messages</div>
          <div id="dmConvos" class="dmList small"></div>
          <div style="margin-top:8px;display:flex;gap:6px">
            <input id="dmTo" placeholder="To (username)" style="flex:1;padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.04)" />
            <button id="openDm" class="ghost">Open</button>
          </div>
        </div>
      </aside>

      <div class="postsCard">
        <header>
          <div>
            <h1>JJS Library â€” Search & Share</h1>
            <div class="credits">Search for a moveset, or share your own with the community! You may also self-promote your content using credits or profile links.</div>
          </div>
          <div class="small">Made for Jujutsu Shenanigans</div>
        </header>

        <main style="flex:1">
          <div class="controls">
            <div class="controlRow controlRow--primary">
              <input id="search" class="search" placeholder="Search libraries (title, tags)..." />
              <div id="authBox">
                <div id="userLabel" class="small"></div>
                <button id="openHomeAuth" class="ghost">Sign in on Home</button>
              </div>
            </div>
            <div class="controlRow controlRow--actions">
              <button id="createEntry" class="ghost">Create</button>
              <button id="reviewReportsBtn" class="ghost" style="display:none">Reports</button>
              <button id="newEntry" class="ghost">Discord</button>
            </div>
            <div class="controlRow" id="discoveryControls" style="justify-content:space-between;gap:10px">
              <div style="display:flex;gap:8px;flex-wrap:wrap;align-items:center">
                <select id="globalTypeSelect" style="min-width:140px">
                  <option value="all">All</option>
                  <option value="posts">Posts</option>
                  <option value="users">Users</option>
                  <option value="tags">Tags</option>
                </select>
                <select id="globalSearchSort" style="min-width:140px">
                  <option value="relevance">Search: Relevance</option>
                  <option value="newest">Search: Newest</option>
                </select>
                <select id="feedModeSelect" style="min-width:140px">
                  <option value="all">Feed: All</option>
                  <option value="following">Feed: Following</option>
                </select>
                <select id="sortSelect" style="min-width:170px">
                  <option value="newest">Newest</option>
                  <option value="oldest">Oldest</option>
                  <option value="highestRated">Highest rated</option>
                  <option value="mostViewed">Most viewed</option>
                  <option value="mostCommented">Most commented</option>
                  <option value="trending">Trending</option>
                </select>
                <select id="tagFilterSelect" style="min-width:170px">
                  <option value="">All tags</option>
                </select>
              </div>
              <div class="smallMuted" id="activeFilterLabel">Showing all posts</div>
            </div>
            <div id="globalSearchResults" class="globalSearchPanel" style="display:none"></div>
          </div>

          <div class="tagBar">
            <div id="tagPicker" class="tagPicker"></div>
            <div class="tagInput">
              <input id="customTag" placeholder="Add tag" />
              <button id="addTagBtn" class="ghost">Add Tag</button>
            </div>
          </div>

    <div class="communityStrip">
      <div class="statBlock">
        <div class="statLabel">Current Users</div>
        <div class="statValue" id="currentUsersValue">â€”</div>
      </div>
      <div class="statBlock">
        <div class="statLabel">Total Libraries</div>
        <div class="statValue" id="totalLibrariesValue">â€”</div>
      </div>
      <div class="staffPanel">
        <div class="staffBlock">
          <div class="statLabel">Owner</div>
          <div class="staffPills">
            <span class="staffPill staffPill--owner" id="staffOwnerValue">Loading...</span>
          </div>
        </div>
        <div class="staffBlock">
          <div class="statLabel">Moderators</div>
          <div class="staffPills" id="staffModerators">
            <span class="staffPill">Loading...</span>
          </div>
        </div>
      </div>
    </div>

    <div id="list" class="list"></div>
    <div id="pagination" class="paginationBar paginationBar--hidden"></div>
        </main>
      </div>
    </div>

  <template id="cardTpl">
    <div class="card">
      <div class="quickActions"></div>
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div>
          <div style="display:flex;align-items:center;gap:10px">
            <div class="cardAvatarWrap"><img class="cardAvatar" src="" alt="avatar"/></div>
            <div>
              <h3 class="title" style="margin:0"></h3>
              <div class="meta"><span class="author"></span><span class="sep">â€¢</span><a class="orig link" target="_blank">Original credit</a></div>
            </div>
          </div>
        </div>
        <div class="cardBadges"></div>
      </div>
      <div class="tagChips"></div>
      <div class="actions">
        <button class="toggle">Show code</button>
        <button class="copy">Copy</button>
        <button class="edit ghost" style="display:none">Edit</button>
        <button class="del ghost" style="display:none">Delete</button>
        <button class="ghost viewOrig">Open credit</button>
      </div>
      <div class="reactionRow"></div>
      <div class="codeWrap" style="display:none">
        <pre class="code" data-full=""></pre>
      </div>
      <div class="cardVisibilityRow" style="display:flex;justify-content:flex-end;margin-top:8px">
        <button type="button" class="ghost visibilityToggle">Public</button>
      </div>
    </div>
  </template>

  <script>
    // Sample libraries array â€” you can extend this or load from a JSON endpoint
    const libs = [
      {
        id: 'hollow-purple',
        title: 'Create a post to share your library with the community!',
        author: 'ADMIN - Kuro',
        description: 'Include details like title, description, tags, and code. You can also link to an original credit if your library is inspired by or based on someone else\'s work.',
        credit: 'https://www.youtube.com/@FFS-Productions',
        tags: ['help','guide','how-to'],
        visibility: 'public',
        // Put the long import code here (string). Keep it escaped as needed.
        code: `
Get a code from the character builder in jjs, then paste it here. When you click "Copy", the full code will be copied to your clipboard for easy sharing or use in your own builds.
`
      }
    ];
    const VISIBILITY = Object.freeze({ PUBLIC: 'public', PRIVATE: 'private' });
    function normalizeVisibility(value){
      return value === VISIBILITY.PRIVATE ? VISIBILITY.PRIVATE : VISIBILITY.PUBLIC;
    }
    function normalizeUsername(value){
      return (value || '').toString().trim().toLowerCase();
    }
    function normalizeWhitelistUsers(list, authorName){
      if(!Array.isArray(list)) return [];
      const seen = new Set();
      const authorLower = normalizeUsername(authorName);
      const cleaned = [];
      list.forEach(item=>{
        const raw = (item || '').toString().trim();
        if(!raw) return;
        const lower = normalizeUsername(raw);
        if(!lower || seen.has(lower)) return;
        if(authorLower && lower === authorLower) return;
        seen.add(lower);
        cleaned.push(raw);
      });
      return cleaned;
    }
    function getLibraryWhitelist(lib){
      return normalizeWhitelistUsers(lib && lib.whitelist, lib && lib.author);
    }
    function isStaffUser(user){
      return permissionGuard.hasPermission(user, OWNER_PERMISSIONS.MODERATION_ACCESS);
    }
    function isLibraryAuthor(user, lib){
      if(!user || !lib) return false;
      return normalizeUsername(user.username) === normalizeUsername(lib.author);
    }
    function isUserWhitelistedForLibrary(lib, user){
      if(!lib || !user || !user.username) return false;
      const userLower = normalizeUsername(user.username);
      return getLibraryWhitelist(lib).some(name=> normalizeUsername(name) === userLower);
    }
    function isLibVisibleToUser(lib, user){
      const state = normalizeVisibility(lib && lib.visibility);
      if(state !== VISIBILITY.PRIVATE) return true;
      if(!user || !user.username || !lib || !lib.author) return false;
      if(isStaffUser(user)) return true;
      if(isLibraryAuthor(user, lib)) return true;
      return isUserWhitelistedForLibrary(lib, user);
    }

    function normalizeRoleId(value){
      return (value || '').toString().trim().toLowerCase().replace(/[^a-z0-9_-]/g, '-');
    }

    function normalizeGradientValue(value){
      const text = String(value || '').trim();
      if(!text) return '';
      return /gradient\s*\(/i.test(text) ? text : '';
    }

    function normalizeRoleRecord(role){
      if(!role) return null;
      const id = normalizeRoleId(role.id || role.name);
      if(!id) return null;
      const rawColor = String(role.color || '#a9b9d3').trim() || '#a9b9d3';
      const gradient = normalizeGradientValue(role.gradient || rawColor);
      return {
        id,
        name: String(role.name || id).trim() || id,
        color: gradient ? '#a9b9d3' : rawColor,
        gradient,
        icon: String(role.icon || '').trim(),
        priority: Number.isFinite(Number(role.priority)) ? Number(role.priority) : 10,
        permissions: Array.isArray(role.permissions) ? role.permissions.filter(Boolean).map(String) : []
      };
    }

    function normalizeBadgeId(value){
      return (value || '').toString().trim().toLowerCase().replace(/[^a-z0-9_-]/g, '-');
    }

    function normalizeBadgeRecord(badge){
      if(!badge) return null;
      const id = normalizeBadgeId(badge.id || badge.name);
      if(!id) return null;
      const rawColor = String(badge.color || '#a9b9d3').trim() || '#a9b9d3';
      const gradient = normalizeGradientValue(badge.gradient || rawColor);
      return {
        id,
        name: String(badge.name || id).trim() || id,
        icon: String(badge.icon || 'ðŸ…').trim() || 'ðŸ…',
        color: gradient ? '#a9b9d3' : rawColor,
        gradient,
        tooltip: String(badge.tooltip || '').trim(),
        showInComments: badge.showInComments !== false
      };
    }

    function dedupeStringList(list){
      if(!Array.isArray(list)) return [];
      const seen = new Set();
      const out = [];
      list.forEach(item=>{
        const v = String(item || '').trim();
        if(!v) return;
        const lower = v.toLowerCase();
        if(seen.has(lower)) return;
        seen.add(lower);
        out.push(v);
      });
      return out;
    }

    function inferRoleFromStateBase(username){
      const normalized = (username || '').toLowerCase();
      if(!normalized) return 'member';
      if(staffState.owner && staffState.owner.username && staffState.owner.username.toLowerCase() === normalized) return 'owner';
      if(staffState.moderators.some(mod=> (mod.username || '').toLowerCase() === normalized)) return 'moderator';
      if(OWNER_USERNAME_LOWER && normalized === OWNER_USERNAME_LOWER) return 'owner';
      return 'member';
    }

    function loadOwnerControlState(force = false){
      if(ownerControlState.loaded && !force) return ownerControlState;
      let roles = DEFAULT_OWNER_ROLES.slice();
      let badges = [];
      let userRoles = {};
      let userBadges = {};
      try{
        const parsed = JSON.parse(localStorage.getItem(OWNER_ROLES_STORAGE_KEY) || '[]');
        if(Array.isArray(parsed) && parsed.length) roles = parsed;
      }catch(_e){}
      try{
        const parsed = JSON.parse(localStorage.getItem(OWNER_BADGES_STORAGE_KEY) || '[]');
        if(Array.isArray(parsed)) badges = parsed;
      }catch(_e){}
      try{
        const parsed = JSON.parse(localStorage.getItem(OWNER_USER_ROLES_STORAGE_KEY) || '{}');
        if(parsed && typeof parsed === 'object') userRoles = parsed;
      }catch(_e){}
      try{
        const parsed = JSON.parse(localStorage.getItem(OWNER_USER_BADGES_STORAGE_KEY) || '{}');
        if(parsed && typeof parsed === 'object') userBadges = parsed;
      }catch(_e){}
      const normalizedRoles = roles.map(normalizeRoleRecord).filter(Boolean);
      if(!normalizedRoles.some(r=>r.id === 'owner')) normalizedRoles.push(DEFAULT_OWNER_ROLES[0]);
      if(!normalizedRoles.some(r=>r.id === 'moderator')) normalizedRoles.push(DEFAULT_OWNER_ROLES[1]);
      if(!normalizedRoles.some(r=>r.id === 'member')) normalizedRoles.push(DEFAULT_OWNER_ROLES[2]);
      ownerControlState.roles = normalizedRoles.sort((a,b)=> Number(b.priority || 0) - Number(a.priority || 0));
      ownerControlState.badges = badges.map(normalizeBadgeRecord).filter(Boolean);
      ownerControlState.userRoles = userRoles;
      ownerControlState.userBadges = userBadges;
      ownerControlState.loaded = true;
      ownerControlState.lastLoadedAt = Date.now();
      return ownerControlState;
    }

    function persistOwnerControlState(){
      loadOwnerControlState();
      try{ localStorage.setItem(OWNER_ROLES_STORAGE_KEY, JSON.stringify(ownerControlState.roles)); }catch(_e){}
      try{ localStorage.setItem(OWNER_BADGES_STORAGE_KEY, JSON.stringify(ownerControlState.badges)); }catch(_e){}
      try{ localStorage.setItem(OWNER_USER_ROLES_STORAGE_KEY, JSON.stringify(ownerControlState.userRoles)); }catch(_e){}
      try{ localStorage.setItem(OWNER_USER_BADGES_STORAGE_KEY, JSON.stringify(ownerControlState.userBadges)); }catch(_e){}
    }

    function persistOwnerControlStateWithSync(){
      persistOwnerControlState();
      scheduleOwnerControlServerSave();
    }

    function applyOwnerControlStateFromPayload(payload){
      const normalized = payload && typeof payload === 'object' ? payload : {};
      const roles = Array.isArray(normalized.roles) ? normalized.roles.map(normalizeRoleRecord).filter(Boolean) : [];
      const badges = Array.isArray(normalized.badges) ? normalized.badges.map(normalizeBadgeRecord).filter(Boolean) : [];
      const userRoles = normalized.userRoles && typeof normalized.userRoles === 'object' ? normalized.userRoles : {};
      const userBadges = normalized.userBadges && typeof normalized.userBadges === 'object' ? normalized.userBadges : {};

      if(!roles.some(r=>r.id === 'owner')) roles.push(DEFAULT_OWNER_ROLES[0]);
      if(!roles.some(r=>r.id === 'moderator')) roles.push(DEFAULT_OWNER_ROLES[1]);
      if(!roles.some(r=>r.id === 'member')) roles.push(DEFAULT_OWNER_ROLES[2]);

      ownerControlState.roles = roles.sort((a,b)=> Number(b.priority || 0) - Number(a.priority || 0));
      ownerControlState.badges = badges;
      ownerControlState.userRoles = userRoles;
      ownerControlState.userBadges = userBadges;
      ownerControlState.loaded = true;
      ownerControlState.lastLoadedAt = Date.now();
      persistOwnerControlState();
    }

    async function refreshOwnerControlFromServer(force = false){
      if(!OWNER_CONTROL_URL) return ownerControlState;
      const age = Date.now() - (ownerControlSyncState.lastRemoteSyncAt || 0);
      if(!force && ownerControlSyncState.fetchPromise) return ownerControlSyncState.fetchPromise;
      if(!force && age < 30000 && ownerControlState.loaded) return ownerControlState;
      ownerControlSyncState.fetchPromise = (async ()=>{
        try{
          const resp = await fetch(OWNER_CONTROL_URL + '?action=ownerControlGet', { cache:'no-store' });
          const data = await resp.json().catch(()=>null);
          if(resp.ok && data && data.ok && data.state){
            applyOwnerControlStateFromPayload(data.state);
            ownerControlSyncState.lastRemoteSyncAt = Date.now();
          }else{
            loadOwnerControlState();
          }
        }catch(_err){
          loadOwnerControlState();
        }finally{
          ownerControlSyncState.fetchPromise = null;
        }
        return ownerControlState;
      })();
      return ownerControlSyncState.fetchPromise;
    }

    async function pushOwnerControlToServer(){
      if(!OWNER_CONTROL_URL) return;
      const token = getToken();
      if(!token) return;
      const state = loadOwnerControlState();
      const payload = {
        roles: state.roles,
        badges: state.badges,
        userRoles: state.userRoles,
        userBadges: state.userBadges
      };
      const resp = await fetch(OWNER_CONTROL_URL + '?action=ownerControlSave', {
        method:'POST',
        headers:{ 'Content-Type':'application/json', 'Authorization':'Bearer ' + token },
        body: JSON.stringify({ state: payload })
      });
      const data = await resp.json().catch(()=>null);
      if(!resp.ok || !data || !data.ok) throw new Error((data && data.error) || 'Failed to sync role/badge changes');
      if(data.state) applyOwnerControlStateFromPayload(data.state);
      ownerControlSyncState.lastRemoteSyncAt = Date.now();
    }

    function scheduleOwnerControlServerSave(){
      if(ownerControlSyncState.saveTimer) clearTimeout(ownerControlSyncState.saveTimer);
      ownerControlSyncState.pendingSave = true;
      ownerControlSyncState.saveTimer = setTimeout(async ()=>{
        if(ownerControlSyncState.savePromise) return;
        ownerControlSyncState.savePromise = (async ()=>{
          try{
            if(ownerControlSyncState.pendingSave) await pushOwnerControlToServer();
          }catch(err){
            console.warn('Owner-control sync failed', err && err.message ? err.message : err);
          }finally{
            ownerControlSyncState.pendingSave = false;
            ownerControlSyncState.savePromise = null;
          }
        })();
        await ownerControlSyncState.savePromise;
      }, 180);
    }

    function logOwnerAction(action, details){
      const user = getCurrentUser();
      const entry = {
        t: Date.now(),
        by: user && user.username ? user.username : 'unknown',
        action: String(action || '').trim() || 'action',
        details: String(details || '').trim()
      };
      try{
        const raw = JSON.parse(localStorage.getItem(OWNER_ACTIVITY_LOG_KEY) || '[]');
        const list = Array.isArray(raw) ? raw : [];
        list.unshift(entry);
        localStorage.setItem(OWNER_ACTIVITY_LOG_KEY, JSON.stringify(list.slice(0, 250)));
      }catch(_e){}
    }

    function getKnownUsersList(){
      const setValue = new Set();
      libs.forEach(lib=>{
        if(lib && lib.author) setValue.add(String(lib.author));
        const comments = Array.isArray(lib && lib.comments) ? lib.comments : [];
        const walk = (arr)=>{
          (arr || []).forEach(c=>{
            if(c && c.author) setValue.add(String(c.author));
            if(Array.isArray(c && c.replies)) walk(c.replies);
          });
        };
        walk(comments);
      });
      if(staffState.owner && staffState.owner.username) setValue.add(staffState.owner.username);
      (staffState.moderators || []).forEach(mod=>{ if(mod && mod.username) setValue.add(mod.username); });
      const me = getCurrentUser();
      if(me && me.username) setValue.add(me.username);
      return Array.from(setValue)
        .map(name=> String(name || '').trim())
        .filter(Boolean)
        .sort((a,b)=> a.localeCompare(b, undefined, { sensitivity:'base' }));
    }

    function searchKnownUsers(query){
      const text = String(query || '').trim().toLowerCase();
      const users = getKnownUsersList();
      if(!text) return users.slice(0, 40);
      return users.filter(name=> name.toLowerCase().includes(text)).slice(0, 60);
    }

    const roleService = {
      getAll(){
        return loadOwnerControlState().roles.slice().sort((a,b)=> Number(b.priority || 0) - Number(a.priority || 0));
      },
      getById(roleId){
        const key = normalizeRoleId(roleId);
        return this.getAll().find(role=> role.id === key) || null;
      },
      create(input){
        const state = loadOwnerControlState();
        const record = normalizeRoleRecord(input);
        if(!record) throw new Error('Invalid role');
        if(state.roles.some(role=> role.id === record.id)) throw new Error('Role already exists');
        state.roles.push(record);
        state.roles.sort((a,b)=> Number(b.priority || 0) - Number(a.priority || 0));
        persistOwnerControlStateWithSync();
        logOwnerAction('role.create', `${record.name}`);
        return record;
      },
      update(roleId, changes){
        const state = loadOwnerControlState();
        const key = normalizeRoleId(roleId);
        const idx = state.roles.findIndex(role=> role.id === key);
        if(idx < 0) throw new Error('Role not found');
        const next = normalizeRoleRecord({ ...state.roles[idx], ...changes, id: state.roles[idx].id });
        if(!next) throw new Error('Invalid role update');
        state.roles[idx] = next;
        state.roles.sort((a,b)=> Number(b.priority || 0) - Number(a.priority || 0));
        persistOwnerControlStateWithSync();
        logOwnerAction('role.update', `${next.name}`);
        return next;
      },
      delete(roleId){
        const state = loadOwnerControlState();
        const key = normalizeRoleId(roleId);
        if(key === 'owner') throw new Error('Owner role cannot be deleted');
        const role = state.roles.find(item=> item.id === key);
        if(!role) throw new Error('Role not found');
        state.roles = state.roles.filter(item=> item.id !== key);
        Object.keys(state.userRoles).forEach(userKey=>{
          state.userRoles[userKey] = dedupeStringList((state.userRoles[userKey] || []).filter(item=> normalizeRoleId(item) !== key));
          if(!state.userRoles[userKey].length) delete state.userRoles[userKey];
        });
        persistOwnerControlStateWithSync();
        logOwnerAction('role.delete', `${role.name}`);
      },
      getUserRoles(username){
        const state = loadOwnerControlState();
        const normalized = normalizeUsername(username);
        if(!normalized) return [];
        const explicit = dedupeStringList(state.userRoles[normalized] || []).map(normalizeRoleId).filter(Boolean);
        const inferred = inferRoleFromStateBase(username);
        const list = explicit.slice();
        if(inferred === 'owner' && !list.includes('owner')) list.push('owner');
        if(inferred === 'moderator' && !list.includes('moderator')) list.push('moderator');
        if(!list.length) list.push('member');
        return dedupeStringList(list);
      },
      assignRole(username, roleId){
        const state = loadOwnerControlState();
        const userKey = normalizeUsername(username);
        if(!userKey) throw new Error('Username required');
        const key = normalizeRoleId(roleId);
        if(!this.getById(key)) throw new Error('Role does not exist');
        const current = dedupeStringList(state.userRoles[userKey] || []).map(normalizeRoleId);
        if(!current.includes(key)) current.push(key);
        state.userRoles[userKey] = dedupeStringList(current);
        persistOwnerControlStateWithSync();
        logOwnerAction('role.assign', `${username} -> ${key}`);
      },
      removeRole(username, roleId){
        const state = loadOwnerControlState();
        const userKey = normalizeUsername(username);
        if(!userKey) throw new Error('Username required');
        const key = normalizeRoleId(roleId);
        if(key === 'owner' && normalizeUsername(username) === normalizeUsername(staffState.owner && staffState.owner.username || OWNER_USERNAME)){
          throw new Error('Cannot remove owner role from platform owner');
        }
        const next = dedupeStringList((state.userRoles[userKey] || []).map(normalizeRoleId).filter(item=> item !== key));
        if(next.length) state.userRoles[userKey] = next;
        else delete state.userRoles[userKey];
        persistOwnerControlStateWithSync();
        logOwnerAction('role.remove', `${username} -/-> ${key}`);
      }
    };

    const badgeService = {
      getAll(){ return loadOwnerControlState().badges.slice(); },
      getById(badgeId){
        const key = normalizeBadgeId(badgeId);
        return this.getAll().find(badge=> badge.id === key) || null;
      },
      create(input){
        const state = loadOwnerControlState();
        const record = normalizeBadgeRecord(input);
        if(!record) throw new Error('Invalid badge');
        if(state.badges.some(badge=> badge.id === record.id)) throw new Error('Badge already exists');
        state.badges.push(record);
        persistOwnerControlStateWithSync();
        logOwnerAction('badge.create', `${record.name}`);
        return record;
      },
      update(badgeId, changes){
        const state = loadOwnerControlState();
        const key = normalizeBadgeId(badgeId);
        const idx = state.badges.findIndex(badge=> badge.id === key);
        if(idx < 0) throw new Error('Badge not found');
        const next = normalizeBadgeRecord({ ...state.badges[idx], ...changes, id: state.badges[idx].id });
        if(!next) throw new Error('Invalid badge update');
        state.badges[idx] = next;
        persistOwnerControlStateWithSync();
        logOwnerAction('badge.update', `${next.name}`);
        return next;
      },
      delete(badgeId){
        const state = loadOwnerControlState();
        const key = normalizeBadgeId(badgeId);
        const badge = state.badges.find(item=> item.id === key);
        if(!badge) throw new Error('Badge not found');
        state.badges = state.badges.filter(item=> item.id !== key);
        Object.keys(state.userBadges).forEach(userKey=>{
          state.userBadges[userKey] = dedupeStringList((state.userBadges[userKey] || []).filter(item=> normalizeBadgeId(item) !== key));
          if(!state.userBadges[userKey].length) delete state.userBadges[userKey];
        });
        persistOwnerControlStateWithSync();
        logOwnerAction('badge.delete', `${badge.name}`);
      },
      getUserBadges(username){
        const state = loadOwnerControlState();
        const key = normalizeUsername(username);
        if(!key) return [];
        return dedupeStringList(state.userBadges[key] || []).map(normalizeBadgeId).filter(Boolean);
      },
      assignBadge(username, badgeId){
        const state = loadOwnerControlState();
        const userKey = normalizeUsername(username);
        if(!userKey) throw new Error('Username required');
        const key = normalizeBadgeId(badgeId);
        if(!this.getById(key)) throw new Error('Badge does not exist');
        const next = dedupeStringList([...(state.userBadges[userKey] || []), key]);
        state.userBadges[userKey] = next;
        persistOwnerControlStateWithSync();
        logOwnerAction('badge.assign', `${username} -> ${key}`);
      },
      removeBadge(username, badgeId){
        const state = loadOwnerControlState();
        const userKey = normalizeUsername(username);
        if(!userKey) throw new Error('Username required');
        const key = normalizeBadgeId(badgeId);
        const next = dedupeStringList((state.userBadges[userKey] || []).filter(item=> normalizeBadgeId(item) !== key));
        if(next.length) state.userBadges[userKey] = next;
        else delete state.userBadges[userKey];
        persistOwnerControlStateWithSync();
        logOwnerAction('badge.remove', `${username} -/-> ${key}`);
      }
    };

    function inferRoleFromState(username){
      const roles = roleService.getUserRoles(username);
      const catalog = roleService.getAll();
      const role = roles
        .map(roleId=> catalog.find(item=> item.id === normalizeRoleId(roleId)))
        .filter(Boolean)
        .sort((a,b)=> Number(b.priority || 0) - Number(a.priority || 0))[0];
      return role ? role.id : inferRoleFromStateBase(username);
    }

    const permissionGuard = {
      getRolesForUser(user){
        if(!user || !user.username) return ['member'];
        return roleService.getUserRoles(user.username);
      },
      hasPermission(user, permission){
        if(!user || !permission) return false;
        const roleIds = this.getRolesForUser(user);
        if(roleIds.includes('owner')) return true;
        const roleCatalog = roleService.getAll();
        return roleIds.some(roleId=>{
          const role = roleCatalog.find(item=> item.id === normalizeRoleId(roleId));
          return !!(role && Array.isArray(role.permissions) && role.permissions.includes(permission));
        });
      },
      requireOwner(user){
        if(!this.hasPermission(user, OWNER_PERMISSIONS.OWNER_PANEL)) throw new Error('Owner access required');
      },
      getModerationPriority(user){
        if(!user || !user.username) return 0;
        const roleCatalog = roleService.getAll();
        return this.getRolesForUser(user)
          .map(roleId=> roleCatalog.find(item=> item.id === normalizeRoleId(roleId)))
          .filter(Boolean)
          .reduce((acc, role)=> Math.max(acc, Number(role.priority || 0)), 0);
      }
    };
    const PAGE_SIZE = 12;
    let currentPage = 1;
    let filteredResults = libs.slice();
    let remoteLibsInitialized = false;
    const REACTION_OPTIONS = ['ðŸ‘','â¤ï¸','ðŸ˜‚','ðŸ˜®','ðŸ”¥'];
    const TOP_RATED_MIN_RATINGS = 3;
    const TOP_RATED_MIN_AVG = 4.2;
    const POST_COOLDOWN_MS = Number(window.POST_COOLDOWN_MS || 90 * 1000);
    const SORT_OPTIONS = Object.freeze({
      NEWEST: 'newest',
      OLDEST: 'oldest',
      HIGHEST_RATED: 'highestRated',
      MOST_VIEWED: 'mostViewed',
      MOST_COMMENTED: 'mostCommented',
      TRENDING: 'trending'
    });
    const REPORTS_STORAGE_KEY = 'jjs_post_reports';
    const OWNER_ROLES_STORAGE_KEY = 'jjs_owner_roles';
    const OWNER_BADGES_STORAGE_KEY = 'jjs_owner_badges';
    const OWNER_USER_ROLES_STORAGE_KEY = 'jjs_owner_user_roles';
    const OWNER_USER_BADGES_STORAGE_KEY = 'jjs_owner_user_badges';
    const OWNER_ACTIVITY_LOG_KEY = 'jjs_owner_activity_log';
    const OWNER_PERMISSIONS = Object.freeze({
      OWNER_PANEL: 'owner.panel',
      MODERATION_ACCESS: 'moderation.access',
      MODERATION_TOOLS: 'moderation.tools',
      ROLES_MANAGE: 'roles.manage',
      BADGES_MANAGE: 'badges.manage',
      COMMANDS_RUN: 'commands.run'
    });
    const DEFAULT_OWNER_ROLES = [
      { id:'owner', name:'Owner', color:'#f5c77d', icon:'ðŸ‘‘', priority:1000, permissions:Object.values(OWNER_PERMISSIONS) },
      { id:'moderator', name:'Moderator', color:'#85c6ff', icon:'ðŸ›¡', priority:700, permissions:[OWNER_PERMISSIONS.MODERATION_ACCESS, OWNER_PERMISSIONS.MODERATION_TOOLS] },
      { id:'member', name:'Member', color:'#a9b9d3', icon:'', priority:10, permissions:[] }
    ];
    const ownerControlState = {
      loaded: false,
      roles: [],
      badges: [],
      userRoles: {},
      userBadges: {},
      lastLoadedAt: 0
    };
    const ownerControlSyncState = {
      fetchPromise: null,
      saveTimer: null,
      savePromise: null,
      pendingSave: false,
      lastRemoteSyncAt: 0
    };
    let activeSort = SORT_OPTIONS.NEWEST;
    let activeTagFilter = '';
    let activeFeedMode = 'all';
    let activeGlobalType = 'all';
    let activeGlobalSearchSort = 'relevance';
    let searchDebounceTimer = null;
    const AVATAR_FOLDER = (window.AVATAR_FOLDER || 'libs/avatars').toString().replace(/\\/g,'/').replace(/^\/+/,'').replace(/\/+$/,'');
    const DEFAULT_AVATAR_URL = '';
    const FALLBACK_AVATAR_DATA_URI = 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="80" height="80" viewBox="0 0 80 80"><rect width="80" height="80" rx="26" fill="%231f2436"/><circle cx="40" cy="30" r="18" fill="%23495773"/><rect x="18" y="52" width="44" height="18" rx="9" fill="%23495773"/></svg>';

    const listEl = document.getElementById('list');
    const paginationEl = document.getElementById('pagination');
    const tpl = document.getElementById('cardTpl');
    const search = document.getElementById('search');
    const BAD_WORDS = ['fuck','nigger','nigga','bitch','shit','pussy'];
    const BAD_WORD_REPLACEMENT = '@#%!';
    const BAD_WORD_REGEX = new RegExp('\\b(' + BAD_WORDS.map(w=>w.replace(/[-/\\^$*+?.()|[\]{}]/g,'\\$&')).join('|') + ')\\b','gi');
    const VIDEO_DURATION_LIMIT_SECONDS = 60;
    const REMOTE_SAVE_MAX_BYTES = 4 * 1024 * 1024; // Vercel body limit ~4MB
    const VIDEO_MAX_SIZE_BYTES = Math.min(25 * 1024 * 1024, Math.floor(REMOTE_SAVE_MAX_BYTES * 0.75));
    const ALLOWED_VIDEO_TYPES = ['video/mp4','video/webm','video/ogg'];

    function censorBadWords(text){
      if(typeof text !== 'string' || !text.trim()) return text;
      return text.replace(BAD_WORD_REGEX, BAD_WORD_REPLACEMENT);
    }

    function sanitizeLibraryContent(lib){
      if(!lib) return lib;
      if(typeof lib.title === 'string') lib.title = censorBadWords(lib.title);
      if(typeof lib.description === 'string') lib.description = censorBadWords(lib.description);
      if(typeof lib.author === 'string') lib.author = censorBadWords(lib.author);
      if(Array.isArray(lib.tags)) lib.tags = lib.tags.map(tag=>censorBadWords(tag || ''));
      lib.visibility = normalizeVisibility(lib.visibility);
      lib.whitelist = getLibraryWhitelist(lib);
      if(!Number.isFinite(Number(lib.createdAt))) lib.createdAt = Number(lib.id) || Date.now();
      if(!Number.isFinite(Number(lib.views))) lib.views = 0;
      lib.pinned = !!lib.pinned;
      if(!lib.reactions || typeof lib.reactions !== 'object') lib.reactions = {};
      return lib;
    }

    libs.forEach(sanitizeLibraryContent);

    function getUserJoinDate(username){
      const normalized = normalizeUsername(username);
      if(!normalized) return null;
      const storeKey = 'jjs_join_dates';
      let store = {};
      try{ store = JSON.parse(localStorage.getItem(storeKey) || '{}') || {}; }catch(_e){ store = {}; }
      if(!store[normalized]){
        store[normalized] = Date.now();
        try{ localStorage.setItem(storeKey, JSON.stringify(store)); }catch(_e){}
      }
      return Number(store[normalized]) || null;
    }

    function ensureCurrentUserJoinDate(){
      const user = getCurrentUser();
      if(!user || !user.username) return;
      getUserJoinDate(user.username);
    }

    function getBookmarksKey(username){
      return 'jjs_bookmarks_' + normalizeUsername(username);
    }

    function getBookmarkSet(username){
      if(!username) return new Set();
      try{
        const raw = JSON.parse(localStorage.getItem(getBookmarksKey(username)) || '[]');
        return new Set(Array.isArray(raw) ? raw.map(String) : []);
      }catch(_e){
        return new Set();
      }
    }

    function saveBookmarkSet(username, setValue){
      if(!username) return;
      try{ localStorage.setItem(getBookmarksKey(username), JSON.stringify(Array.from(setValue || new Set()))); }catch(_e){}
    }

    function toggleBookmarkLib(lib){
      const user = getCurrentUser();
      if(!user) return { changed:false, bookmarked:false, reason:'Sign in to bookmark posts' };
      const setValue = getBookmarkSet(user.username);
      const key = String(lib && lib.id || '');
      if(!key) return { changed:false, bookmarked:false, reason:'Invalid post id' };
      let bookmarked;
      if(setValue.has(key)){
        setValue.delete(key);
        bookmarked = false;
      }else{
        setValue.add(key);
        bookmarked = true;
      }
      saveBookmarkSet(user.username, setValue);
      return { changed:true, bookmarked };
    }

    function getCommentCount(lib){
      const walk = (arr)=>{
        if(!Array.isArray(arr) || !arr.length) return 0;
        return arr.reduce((acc, item)=> acc + 1 + walk(item && item.replies), 0);
      };
      return walk(Array.isArray(lib && lib.comments) ? lib.comments : []);
    }

    function isTopRatedLibrary(lib){
      const stats = getRatingStats(lib);
      return stats.count >= TOP_RATED_MIN_RATINGS && stats.avg >= TOP_RATED_MIN_AVG;
    }

    function getTrendingScore(lib){
      const stats = getRatingStats(lib);
      const views = Number(lib && lib.views) || 0;
      const comments = getCommentCount(lib);
      const createdAt = Number(lib && lib.createdAt) || Date.now();
      const ageHours = Math.max(1, (Date.now() - createdAt) / (1000 * 60 * 60));
      const decay = 1 / Math.pow(ageHours / 24 + 1, 0.85);
      const base = (views * 0.6) + (stats.avg * Math.max(1, stats.count) * 4) + (comments * 3);
      return base * decay;
    }

    function getPinnedAndRegular(items){
      const pinned = [];
      const regular = [];
      (items || []).forEach(item=>{
        if(item && item.pinned) pinned.push(item);
        else regular.push(item);
      });
      return { pinned, regular };
    }

    function sortLibraries(items, sortKey){
      const list = (items || []).slice();
      const compare = {
        [SORT_OPTIONS.NEWEST]: (a,b)=> (Number(b.createdAt) || 0) - (Number(a.createdAt) || 0),
        [SORT_OPTIONS.OLDEST]: (a,b)=> (Number(a.createdAt) || 0) - (Number(b.createdAt) || 0),
        [SORT_OPTIONS.HIGHEST_RATED]: (a,b)=> getRatingStats(b).avg - getRatingStats(a).avg,
        [SORT_OPTIONS.MOST_VIEWED]: (a,b)=> (Number(b.views) || 0) - (Number(a.views) || 0),
        [SORT_OPTIONS.MOST_COMMENTED]: (a,b)=> getCommentCount(b) - getCommentCount(a),
        [SORT_OPTIONS.TRENDING]: (a,b)=> getTrendingScore(b) - getTrendingScore(a)
      };
      const sorter = compare[sortKey] || compare[SORT_OPTIONS.NEWEST];
      list.sort(sorter);
      return list;
    }

    function getFilteredSortedLibs(queryText){
      const viewer = getCurrentUser();
      const query = (queryText || '').trim().toLowerCase();
      const visible = libs.filter(lib=> isLibVisibleToUser(lib, viewer));
      const followingSet = getFollowingSetForCurrentUser();
      const feedFiltered = visible.filter(lib=>{
        if(activeFeedMode !== 'following') return true;
        if(!viewer || !viewer.username) return false;
        if(normalizeUsername(lib.author) === normalizeUsername(viewer.username)) return true;
        return followingSet.has(normalizeUsername(lib.author));
      });
      const matched = feedFiltered.filter(lib=>{
        if(activeTagFilter){
          const hasTag = (lib.tags || []).some(tag=> (tag || '').toLowerCase() === activeTagFilter);
          if(!hasTag) return false;
        }
        if(!query) return true;
        const titleMatch = (lib.title || '').toLowerCase().includes(query);
        const tagMatch = (lib.tags || []).some(tag=> (tag || '').toLowerCase().includes(query));
        const authorMatch = (lib.author || '').toLowerCase().includes(query);
        return titleMatch || tagMatch || authorMatch;
      });
      const { pinned, regular } = getPinnedAndRegular(matched);
      const sortedPinned = sortLibraries(pinned, activeSort);
      const sortedRegular = sortLibraries(regular, activeSort);
      return [...sortedPinned, ...sortedRegular];
    }

    function getFollowingSetForCurrentUser(){
      const user = getCurrentUser();
      if(!user || !user.username) return new Set();
      const key = getSocialStorageKey(user.username);
      const legacyKey = 'jjs_social_' + user.username;
      let following = [];
      const cached = socialCache.get(normalizeUsernameKey(user.username)) || socialCache.get(user.username);
      if(cached && Array.isArray(cached.following)) following = cached.following;
      if(!following.length){
        try{
          const social = JSON.parse(localStorage.getItem(key) || localStorage.getItem(legacyKey) || '{}');
          following = Array.isArray(social.following) ? social.following : [];
        }catch(_e){ following = []; }
      }
      return new Set(normalizeUserList(following).map(normalizeUsername));
    }

    function getCachedSocialSnapshot(username){
      if(!username) return {};
      const normalizedUser = normalizeUsernameKey(username);
      const cached = socialCache.get(normalizedUser) || socialCache.get(username);
      if(cached) return cached;
      try{
        return JSON.parse(localStorage.getItem(getSocialStorageKey(username)) || localStorage.getItem('jjs_social_' + username) || '{}') || {};
      }catch(_e){
        return {};
      }
    }

    function getRoleBadgeEntries(username, social, opts = {}){
      const context = opts.context || 'default';
      const badges = [];
      const roleCatalog = roleService.getAll();
      const roleIds = roleService.getUserRoles(username);
      roleIds
        .map(roleId=> roleCatalog.find(role=> role.id === normalizeRoleId(roleId)))
        .filter(Boolean)
        .sort((a,b)=> Number(b.priority || 0) - Number(a.priority || 0))
        .forEach(role=>{
          if(role.id === 'member') return;
          const short = (role.icon || role.name || role.id || 'R').slice(0, 3).toUpperCase();
          const cls = role.id === 'owner' ? 'roleBadge--owner' : (role.id === 'moderator' ? 'roleBadge--moderator' : 'roleBadge--custom');
          badges.push({ label: role.name, short, name: role.name, cls, color: role.color, gradient: role.gradient });
        });

      const assignedBadges = badgeService.getUserBadges(username)
        .map(badgeId=> badgeService.getById(badgeId))
        .filter(Boolean)
        .filter(badge=> context !== 'comment' || badge.showInComments !== false)
        .map(badge=>({ label: badge.tooltip || badge.name, short: (badge.icon || badge.name || 'ðŸ…').slice(0, 3), name: badge.name, cls:'roleBadge--custom', color: badge.color, gradient: badge.gradient }));
      badges.push(...assignedBadges);

      const socialData = social || getCachedSocialSnapshot(username);
      if(socialData && socialData.verifiedCreator) badges.push({ label:'Verified Creator', short:'âœ“', name:'Verified Creator', cls:'roleBadge--verified' });
      if(socialData && socialData.ogUser) badges.push({ label:'OG User', short:'OG', name:'OG User', cls:'roleBadge--og' });
      return badges;
    }

    function renderRoleBadgesInline(container, username, social, opts = {}){
      if(!container) return;
      const badges = getRoleBadgeEntries(username, social, opts);
      const existing = container.querySelector('.roleBadges');
      if(existing) existing.remove();
      if(!badges.length) return;
      const showNames = !!opts.showNames;
      const wrap = document.createElement('span');
      wrap.className = 'roleBadges';
      badges.forEach(badge=>{
        const item = document.createElement('span');
        item.className = `roleBadge ${badge.cls}${showNames ? ' roleBadge--named' : ''}`;
        item.title = badge.label;
        if(badge.color) item.style.setProperty('--badge-color', badge.color);
        if(badge.gradient){
          item.style.background = badge.gradient;
          item.style.borderColor = 'rgba(255,255,255,0.42)';
        }
        if(showNames){
          const iconEl = document.createElement('span');
          iconEl.className = 'roleBadgeIcon';
          iconEl.textContent = badge.short;
          const nameEl = document.createElement('span');
          nameEl.className = 'roleBadgeName';
          nameEl.textContent = badge.name || badge.label || '';
          item.appendChild(iconEl);
          item.appendChild(nameEl);
        }else{
          item.textContent = badge.short;
        }
        wrap.appendChild(item);
      });
      container.appendChild(wrap);
    }

    function escapeRegExp(value){
      return (value || '').replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }

    function highlightMatch(text, query){
      const safeText = escapeHtml(String(text || ''));
      const q = (query || '').trim();
      if(!q) return safeText;
      const regex = new RegExp(`(${escapeRegExp(q)})`, 'ig');
      return safeText.replace(regex, '<mark>$1</mark>');
    }

    function buildGlobalSearchResults(query){
      const text = (query || '').trim();
      if(!text) return { posts: [], users: [], tags: [] };
      const q = text.toLowerCase();
      const viewer = getCurrentUser();
      const visiblePosts = libs.filter(lib=> isLibVisibleToUser(lib, viewer));

      const posts = visiblePosts
        .map(lib=>{
          const title = String(lib.title || '');
          const author = String(lib.author || '');
          const tags = (lib.tags || []).join(' ');
          const hay = `${title} ${author} ${tags}`.toLowerCase();
          const score = (hay.includes(q) ? 1 : 0) + (title.toLowerCase().includes(q) ? 2 : 0);
          if(!score) return null;
          return { id: lib.id, title, author, createdAt: Number(lib.createdAt) || 0, score };
        })
        .filter(Boolean)
        .sort((a,b)=> activeGlobalSearchSort === 'newest' ? b.createdAt - a.createdAt : b.score - a.score);

      const userMap = new Map();
      visiblePosts.forEach(lib=>{
        const name = String(lib.author || '').trim();
        if(!name) return;
        const lower = name.toLowerCase();
        const item = userMap.get(lower) || { username:name, count:0, latest:0 };
        item.count += 1;
        item.latest = Math.max(item.latest, Number(lib.createdAt) || 0);
        userMap.set(lower, item);
      });
      const users = Array.from(userMap.values())
        .filter(item=> item.username.toLowerCase().includes(q))
        .sort((a,b)=> activeGlobalSearchSort === 'newest' ? b.latest - a.latest : b.count - a.count);

      const tagMap = new Map();
      visiblePosts.forEach(lib=>{
        (lib.tags || []).forEach(tag=>{
          const clean = String(tag || '').trim();
          if(!clean) return;
          const lower = clean.toLowerCase();
          tagMap.set(lower, (tagMap.get(lower) || 0) + 1);
        });
      });
      const tags = Array.from(tagMap.entries())
        .filter(([tag])=> tag.includes(q))
        .map(([tag,count])=> ({ tag, count }))
        .sort((a,b)=> b.count - a.count);

      return { posts, users, tags };
    }

    function renderGlobalSearchResults(query){
      const panel = document.getElementById('globalSearchResults');
      if(!panel) return;
      const text = (query || '').trim();
      if(!text){ panel.style.display = 'none'; panel.innerHTML = ''; return; }
      const groups = buildGlobalSearchResults(text);
      const showPosts = activeGlobalType === 'all' || activeGlobalType === 'posts';
      const showUsers = activeGlobalType === 'all' || activeGlobalType === 'users';
      const showTags = activeGlobalType === 'all' || activeGlobalType === 'tags';
      panel.innerHTML = '';
      const appendGroup = (title, items)=>{
        const group = document.createElement('div');
        group.className = 'globalSearchGroup';
        group.innerHTML = `<div class="smallMuted">${title}</div>`;
        items.forEach(node=> group.appendChild(node));
        panel.appendChild(group);
      };

      if(showPosts && groups.posts.length){
        const nodes = groups.posts.slice(0, 8).map(item=>{
          const row = document.createElement('div');
          row.className = 'globalSearchItem';
          row.innerHTML = `<div>${highlightMatch(censorBadWords(item.title), text)}</div><div class="smallMuted">by ${highlightMatch(censorBadWords(item.author), text)}</div>`;
          row.addEventListener('click', ()=>{
            activeGlobalType = 'posts';
            const input = document.getElementById('search');
            if(input) input.value = item.title;
            refreshListView({ refilter:true, resetPage:true, animate:true });
          });
          return row;
        });
        appendGroup('Posts', nodes);
      }

      if(showUsers && groups.users.length){
        const nodes = groups.users.slice(0, 8).map(item=>{
          const row = document.createElement('div');
          row.className = 'globalSearchItem';
          row.innerHTML = `<div>${highlightMatch(censorBadWords(item.username), text)}</div><div class="smallMuted">${item.count} post${item.count===1?'':'s'}</div>`;
          row.addEventListener('click', ()=> openProfile(item.username));
          return row;
        });
        appendGroup('Users', nodes);
      }

      if(showTags && groups.tags.length){
        const nodes = groups.tags.slice(0, 10).map(item=>{
          const row = document.createElement('div');
          row.className = 'globalSearchItem';
          row.innerHTML = `<div>#${highlightMatch(censorBadWords(item.tag), text)}</div><div class="smallMuted">${item.count} post${item.count===1?'':'s'}</div>`;
          row.addEventListener('click', ()=>{
            activeTagFilter = item.tag;
            const tagSelect = document.getElementById('tagFilterSelect');
            if(tagSelect) tagSelect.value = item.tag;
            refreshListView({ refilter:true, resetPage:true, animate:true });
          });
          return row;
        });
        appendGroup('Tags', nodes);
      }

      if(!panel.innerHTML){
        panel.innerHTML = '<div class="smallMuted">No results found.</div>';
      }
      panel.style.display = 'block';
    }

    function refreshTagFilterOptions(){
      const select = document.getElementById('tagFilterSelect');
      if(!select) return;
      const viewer = getCurrentUser();
      const tags = new Set();
      libs.forEach(lib=>{
        if(!isLibVisibleToUser(lib, viewer)) return;
        (lib.tags || []).forEach(tag=>{
          const clean = (tag || '').trim();
          if(clean) tags.add(clean);
        });
      });
      const sorted = Array.from(tags).sort((a,b)=>a.localeCompare(b));
      const current = activeTagFilter;
      select.innerHTML = '<option value="">All tags</option>';
      sorted.forEach(tag=>{
        const opt = document.createElement('option');
        opt.value = tag.toLowerCase();
        opt.textContent = tag;
        select.appendChild(opt);
      });
      select.value = current;
    }

    function updateActiveFilterLabel(){
      const label = document.getElementById('activeFilterLabel');
      if(!label) return;
      const parts = [];
      if(activeTagFilter) parts.push(`Tag: ${activeTagFilter}`);
      if(activeSort && activeSort !== SORT_OPTIONS.NEWEST) parts.push(`Sort: ${activeSort}`);
      label.textContent = parts.length ? parts.join(' â€¢ ') : 'Showing all posts';
    }

    function getReactionStore(lib){
      if(!lib || !lib.reactions || typeof lib.reactions !== 'object') lib.reactions = {};
      REACTION_OPTIONS.forEach(key=>{
        if(!Array.isArray(lib.reactions[key])) lib.reactions[key] = [];
      });
      return lib.reactions;
    }

    function getUserReaction(lib, username){
      if(!lib || !username) return null;
      const reactions = getReactionStore(lib);
      const lower = normalizeUsername(username);
      for(const emoji of REACTION_OPTIONS){
        if((reactions[emoji] || []).some(name=> normalizeUsername(name) === lower)) return emoji;
      }
      return null;
    }

    function readReportsStore(){
      try{
        const parsed = JSON.parse(localStorage.getItem(REPORTS_STORAGE_KEY) || '[]');
        return Array.isArray(parsed) ? parsed : [];
      }catch(_e){
        return [];
      }
    }

    function writeReportsStore(list){
      try{ localStorage.setItem(REPORTS_STORAGE_KEY, JSON.stringify(list || [])); }catch(_e){}
    }

    function addPostReport(lib, reason){
      const user = getCurrentUser();
      if(!user) throw new Error('Sign in to report posts');
      const entry = {
        id: `${Date.now()}_${Math.random().toString(36).slice(2,7)}`,
        libId: lib && lib.id,
        title: lib && lib.title,
        author: lib && lib.author,
        reporter: user.username,
        reason,
        t: Date.now()
      };
      const store = readReportsStore();
      store.unshift(entry);
      writeReportsStore(store.slice(0, 500));
      return entry;
    }

    function getUserPostStats(username, viewer){
      const visiblePosts = libs.filter(lib=> normalizeUsername(lib.author) === normalizeUsername(username) && isLibVisibleToUser(lib, viewer));
      const ratingValues = visiblePosts
        .map(lib=> getRatingStats(lib))
        .filter(stats=> stats.count > 0);
      const weightedCount = ratingValues.reduce((acc, stats)=> acc + stats.count, 0);
      const weightedSum = ratingValues.reduce((acc, stats)=> acc + (stats.avg * stats.count), 0);
      const avgPostRating = weightedCount ? (weightedSum / weightedCount) : 0;
      return { visiblePosts, avgPostRating, ratingsCount: weightedCount };
    }

    function canEditLibrary(user, lib){
      if(!user || !lib) return false;
      return isLibraryAuthor(user, lib) || isStaffUser(user);
    }

    function canPinLibrary(user){
      return isStaffUser(user);
    }

    function canReportLibrary(user, lib){
      if(!user || !lib) return false;
      return normalizeUsername(user.username) !== normalizeUsername(lib.author);
    }

    function getViewStoreKey(user, lib){
      const userKey = normalizeUsername(user && user.username ? user.username : 'guest');
      const libKey = lib && lib.id ? String(lib.id) : 'unknown';
      return `jjs_view_${userKey}_${libKey}`;
    }

    function markPostViewed(lib){
      if(!lib || !lib.id) return;
      const user = getCurrentUser();
      const key = getViewStoreKey(user, lib);
      try{
        if(sessionStorage.getItem(key)) return;
        sessionStorage.setItem(key, '1');
      }catch(_e){}
      lib.views = (Number(lib.views) || 0) + 1;
    }

    async function submitReaction(lib, emoji){
      const user = getCurrentUser();
      if(!user) throw new Error('Sign in to react');
      if(!REACTION_OPTIONS.includes(emoji)) throw new Error('Invalid reaction');
      const reactions = getReactionStore(lib);
      const lower = normalizeUsername(user.username);
      REACTION_OPTIONS.forEach(item=>{
        reactions[item] = (reactions[item] || []).filter(name=> normalizeUsername(name) !== lower);
      });
      reactions[emoji].push(user.username);
      try{
        await persistLibraryFile(lib);
      }catch(_err){
        addNotification('Reaction saved locally â€” sync pending');
      }
      return reactions;
    }

    function getReactionCount(lib, emoji){
      const reactions = getReactionStore(lib);
      return (reactions[emoji] || []).length;
    }

    async function togglePinLibrary(lib){
      const user = getCurrentUser();
      if(!canPinLibrary(user)) throw new Error('Only owner/moderators can pin posts');
      lib.pinned = !lib.pinned;
      try{
        await persistLibraryFile(lib);
      }catch(_err){
        addNotification('Pin updated locally â€” sync pending');
      }
      return lib.pinned;
    }

    function getUserPostCooldownRemaining(user){
      if(!user || !user.username || !POST_COOLDOWN_MS) return 0;
      const key = 'jjs_post_cooldown_' + normalizeUsername(user.username);
      const last = Number(localStorage.getItem(key) || 0);
      const remaining = POST_COOLDOWN_MS - (Date.now() - last);
      return Math.max(0, remaining);
    }

    function setUserPostCooldown(user){
      if(!user || !user.username || !POST_COOLDOWN_MS) return;
      const key = 'jjs_post_cooldown_' + normalizeUsername(user.username);
      try{ localStorage.setItem(key, String(Date.now())); }catch(_e){}
    }

    function formatMs(ms){
      const total = Math.ceil(ms / 1000);
      const mins = Math.floor(total / 60);
      const secs = total % 60;
      return mins ? `${mins}m ${secs}s` : `${secs}s`;
    }

    function openReportPostModal(lib){
      const user = getCurrentUser();
      if(!canReportLibrary(user, lib)) return alert('You cannot report this post.');
      const reasons = ['Spam', 'Harassment', 'Stolen content', 'NSFW / inappropriate', 'Other'];
      let modal = document.getElementById('reportPostModal');
      if(modal) modal.remove();
      modal = document.createElement('div');
      modal.id = 'reportPostModal';
      modal.style.position = 'fixed';
      modal.style.left = '0';
      modal.style.top = '0';
      modal.style.width = '100vw';
      modal.style.height = '100vh';
      modal.style.background = 'rgba(0,0,0,0.55)';
      modal.style.zIndex = '9999';
      modal.style.display = 'flex';
      modal.style.alignItems = 'center';
      modal.style.justifyContent = 'center';
      modal.innerHTML = `<div style="background:var(--card);padding:20px;min-width:320px;max-width:420px;width:92vw;border-radius:12px;box-shadow:0 8px 32px #000a;position:relative;">
        <button id="closeReportModal" class="ghost" style="position:absolute;right:10px;top:10px" type="button">Close</button>
        <h3 style="margin:0 0 10px 0">Report post</h3>
        <div class="smallMuted" style="margin-bottom:10px">${escapeHtml(censorBadWords(lib.title || 'Untitled'))}</div>
        <select id="reportReasonSelect" style="width:100%">${reasons.map(r=>`<option value="${escapeHtml(r)}">${escapeHtml(r)}</option>`).join('')}</select>
        <button id="submitReportBtn" class="ghost" style="margin-top:12px">Submit report</button>
      </div>`;
      document.body.appendChild(modal);
      modal.querySelector('#closeReportModal').addEventListener('click', ()=> modal.remove());
      modal.querySelector('#submitReportBtn').addEventListener('click', ()=>{
        const reason = modal.querySelector('#reportReasonSelect').value || 'Other';
        addPostReport(lib, reason);
        addNotification(`Reported post: ${lib.title}`);
        modal.remove();
      });
    }

    function normalizeProfileLinkEntry(entry){
      if(!entry) return null;
      let label = typeof entry.label === 'string' ? entry.label.trim() : '';
      let url = typeof entry.url === 'string' ? entry.url.trim() : '';
      if(!url) return null;
      if(!/^https?:\/\//i.test(url)) url = 'https://' + url;
      try{
        const parsed = new URL(url);
        url = parsed.href;
      }catch(_e){
        return null;
      }
      label = censorBadWords(label).slice(0, 40);
      if(!label) label = url.replace(/^https?:\/\//i,'').slice(0,40);
      return { label, url };
    }

    function sanitizeProfileLinks(list){
      if(!Array.isArray(list)) return [];
      const seen = new Set();
      const cleaned = [];
      list.forEach(item=>{
        const normalized = normalizeProfileLinkEntry(item);
        if(!normalized) return;
        const key = normalized.url.toLowerCase();
        if(seen.has(key)) return;
        seen.add(key);
        cleaned.push(normalized);
      });
      return cleaned.slice(0, 6);
    }

    function formatVideoDuration(seconds){
      if(!Number.isFinite(seconds) || seconds <= 0) return '0:00';
      const totalSeconds = Math.round(seconds);
      const mins = Math.floor(totalSeconds / 60);
      const secs = (totalSeconds % 60).toString().padStart(2,'0');
      return `${mins}:${secs}`;
    }

    function formatBytes(bytes){
      if(!Number.isFinite(bytes) || bytes <= 0) return '0 B';
      const units = ['B','KB','MB','GB'];
      let value = bytes;
      let unitIndex = 0;
      while(value >= 1024 && unitIndex < units.length - 1){
        value /= 1024;
        unitIndex++;
      }
      const precision = value >= 10 || unitIndex === 0 ? 0 : 1;
      return `${value.toFixed(precision)} ${units[unitIndex]}`;
    }

    function readVideoDuration(file){
      return new Promise((resolve,reject)=>{
        const video = document.createElement('video');
        let objectUrl = '';
        const cleanup = ()=>{
          if(objectUrl){
            URL.revokeObjectURL(objectUrl);
            objectUrl = '';
          }
          video.removeAttribute('src');
          video.load();
        };
        video.preload = 'metadata';
        video.onloadedmetadata = ()=>{
          const duration = video.duration || 0;
          cleanup();
          resolve(duration);
        };
        video.onerror = ()=>{
          cleanup();
          reject(new Error('Could not read video metadata.'));
        };
        objectUrl = URL.createObjectURL(file);
        video.src = objectUrl;
      });
    }

    async function processVideoFile(file, opts = {}){
      if(!file) throw new Error('Select a video file first.');
      if(!file.type || !file.type.startsWith('video/')) throw new Error('File must be a video.');
      if(ALLOWED_VIDEO_TYPES.length && !ALLOWED_VIDEO_TYPES.includes(file.type)){
        throw new Error('Video must be MP4, WebM, or Ogg.');
      }
      if(file.size > VIDEO_MAX_SIZE_BYTES){
        throw new Error(`Video must be under ${formatBytes(VIDEO_MAX_SIZE_BYTES)} to stay within upload limits.`);
      }
      const duration = await readVideoDuration(file);
      if(duration > VIDEO_DURATION_LIMIT_SECONDS){
        throw new Error('Video must be 60 seconds or shorter.');
      }
      const base = {
        name: file.name,
        type: file.type,
        size: file.size,
        duration: Math.round(duration * 10) / 10
      };
      if(opts.skipEncoding) return base;
      const dataUrl = await fileToDataUrl(file);
      base.dataUrl = dataUrl;
      return base;
    }

    function buildVideoAttachment(videoPayload){
      if(!videoPayload) return null;
      const attachment = {
        dataUrl: videoPayload.dataUrl,
        name: censorBadWords(videoPayload.name || 'video'),
        type: videoPayload.type,
        duration: videoPayload.duration,
        size: videoPayload.size
      };
      if(!attachment.dataUrl) return null;
      return attachment;
    }

    function normalizeKey(value){
      return (value || 'unknown').toString().replace(/[^a-z0-9_-]/gi,'_');
    }

    function getLibStorageId(lib){
      if(!lib) return 'unknown';
      return normalizeKey(lib.id || lib.__filename || lib.title || Date.now());
    }

    function getLocalComments(lib){
      const key = 'jjs_comments_' + getLibStorageId(lib);
      try{ return JSON.parse(localStorage.getItem(key) || '[]'); }
      catch(_e){ return []; }
    }

    function saveLocalComments(lib, comments){
      const key = 'jjs_comments_' + getLibStorageId(lib);
      try{ localStorage.setItem(key, JSON.stringify(comments || [])); }
      catch(_e){}
    }

    function ensureLibComments(lib){
      if(!lib) return [];
      if(Array.isArray(lib.comments) && lib.comments.length){
        saveLocalComments(lib, lib.comments);
        return lib.comments;
      }
      lib.comments = getLocalComments(lib);
      return lib.comments;
    }

    function appendComment(lib, comment){
      const comments = ensureLibComments(lib);
      comments.push(comment);
      saveLocalComments(lib, comments);
      return comments;
    }

    function addReply(comments, parentId, reply){
      for(const comment of comments){
        if(comment.id === parentId){
          comment.replies = comment.replies || [];
          comment.replies.push(reply);
          return true;
        }
        if(comment.replies && comment.replies.length && addReply(comment.replies, parentId, reply)){
          return true;
        }
      }
      return false;
    }

    const COMMENT_MAX_LENGTH = 200;

    function getLibIdForApi(lib){
      if(lib && lib.id) return lib.id;
      const storageId = getLibStorageId(lib);
      return storageId !== 'unknown' ? storageId : null;
    }

    async function postCommentToServer(lib, author, text, parentId){
      if(!SERVERLESS_URL) throw new Error('Serverless endpoint not configured');
      const libId = getLibIdForApi(lib);
      if(!libId) throw new Error('Missing library identifier');
      const payload = { libId, comment: { author, text, parentId } };
      const resp = await fetch(SERVERLESS_URL + '?action=addComment', {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: JSON.stringify(payload)
      });
      const data = await resp.json().catch(()=>null);
      if(!resp.ok || !data || !data.ok) throw new Error(data && data.error ? data.error : 'Failed to post comment');
      return data.comment;
    }

    function ensureLibRatings(lib){
      if(!lib) return [];
      if(Array.isArray(lib.ratings)) return lib.ratings;
      lib.ratings = [];
      return lib.ratings;
    }

    function clampRatingValue(value){
      const num = Number(value);
      if(!Number.isFinite(num)) return null;
      return Math.min(5, Math.max(1, num));
    }

    function getRatingStats(lib){
      const ratings = ensureLibRatings(lib);
      const values = ratings
        .map(entry => clampRatingValue(entry && entry.value))
        .filter(val => typeof val === 'number');
      if(!values.length) return { avg: 0, percent: 0, count: 0 };
      const sum = values.reduce((acc, val)=> acc + val, 0);
      const avg = sum / values.length;
      const percent = Math.round(((avg - 1) / 4) * 100);
      const clampedPercent = Math.max(0, Math.min(100, percent));
      return { avg, percent: clampedPercent, count: values.length };
    }

    function getRatingTone(percent){
      if(percent >= 70) return 'positive';
      if(percent >= 40) return 'neutral';
      return 'negative';
    }

    function formatRatingSummary(stats){
      if(!stats || !stats.count) return 'Be the first to rate';
      const countLabel = `${stats.count} rating${stats.count === 1 ? '' : 's'}`;
      return `${stats.percent}% quality â€¢ ${countLabel}`;
    }

    function getUserRatingValue(lib){
      const me = getCurrentUser();
      if(!me) return null;
      const ratings = ensureLibRatings(lib);
      const match = ratings.find(r=> (r.user || '').toLowerCase() === me.username.toLowerCase());
      return match ? Number(match.value) || null : null;
    }

    async function submitRating(lib, value){
      const me = getCurrentUser();
      if(!me) throw new Error('Sign in to rate');
      const normalizedAuthor = (lib && typeof lib.author === 'string') ? lib.author.toLowerCase() : '';
      const normalizedUser = (me.username || '').toLowerCase();
      if(normalizedAuthor && normalizedAuthor === normalizedUser){
        throw new Error('You cannot rate your own post');
      }
      const normalizedValue = clampRatingValue(value);
      if(normalizedValue == null) throw new Error('Invalid rating value');

      const ratings = ensureLibRatings(lib);
      const existingIndex = ratings.findIndex(entry => normalizeUsername(entry && entry.user) === normalizedUser);
      const nextEntry = { user: me.username, value: normalizedValue, t: Date.now() };
      if(existingIndex >= 0) ratings[existingIndex] = nextEntry;
      else ratings.push(nextEntry);

      if(!SERVERLESS_URL){
        addNotification('Rating saved locally â€” sync pending');
        return getRatingStats(lib);
      }

      const libId = getLibIdForApi(lib);
      if(!libId){
        addNotification('Rating saved locally â€” sync pending');
        return getRatingStats(lib);
      }

      try{
        const resp = await fetch(SERVERLESS_URL + '?action=rate', {
          method: 'POST',
          headers: { 'Content-Type':'application/json' },
          body: JSON.stringify({ libId, rating: normalizedValue, username: me.username })
        });
        const data = await resp.json().catch(()=>null);
        if(!resp.ok || !data || !data.ok) throw new Error((data && data.error) || 'Failed to submit rating');
        lib.ratings = Array.isArray(data.ratings) ? data.ratings : ensureLibRatings(lib);
        return data.stats || getRatingStats(lib);
      }catch(_err){
        addNotification('Rating saved locally â€” sync pending');
        return getRatingStats(lib);
      }
    }

    function renderRatingRow(lib, container){
      const stats = getRatingStats(lib);
      const avgRounded = Math.round(stats.avg);
      const me = getCurrentUser();
      const normalizedAuthor = (lib && typeof lib.author === 'string') ? lib.author.toLowerCase() : '';
      const normalizedUser = me && me.username ? me.username.toLowerCase() : '';
      const isOwnLibrary = !!(normalizedAuthor && normalizedUser && normalizedAuthor === normalizedUser);
      const canRate = !!(me && !isOwnLibrary);
      const toneClasses = ['ratingPercent--positive','ratingPercent--neutral','ratingPercent--negative'];
      const shouldFlash = container.dataset.justRated === 'true';
      container.innerHTML = '';
      const starsWrap = document.createElement('div');
      starsWrap.className = 'ratingStars';
      starsWrap.setAttribute('aria-label', stats.count ? `Average rating ${stats.avg.toFixed(1)} out of 5 stars` : 'No ratings yet');
      const percentEl = document.createElement('div');
      percentEl.className = 'ratingPercent';
      percentEl.setAttribute('aria-live','polite');
      percentEl.textContent = formatRatingSummary(stats);
      if(stats.count){
        percentEl.classList.add(`ratingPercent--${getRatingTone(stats.percent)}`);
        percentEl.title = `${stats.avg.toFixed(2)} average stars`;
      }else{
        percentEl.title = 'No ratings yet';
      }
      const starButtons = [];
      const applyFill = (fillValue)=>{
        starButtons.forEach(b=>{
          const isFilled = Number(b.dataset.value) <= fillValue;
          b.classList.toggle('filled', isFilled);
        });
      };
      for(let i=1;i<=5;i++){
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.textContent = 'â˜…';
        btn.dataset.value = i;
        btn.setAttribute('aria-label', `Rate ${i} star${i===1?'':'s'}`);
        if(!canRate){
          btn.disabled = true;
          btn.title = me ? 'You cannot rate your own post' : 'Sign in to rate';
        }
        btn.addEventListener('mouseenter', ()=>{
          if(btn.disabled) return;
          applyFill(i);
        });
        btn.addEventListener('mouseleave', ()=>{
          applyFill(Math.round(getRatingStats(lib).avg));
        });
        btn.addEventListener('click', async ()=>{
          if(btn.disabled) return;
          const starValue = Number(btn.dataset.value);
          starButtons.forEach(b=> b.disabled = true);
          percentEl.textContent = 'Saving...';
          toneClasses.forEach(cls => percentEl.classList.remove(cls));
          try{
            await submitRating(lib, starValue);
            container.dataset.justRated = 'true';
            renderRatingRow(lib, container);
            addNotification(`Rated ${lib.title} ${starValue} star${starValue===1?'':'s'}`);
          }catch(err){
            alert(err && err.message ? err.message : 'Failed to submit rating');
            starButtons.forEach(b=> b.disabled = !canRate);
            const fallbackStats = getRatingStats(lib);
            percentEl.textContent = formatRatingSummary(fallbackStats);
            if(fallbackStats.count){
              percentEl.classList.add(`ratingPercent--${getRatingTone(fallbackStats.percent)}`);
            }
            applyFill(Math.round(fallbackStats.avg));
          }
        });
        starButtons.push(btn);
        starsWrap.appendChild(btn);
      }
      applyFill(avgRounded);
      container.appendChild(starsWrap);
      container.appendChild(percentEl);
      if(shouldFlash){
        container.classList.add('ratingRowFlash');
        delete container.dataset.justRated;
        setTimeout(()=> container.classList.remove('ratingRowFlash'), 600);
      }else{
        container.classList.remove('ratingRowFlash');
      }
    }

    async function syncCommentsFromServer(lib, opts = {}){
      if(!SERVERLESS_URL) return;
      const list = document.getElementById('commentsList');
      const libId = getLibIdForApi(lib);
      const rerender = typeof opts.renderFn === 'function' ? opts.renderFn : null;
      if(!libId){ if(rerender) rerender(); return; }
      if(opts.showSpinner && list){
        list.innerHTML = '<div class="smallMuted">Loading comments...</div>';
      }
      try{
        const resp = await fetch(
          SERVERLESS_URL + '?action=getComments&libId=' + encodeURIComponent(libId),
          {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ libId })
          }
        );
        if(resp.status === 404){
          lib.comments = [];
          saveLocalComments(lib, []);
          if(rerender) rerender();
          return;
        }
        const data = await resp.json().catch(()=>null);
        if(!resp.ok || !data || !data.ok) throw new Error((data && data.error) || 'Failed');
        lib.comments = data.comments || [];
        saveLocalComments(lib, lib.comments);
        if(rerender) rerender();
      }catch(e){
        console.error('syncCommentsFromServer failed', e);
        if(opts.showError && list){
          const msg = e && e.message ? e.message : 'Unknown error';
          list.innerHTML = `<div class="smallMuted">Failed to load comments. ${escapeHtml(msg)} <button class="ghost" id="retryCommentsSync">Retry</button></div>`;
          const retryBtn = list.querySelector('#retryCommentsSync');
          if(retryBtn){
            retryBtn.addEventListener('click', ()=> syncCommentsFromServer(lib, Object.assign({}, opts, { showSpinner: true, showError: true })));
          }
        }
      }
    }

    function render(filtered){
      updateTotalLibrariesDisplay();
      listEl.innerHTML = '';
      if(filtered.length===0){
        listEl.innerHTML = '<div class="small">No libraries match your search.</div>';
        return;
      }
      filtered.forEach(lib=>{
        const node = tpl.content.cloneNode(true);
        const titleEl = node.querySelector('.title');
        const avatarImg = node.querySelector('.cardAvatar');
        const avatarWrap = node.querySelector('.cardAvatarWrap');
        markPostViewed(lib);
        setAvatarImage(avatarImg, { src: DEFAULT_AVATAR_URL, wrapper: avatarWrap, stage: 'default' });
        titleEl.textContent = censorBadWords(lib.title || '');
        // Show description if present
        if(lib.description){
          const desc = document.createElement('div');
          desc.className = 'smallMuted';
          desc.style.margin = '6px 0 0 0';
          const safeDesc = censorBadWords(lib.description);
          desc.textContent = safeDesc.length>250? safeDesc.slice(0,250)+'â€¦': safeDesc;
          titleEl.parentElement.appendChild(desc);
        }
        node.querySelector('.author').textContent = censorBadWords(lib.author || '');
        // make author clickable to open profile
        try{ const authorEl = node.querySelector('.author'); authorEl.style.cursor='pointer'; authorEl.addEventListener('click', ()=> openProfile(lib.author)); }catch(e){}
        node.querySelector('.orig').href = lib.credit;
        node.querySelector('.orig').textContent = 'Credit';
        const safeTags = (lib.tags || []).map(tag=>censorBadWords(tag || ''));
        const tagChipsWrap = node.querySelector('.tagChips');
        if(tagChipsWrap){
          tagChipsWrap.innerHTML = '';
          safeTags.forEach(tag=>{
            const chip = document.createElement('button');
            chip.type = 'button';
            chip.className = 'tagChip';
            chip.textContent = '#' + tag;
            chip.title = `Filter by ${tag}`;
            chip.addEventListener('click', ()=>{
              const select = document.getElementById('tagFilterSelect');
              activeTagFilter = (tag || '').toLowerCase();
              if(select) select.value = activeTagFilter;
              refreshListView({ refilter:true, resetPage:true, animate:true });
            });
            tagChipsWrap.appendChild(chip);
          });
        }
        const pre = node.querySelector('.code');
        pre.textContent = lib.code;
        pre.setAttribute('data-full', lib.code);
        const currentUser = getCurrentUser();

        // populate author avatar from social if available
        (async ()=>{
          if(!avatarImg) return;
          try{
            const social = await fetchSocial(lib.author);
            const authorMeta = node.querySelector('.meta');
            renderRoleBadgesInline(authorMeta, lib.author, social, { context:'post', showNames:true });
            const avatarSource = getAvatarSourceBundle(lib.author, social);
            setAvatarImage(avatarImg, {
              src: avatarSource.src || DEFAULT_AVATAR_URL,
              wrapper: avatarWrap,
              stage: avatarSource.stage,
              fallbackSources: avatarSource.fallbackSources
            });
            if(social && social.bio){
              const meta = node.querySelector('.meta');
              const bioEl = document.createElement('div');
              bioEl.className='smallMuted';
              bioEl.style.marginTop='6px';
              bioEl.textContent = social.bio.length>80? social.bio.slice(0,80)+'â€¦': social.bio;
              meta.appendChild(bioEl);
            }
          }catch(e){
            const authorMeta = node.querySelector('.meta');
            renderRoleBadgesInline(authorMeta, lib.author, null, { context:'post', showNames:true });
            setAvatarImage(avatarImg, { src: DEFAULT_AVATAR_URL, wrapper: avatarWrap, stage: 'default' });
          }
        })();

        const card = node.querySelector('.card');
        const actionsEl = node.querySelector('.actions');

        if(lib.video && lib.video.dataUrl && card){
          const videoWrap = document.createElement('div');
          videoWrap.className = 'cardVideoWrap';
          const videoEl = document.createElement('video');
          videoEl.controls = true;
          videoEl.playsInline = true;
          videoEl.preload = 'metadata';
          videoEl.muted = true;
          videoEl.src = lib.video.dataUrl;
          videoWrap.appendChild(videoEl);
          if(lib.video.duration || lib.video.name || lib.video.size){
            const meta = document.createElement('div');
            meta.className = 'cardVideoMeta';
            const parts = [];
            if(Number.isFinite(lib.video.duration)) parts.push(`Duration ${formatVideoDuration(lib.video.duration)}`);
            if(typeof lib.video.size === 'number') parts.push(formatBytes(lib.video.size));
            if(lib.video.name) parts.push(censorBadWords(lib.video.name));
            meta.textContent = parts.join(' â€¢ ');
            videoWrap.appendChild(meta);
          }
          if(actionsEl) card.insertBefore(videoWrap, actionsEl); else card.appendChild(videoWrap);
        }

        // Ratings UI
        const ratingRow = document.createElement('div');
        ratingRow.className = 'ratingRow';
        ensureLibRatings(lib);
        renderRatingRow(lib, ratingRow);
        if(actionsEl) card.insertBefore(ratingRow, actionsEl); else card.appendChild(ratingRow);
        const reactionRow = node.querySelector('.reactionRow');
        if(reactionRow){
          reactionRow.innerHTML = '';
          const viewerReaction = currentUser ? getUserReaction(lib, currentUser.username) : null;
          REACTION_OPTIONS.forEach(emoji=>{
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'reactionBtn' + (viewerReaction === emoji ? ' active' : '');
            btn.textContent = `${emoji} ${getReactionCount(lib, emoji)}`;
            if(!currentUser) btn.disabled = true;
            btn.addEventListener('click', async ()=>{
              if(!currentUser) return alert('Sign in to react');
              try{
                await submitReaction(lib, emoji);
                refreshListView({ refilter:true });
              }catch(err){
                alert(err && err.message ? err.message : 'Failed to save reaction');
              }
            });
            reactionRow.appendChild(btn);
          });
        }
        const toggle = node.querySelector('.toggle');
        const copyBtn = node.querySelector('.copy');
        const viewOrig = node.querySelector('.viewOrig');
        const wrap = node.querySelector('.codeWrap');

        toggle.addEventListener('click', ()=>{
          if(wrap.style.display==='none'){
            wrap.style.display='block'; toggle.textContent='Hide code';
          } else { wrap.style.display='none'; toggle.textContent='Show code'; }
        });

        copyBtn.addEventListener('click', async ()=>{
          try{
            await navigator.clipboard.writeText(pre.getAttribute('data-full'));
            copyBtn.textContent='Copied!';
            setTimeout(()=>copyBtn.textContent='Copy',1400);
          }catch(e){
            alert('Copy failed â€” select and copy manually.');
          }
        });

        viewOrig.addEventListener('click', ()=>window.open(lib.credit,'_blank'));
        // show edit/delete if current user is author
        const editBtn = node.querySelector('.edit');
        const delBtn = node.querySelector('.del');
        const isAuthor = isLibraryAuthor(currentUser, lib);
        const canEdit = canEditLibrary(currentUser, lib);
        const canDelete = canDeleteLibrary(currentUser, lib);
        const canPin = canPinLibrary(currentUser);
        const canReport = canReportLibrary(currentUser, lib);
        const quickActionsWrap = node.querySelector('.quickActions');
        const badgeWrap = node.querySelector('.cardBadges');

        if(badgeWrap){
          badgeWrap.innerHTML = '';
          const visibilityBadge = document.createElement('span');
          visibilityBadge.className = 'postBadge ' + (normalizeVisibility(lib.visibility) === VISIBILITY.PRIVATE ? 'postBadge--private' : 'postBadge--public');
          visibilityBadge.textContent = normalizeVisibility(lib.visibility) === VISIBILITY.PRIVATE ? 'ðŸ”’ Private' : 'ðŸŒ Public';
          badgeWrap.appendChild(visibilityBadge);
          if(lib.pinned){
            const pinBadge = document.createElement('span');
            pinBadge.className = 'postBadge postBadge--pinned';
            pinBadge.textContent = 'ðŸ“Œ Pinned';
            badgeWrap.appendChild(pinBadge);
          }
          if(isTopRatedLibrary(lib)){
            const topBadge = document.createElement('span');
            topBadge.className = 'postBadge postBadge--top';
            topBadge.textContent = 'â­ Top Rated';
            badgeWrap.appendChild(topBadge);
          }
        }

        if(quickActionsWrap){
          quickActionsWrap.innerHTML = '';
          const addQuickAction = (icon, title, handler)=>{
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'ghost quickActionBtn';
            btn.textContent = icon;
            btn.title = title;
            btn.addEventListener('click', handler);
            quickActionsWrap.appendChild(btn);
            return btn;
          };
          if(canEdit){
            addQuickAction('âœï¸', 'Edit post', ()=> editBtn && editBtn.click());
          }
          if(canDelete){
            addQuickAction('ðŸ—‘ï¸', 'Delete post', ()=> delBtn && delBtn.click());
          }
          addQuickAction('ðŸ”—', 'Share post', async ()=>{
            const shareUrl = `${location.origin}${location.pathname}#post-${encodeURIComponent(lib.id || lib.title || '')}`;
            try{
              await navigator.clipboard.writeText(shareUrl);
              addNotification('Share link copied');
            }catch(_e){
              alert('Failed to copy share link');
            }
          });
          const bookmarkState = currentUser ? getBookmarkSet(currentUser.username).has(String(lib.id || '')) : false;
          addQuickAction(bookmarkState ? 'ðŸ”–' : 'ðŸ“‘', bookmarkState ? 'Remove bookmark' : 'Save bookmark', ()=>{
            const result = toggleBookmarkLib(lib);
            if(!result.changed){
              alert(result.reason || 'Could not bookmark post');
              return;
            }
            addNotification(result.bookmarked ? `Saved ${lib.title}` : `Removed bookmark for ${lib.title}`);
            refreshListView({ refilter:true });
          });
          if(canPin){
            addQuickAction(lib.pinned ? 'ðŸ“Œ' : 'ðŸ“', lib.pinned ? 'Unpin post' : 'Pin post', async ()=>{
              try{
                const nowPinned = await togglePinLibrary(lib);
                addNotification(nowPinned ? `Pinned ${lib.title}` : `Unpinned ${lib.title}`);
                refreshListView({ refilter:true });
              }catch(err){
                alert(err && err.message ? err.message : 'Failed to update pin');
              }
            });
          }
          if(canReport){
            addQuickAction('ðŸš©', 'Report post', ()=> openReportPostModal(lib));
          }
        }
        const visibilityBtn = node.querySelector('.visibilityToggle');
        const visibilityRow = node.querySelector('.cardVisibilityRow');
        if(visibilityRow) visibilityRow.style.display = 'none';
        if(visibilityBtn){
          const applyVisibilityState = ()=>{
            const state = normalizeVisibility(lib.visibility);
            const whitelistCount = getLibraryWhitelist(lib).length;
            visibilityBtn.dataset.state = state;
            const isPrivate = state === VISIBILITY.PRIVATE;
            visibilityBtn.textContent = isPrivate ? (whitelistCount ? 'Private â€¢ Shared' : 'Private') : 'Public';
            const hint = isPrivate
              ? (whitelistCount ? `Private â€” shared with ${whitelistCount} whitelisted user${whitelistCount===1?'':'s'}, plus staff` : 'Private â€” only you, whitelisted users, and staff can view this post')
              : 'Public â€” everyone can view this post';
            visibilityBtn.title = hint;
            if(visibilityRow) visibilityRow.title = hint;
          };
          if(isAuthor){
            applyVisibilityState();
            visibilityBtn.style.display = 'inline-flex';
            visibilityBtn.disabled = false;
            visibilityBtn.addEventListener('click', async ()=>{
              const currentState = visibilityBtn.dataset.state || VISIBILITY.PUBLIC;
              const nextState = currentState === VISIBILITY.PRIVATE ? VISIBILITY.PUBLIC : VISIBILITY.PRIVATE;
              const previousLabel = visibilityBtn.textContent;
              visibilityBtn.textContent = 'Saving...';
              visibilityBtn.disabled = true;
              try{
                await updateLibraryVisibility(lib, nextState);
                applyVisibilityState();
                addNotification(`Visibility set to ${nextState}`);
                refreshListView({ refilter:true });
              }catch(err){
                alert(err && err.message ? err.message : 'Failed to update visibility');
                visibilityBtn.textContent = previousLabel;
              }finally{
                visibilityBtn.disabled = false;
              }
            });
          }else{
            visibilityBtn.remove();
          }
        }
        if(editBtn) editBtn.style.display = canEdit ? 'none' : 'none';
        if(delBtn) delBtn.style.display = canDelete ? 'none' : 'none';

        if(editBtn){
          editBtn.addEventListener('click', ()=>{
            openLibraryModal({
              mode: 'edit',
              lib,
              onSubmit: async (payload)=>{
                const { title, description, credit, code, tags, visibility, whitelist, video, videoRemoved } = payload;
                if(!title) throw new Error('Title required');
                if(!description) throw new Error('Description required');
                if(description.length > 250) throw new Error('Description too long');
                if(!code) throw new Error('Code required');
                lib.title = censorBadWords(title);
                lib.description = censorBadWords(description);
                lib.credit = credit;
                lib.code = code;
                lib.tags = (tags || []).map(tag=>censorBadWords(tag));
                lib.visibility = visibility;
                lib.whitelist = normalizeVisibility(visibility) === VISIBILITY.PRIVATE ? normalizeWhitelistUsers(whitelist, lib.author) : [];
                if(videoRemoved){
                  delete lib.video;
                }else if(video){
                  if(video !== lib.video){
                    const attachment = buildVideoAttachment(video);
                    if(attachment) lib.video = attachment;
                  }
                }else{
                  delete lib.video;
                }
                sanitizeLibraryContent(lib);
                await persistLibraryFile(lib);
                addNotification('Library updated');
                refreshListView({ refilter:true });
              }
            });
          });
        }

        if(delBtn){
          delBtn.addEventListener('click', async ()=>{
            const actingUser = getCurrentUser();
            if(!canDeleteLibrary(actingUser, lib)){
              alert('Only the author or owner can delete this entry.');
              return;
            }
            const isOwnerAction = actingUser && actingUser.role === 'owner';
            const promptMsg = isOwnerAction ? 'Remove this library as the owner?' : 'Delete this library?';
            if(!confirm(promptMsg)) return;
            const localBasePath = (GITHUB.path || '').replace(/^\/+|\/+$/g,'');
            const fallbackFilename = lib.__filename || `${lib.id || Date.now()}-${sanitizeFilename(lib.title || 'library')}.json`;
            const resolvedPath = (lib.__path && lib.__path.trim()) || (localBasePath ? `${localBasePath}/${fallbackFilename}` : fallbackFilename);
            if(!resolvedPath){
              alert('Unable to determine a file path for this library.');
              return;
            }
            let deleted = false;
            try{
              if(SERVERLESS_URL){
                const resp = await fetch(SERVERLESS_URL + '?action=delete', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ path: resolvedPath, filename: fallbackFilename, lib }) });
                const data = await resp.json().catch(()=>null);
                if(!resp.ok || (data && data.error)) throw new Error((data && data.error) || 'Delete failed');
                deleted = true;
              }
              else if(GITHUB.token && GITHUB.owner && GITHUB.repo){
                // delete via contents API
                const apiBase = `https://api.github.com/repos/${GITHUB.owner}/${GITHUB.repo}/contents/${encodeURIComponent(resolvedPath)}`;
                const getResp = await fetch(apiBase + `?ref=${encodeURIComponent(GITHUB.branch)}`, { headers: { 'Accept':'application/vnd.github.v3+json', 'Authorization': `token ${GITHUB.token}` } });
                if(getResp.status===200){
                  const data = await getResp.json();
                  const delResp = await fetch(apiBase, { method:'DELETE', headers: { 'Accept':'application/vnd.github.v3+json', 'Authorization': `token ${GITHUB.token}`, 'Content-Type':'application/json' }, body: JSON.stringify({ message: 'Delete library', sha: data.sha, branch: GITHUB.branch }) });
                  if(!delResp.ok) throw new Error('GitHub delete failed');
                  deleted = true;
                }else{
                  throw new Error('File not found in repository');
                }
              }
            }catch(e){
              alert(e && e.message ? e.message : 'Failed to delete library');
              return;
            }
            if(!deleted) return;
            const idx = libs.findIndex(x=>x.id===lib.id);
            if(idx>=0) libs.splice(idx,1);
            refreshListView({ refilter:true });
            const staffDelete = !!(actingUser && isStaffUser(actingUser) && !isLibraryAuthor(actingUser, lib));
            addNotification((staffDelete ? 'Staff removed ' : 'Deleted ') + lib.title);
          });
        }

        // --- COMMENTS UI (modal) ---
        const commentsBtn = document.createElement('button');
        commentsBtn.className = 'ghost';
        commentsBtn.textContent = 'Comments';
        if(actionsEl) actionsEl.appendChild(commentsBtn);
        else card.appendChild(commentsBtn);

        if(isAuthor && visibilityBtn && visibilityBtn.isConnected){
          if(actionsEl) actionsEl.appendChild(visibilityBtn);
          else card.appendChild(visibilityBtn);
        }

        commentsBtn.addEventListener('click', () => openCommentsModal(lib));
        // --- Comments Modal ---
        function openCommentsModal(lib) {
          let modal = document.getElementById('commentsModal');
          if(modal) modal.remove();
          modal = document.createElement('div');
          modal.id = 'commentsModal';
          modal.style.position = 'fixed';
          modal.style.left = '0';
          modal.style.top = '0';
          modal.style.width = '100vw';
          modal.style.height = '100vh';
          modal.style.background = 'rgba(0,0,0,0.55)';
          modal.style.zIndex = '9999';
          modal.style.display = 'flex';
          modal.style.alignItems = 'center';
          modal.style.justifyContent = 'center';
          modal.innerHTML = `<div id="commentsModalInner" style="background:var(--card);padding:24px 18px 18px 18px;min-width:340px;max-width:98vw;max-height:90vh;overflow:auto;border-radius:12px;box-shadow:0 8px 32px #000a;position:relative;">
            <button id="closeCommentsModal" style="position:absolute;top:10px;right:10px;" class="ghost">Close</button>
            <h3 style="margin-top:0">Comments for <span style="color:#6cf">${escapeHtml(lib.title)}</span></h3>
            <div id="addCommentSection"></div>
            <hr style="margin:16px 0 10px 0;opacity:0.2">
            <div id="commentsList"></div>
          </div>`;
          document.body.appendChild(modal);
          document.getElementById('closeCommentsModal').onclick = ()=>modal.remove();
          const rerenderComments = () => renderCommentsList(lib);
          // Add comment UI
          renderAddCommentUI(lib, rerenderComments);
          // Fetch and render comments
          const hasLocalComments = ensureLibComments(lib).length > 0;
          rerenderComments();
          syncCommentsFromServer(lib, { showSpinner: !hasLocalComments, showError: true, renderFn: rerenderComments });
        }

        function renderAddCommentUI(lib, rerenderCb) {
          const u = getCurrentUser();
          const wrap = document.getElementById('addCommentSection');
          wrap.innerHTML = '';
          const form = document.createElement('form');
          form.innerHTML = `<div style="font-weight:bold;margin-bottom:4px">Add a comment</div><textarea class="commentInput" maxlength="200" placeholder="Add a comment (max 200 chars)" style="width:100%;min-height:48px;padding:8px;border-radius:8px;border:1px solid #333"></textarea><div style="display:flex;gap:8px;align-items:center;margin-top:6px"><button type="submit" class="ghost">Post</button><span class="smallMuted commentCount"></span></div>`;
          const input = form.querySelector('.commentInput');
          const count = form.querySelector('.commentCount');
          const submitBtn = form.querySelector('button');
          input.addEventListener('input',()=>{ count.textContent = (input.value.length ? input.value.length + '/' + COMMENT_MAX_LENGTH : ''); });
          form.addEventListener('submit', async (ev)=>{
            ev.preventDefault();
            if(!u) return alert('Sign in to comment');
            const text = input.value.trim();
            if(!text) return;
            if(text.length>COMMENT_MAX_LENGTH) return alert('Max ' + COMMENT_MAX_LENGTH + ' chars');
            submitBtn.disabled = true;
            const cleanText = censorBadWords(text).slice(0,COMMENT_MAX_LENGTH);
            const tempComment = { id: Date.now().toString(36) + Math.random().toString(36).slice(2,8), author: u.username, text: cleanText, t: Date.now(), replies: [] };
            appendComment(lib, tempComment);
            if(rerenderCb) rerenderCb(); else renderCommentsList(lib);
            input.value = '';
            count.textContent = '';
            try{
              if(SERVERLESS_URL){
                await postCommentToServer(lib, u.username, cleanText, null);
                await syncCommentsFromServer(lib, { renderFn: rerenderCb });
              }
            }catch(err){
              console.warn('Comment sync failed', err);
              addNotification('Comment saved locally â€” server unreachable');
            }
            submitBtn.disabled = false;
          });
          wrap.appendChild(form);
        }

        function renderCommentsList(lib) {
          const list = document.getElementById('commentsList');
          if(!list) return;
          const comments = ensureLibComments(lib);
          if(!comments || comments.length === 0){
            list.innerHTML = '<div class="smallMuted">No comments yet.</div>';
            return;
          }
          list.innerHTML = '';
          renderCommentsThread(comments, list, lib);
        }

        function renderCommentsThread(comments, parentEl, lib, depth=0) {
          const u = getCurrentUser();
          comments.forEach(c=>{
            const div = document.createElement('div');
            div.className = 'commentItem';
            div.style.marginLeft = (depth*18)+'px';
            div.style.marginTop = '10px';
            div.style.padding = '8px';
            div.style.background = 'rgba(255,255,255,0.03)';
            div.style.borderRadius = '8px';
            const safeAuthor = censorBadWords(c.author || '');
            const safeCommentText = escapeHtml(censorBadWords(c.text || ''));
            div.innerHTML = `<span class="small"><b>${safeAuthor}</b>:</span> <span>${safeCommentText}</span> <span class="smallMuted" style="margin-left:8px">${new Date(c.t).toLocaleString()}</span>`;
            const authorSpan = div.querySelector('.small');
            renderRoleBadgesInline(authorSpan, c.author, null, { context:'comment' });
            // Reply button
            if(depth<4){
              const replyBtn = document.createElement('button'); replyBtn.className='ghost'; replyBtn.textContent='Reply'; replyBtn.style.marginLeft='8px';
              replyBtn.addEventListener('click',()=>{
                if(div.querySelector('.replyForm')) return;
                const rf = document.createElement('form'); rf.className='replyForm'; rf.style.marginTop='8px';
                rf.innerHTML = `<textarea maxlength="200" placeholder="Reply (max 200 chars)" style="width:100%;min-height:28px;padding:4px;border-radius:6px;border:1px solid #333"></textarea><div style="display:flex;gap:8px;align-items:center;margin-top:2px"><button type="submit" class="ghost">Post</button><span class="smallMuted replyCount"></span></div>`;
                const rinput = rf.querySelector('textarea');
                const rcount = rf.querySelector('.replyCount');
                rinput.addEventListener('input',()=>{ rcount.textContent = (rinput.value.length ? rinput.value.length + '/' + COMMENT_MAX_LENGTH : ''); });
                rf.addEventListener('submit', async (ev)=>{
                  ev.preventDefault();
                  if(!u) return alert('Sign in to reply');
                  const text = rinput.value.trim();
                  if(!text) return;
                  if(text.length>COMMENT_MAX_LENGTH) return alert('Max ' + COMMENT_MAX_LENGTH + ' chars');
                  const btn = rf.querySelector('button');
                  btn.disabled = true;
                  const cleanReplyText = censorBadWords(text).slice(0,COMMENT_MAX_LENGTH);
                  const reply = { id: Date.now().toString(36) + Math.random().toString(36).slice(2,8), author: u.username, text: cleanReplyText, t: Date.now(), replies: [] };
                  const comments = ensureLibComments(lib);
                  const added = addReply(comments, c.id, reply);
                  if(added){
                    saveLocalComments(lib, comments);
                    renderCommentsList(lib);
                    rinput.value = '';
                    rcount.textContent = '';
                    try{
                      if(SERVERLESS_URL){
                        await postCommentToServer(lib, u.username, cleanReplyText, c.id);
                        await syncCommentsFromServer(lib, { renderFn: ()=>renderCommentsList(lib) });
                      }
                    }catch(err){
                      console.warn('Reply sync failed', err);
                      addNotification('Reply saved locally â€” server unreachable');
                    }
                  }else{
                    alert('Failed to reply');
                  }
                  btn.disabled = false;
                });
                div.appendChild(rf);
              });
              div.appendChild(replyBtn);
            }
            parentEl.appendChild(div);
            if(c.replies && c.replies.length) renderCommentsThread(c.replies, parentEl, lib, depth+1);
          });
        }
        listEl.appendChild(node);
        });
        // diagnostics removed
    }

    function escapeHtml(str){
      const map = {"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"};
      return String(str).replace(/[&<>"']/g, (m)=>map[m] || m);
    }

    function filter(q){
      return getFilteredSortedLibs(q);
    }

    function updateFilteredResults(){
      refreshTagFilterOptions();
      const query = (search && typeof search.value === 'string') ? search.value : '';
      filteredResults = filter(query);
      updateActiveFilterLabel();
    }

    function ensureValidPage(){
      const totalPages = Math.max(1, Math.ceil((filteredResults.length || 0) / PAGE_SIZE) || 1);
      if(currentPage > totalPages) currentPage = totalPages;
      if(currentPage < 1) currentPage = 1;
      return totalPages;
    }

    function getCurrentPageItems(){
      const start = (currentPage - 1) * PAGE_SIZE;
      return filteredResults.slice(start, start + PAGE_SIZE);
    }

    function animatePageTransition(callback){
      if(!listEl){ callback(); return; }
      listEl.classList.add('list--fading');
      setTimeout(()=>{
        callback();
        requestAnimationFrame(()=> listEl.classList.remove('list--fading'));
      }, 200);
    }

    function buildPageList(totalPages){
      if(totalPages <= 7){
        return Array.from({ length: totalPages }, (_, idx)=> idx + 1);
      }
      const slots = new Set([1, totalPages, currentPage, currentPage - 1, currentPage + 1]);
      if(currentPage <= 3){ slots.add(2); slots.add(3); slots.add(4); }
      if(currentPage >= totalPages - 2){ slots.add(totalPages - 1); slots.add(totalPages - 2); slots.add(totalPages - 3); }
      const ordered = Array.from(slots).filter(p=>p >= 1 && p <= totalPages).sort((a,b)=>a-b);
      const result = [];
      ordered.forEach((page, idx)=>{
        if(idx>0 && page - ordered[idx-1] > 1){
          result.push('ellipsis');
        }
        result.push(page);
      });
      return result;
    }

    function renderPaginationControls(totalPages){
      if(!paginationEl) return;
      if(filteredResults.length <= PAGE_SIZE){
        paginationEl.innerHTML = '';
        paginationEl.classList.add('paginationBar--hidden');
        return;
      }
      paginationEl.classList.remove('paginationBar--hidden');
      paginationEl.innerHTML = '';
      const createBtn = (label, opts = {})=>{
        const btn = document.createElement('button');
        btn.className = 'pageBtn';
        if(opts.nav) btn.classList.add('pageBtn--nav');
        if(opts.active) btn.classList.add('pageBtn--active');
        btn.textContent = label;
        btn.disabled = !!opts.disabled;
        if(!btn.disabled && typeof opts.onClick === 'function'){
          btn.addEventListener('click', opts.onClick);
        }
        return btn;
      };
      paginationEl.appendChild(createBtn('â€¹ Previous', { nav:true, disabled: currentPage === 1, onClick: ()=> goToPage(currentPage - 1) }));
      buildPageList(totalPages).forEach(entry=>{
        if(entry === 'ellipsis'){
          const span = document.createElement('span');
          span.className = 'pageEllipsis';
          span.textContent = '...';
          paginationEl.appendChild(span);
        }else{
          const pageNumber = Number(entry);
          paginationEl.appendChild(createBtn(String(pageNumber), {
            active: pageNumber === currentPage,
            onClick: ()=> goToPage(pageNumber)
          }));
        }
      });
      const total = Math.max(1, totalPages);
      paginationEl.appendChild(createBtn('Next â€º', { nav:true, disabled: currentPage === total, onClick: ()=> goToPage(currentPage + 1) }));
    }

    function goToPage(page){
      const totalPages = ensureValidPage();
      const target = Math.min(Math.max(page,1), totalPages);
      if(target === currentPage) return;
      currentPage = target;
      refreshListView({ animate:true });
    }

    function refreshListView(opts = {}){
      const { refilter = false, resetPage = false, animate = false } = opts;
      if(refilter){ updateFilteredResults(); }
      if(resetPage) currentPage = 1;
      const totalPages = ensureValidPage();
      const items = getCurrentPageItems();
      const renderNow = ()=> render(items);
      if(animate){
        animatePageTransition(renderNow);
      }else{
        renderNow();
      }
      renderPaginationControls(totalPages);
    }

    const runSearchPipeline = ()=>{
      refreshListView({ refilter:true, resetPage:true, animate:true });
      renderGlobalSearchResults(search.value || '');
    };

    search.addEventListener('input', ()=>{
      if(searchDebounceTimer) clearTimeout(searchDebounceTimer);
      searchDebounceTimer = setTimeout(runSearchPipeline, 220);
    });

    const sortSelectEl = document.getElementById('sortSelect');
    if(sortSelectEl){
      sortSelectEl.value = activeSort;
      sortSelectEl.addEventListener('change', ()=>{
        activeSort = sortSelectEl.value || SORT_OPTIONS.NEWEST;
        refreshListView({ refilter:true, resetPage:true, animate:true });
      });
    }

    const tagFilterSelectEl = document.getElementById('tagFilterSelect');
    if(tagFilterSelectEl){
      tagFilterSelectEl.addEventListener('change', ()=>{
        activeTagFilter = (tagFilterSelectEl.value || '').toLowerCase();
        refreshListView({ refilter:true, resetPage:true, animate:true });
      });
    }

    const globalTypeSelectEl = document.getElementById('globalTypeSelect');
    if(globalTypeSelectEl){
      globalTypeSelectEl.addEventListener('change', ()=>{
        activeGlobalType = globalTypeSelectEl.value || 'all';
        renderGlobalSearchResults(search.value || '');
      });
    }

    const globalSearchSortEl = document.getElementById('globalSearchSort');
    if(globalSearchSortEl){
      globalSearchSortEl.addEventListener('change', ()=>{
        activeGlobalSearchSort = globalSearchSortEl.value || 'relevance';
        renderGlobalSearchResults(search.value || '');
      });
    }

    const feedModeSelectEl = document.getElementById('feedModeSelect');
    if(feedModeSelectEl){
      feedModeSelectEl.addEventListener('change', ()=>{
        activeFeedMode = feedModeSelectEl.value || 'all';
        refreshListView({ refilter:true, resetPage:true, animate:true });
      });
    }

    function openReportsReviewModal(){
      const user = getCurrentUser();
      if(!isStaffUser(user)) return alert('Only owner/moderators can view reports.');
      let modal = document.getElementById('reportsReviewModal');
      if(modal) modal.remove();
      modal = document.createElement('div');
      modal.id = 'reportsReviewModal';
      modal.style.position = 'fixed';
      modal.style.left = '0';
      modal.style.top = '0';
      modal.style.width = '100vw';
      modal.style.height = '100vh';
      modal.style.background = 'rgba(0,0,0,0.55)';
      modal.style.zIndex = '9999';
      modal.style.display = 'flex';
      modal.style.alignItems = 'center';
      modal.style.justifyContent = 'center';
      const reports = readReportsStore();
      modal.innerHTML = `<div style="background:var(--card);padding:20px;min-width:340px;max-width:800px;width:92vw;max-height:86vh;overflow:auto;border-radius:12px;box-shadow:0 8px 32px #000a;position:relative;">
        <button id="closeReportsReview" class="ghost" style="position:absolute;right:10px;top:10px" type="button">Close</button>
        <h3 style="margin:0 0 12px 0">Reported Posts (${reports.length})</h3>
        <div id="reportsList"></div>
      </div>`;
      document.body.appendChild(modal);
      document.getElementById('closeReportsReview').addEventListener('click', ()=> modal.remove());
      const listEl = modal.querySelector('#reportsList');
      if(!reports.length){
        listEl.innerHTML = '<div class="smallMuted">No reports yet.</div>';
        return;
      }
      reports.forEach(rep=>{
        const row = document.createElement('div');
        row.className = 'libItem';
        row.innerHTML = `<div><strong>${escapeHtml(censorBadWords(rep.title || 'Untitled'))}</strong></div><div class="smallMuted">Reason: ${escapeHtml(censorBadWords(rep.reason || ''))}</div><div class="smallMuted">Reporter: ${escapeHtml(censorBadWords(rep.reporter || 'unknown'))} â€¢ ${new Date(rep.t || Date.now()).toLocaleString()}</div>`;
        listEl.appendChild(row);
      });
    }

    const reviewReportsBtn = document.getElementById('reviewReportsBtn');
    if(reviewReportsBtn){
      reviewReportsBtn.addEventListener('click', openReportsReviewModal);
    }

    // Add button opens Discord invite (manual additions are done by editing the file)
    document.getElementById('newEntry').addEventListener('click', ()=>{
      window.open('https://discord.gg/VqwDPu6K', '_blank');
    });

    /*
      GitHub auto-save configuration (client-side fallback)
      WARNING: Do NOT place a PAT here in production. Use the serverless endpoint below instead.
    */
    const GITHUB = {
      owner: '', // e.g. 'your-username'
      repo: '',  // e.g. 'JJS-Library'
      path: 'libs', // path inside repo to save files
      branch: 'main',
      token: '' // insecure: only for quick testing
    };

    // Serverless endpoint (preferred). If deployed on Vercel you can use
    // https://<your-project>.vercel.app/api/save-lib. Defaulting to your known deploy URL.
    const SERVERLESS_URL = 'https://jjs-libraries.vercel.app/api/save-lib';
    const SAVE_URL_LOCAL = '/api/save-lib';

    // Users endpoint derived from serverless base
    const USERS_URL = SERVERLESS_URL.replace(/\/save-lib$/,'/users');
    const OWNER_CONTROL_URL = USERS_URL;
    const OWNER_USERNAME = 'Kuro';
    const OWNER_USERNAME_LOWER = OWNER_USERNAME.toLowerCase();
    const socialCache = new Map();
    const staffState = { owner: null, moderators: [] };
    const userDataCache = { fallbackUsers: null, lastFetched: 0 };
    const USERS_FILE_CANDIDATES = [
      'users/users.json','users/users.txt','users/users','users.json','users.txt','users'
    ];

    function saveEndpointCandidates(){
      const list = [SAVE_URL_LOCAL, SERVERLESS_URL].filter(Boolean);
      return Array.from(new Set(list));
    }

    function getRepoDefaults(){
      return {
        owner: GITHUB.owner || 'ItzKuroYT',
        repo: GITHUB.repo || 'JJS-Libraries',
        branch: GITHUB.branch || 'main'
      };
    }

    function encodePathForRaw(input){
      return input.split('/').map(seg=>encodeURIComponent(seg)).join('/');
    }

    function normalizeUserRecord(raw, idx){
      if(!raw) return null;
      if(typeof raw === 'string'){
        const trimmed = raw.trim();
        if(!trimmed) return null;
        return { id: String(idx ?? trimmed), username: trimmed, role: 'member' };
      }
      const username = (raw.username || raw.user || raw.name || raw.id || '').toString().trim();
      if(!username) return null;
      return {
        id: raw.id || String(idx ?? username),
        username,
        role: raw.role || raw.type || 'member'
      };
    }

    function parseUsersPayload(payload){
      if(!payload) return [];
      if(Array.isArray(payload)) return payload.map((item, idx)=> normalizeUserRecord(item, idx)).filter(Boolean);
      if(payload && Array.isArray(payload.users)) return payload.users.map((item, idx)=> normalizeUserRecord(item, idx)).filter(Boolean);
      return [];
    }

    async function fetchUsersFallback(force = false){
      const now = Date.now();
      if(!force && userDataCache.fallbackUsers && (now - userDataCache.lastFetched) < 60000){
        return userDataCache.fallbackUsers;
      }
      const { owner, repo, branch } = getRepoDefaults();
      const customPath = (window.USERS_FILE_PATH || '').trim();
      const candidates = [];
      if(customPath) candidates.push(customPath);
      USERS_FILE_CANDIDATES.forEach(path=>candidates.push(path));
      const tried = new Set();
      for(const candidateRaw of candidates){
        if(!candidateRaw) continue;
        const clean = candidateRaw.replace(/^\/+/,'');
        if(!clean || tried.has(clean)) continue;
        tried.add(clean);
        const url = `https://raw.githubusercontent.com/${owner}/${repo}/${branch}/${encodePathForRaw(clean)}`;
        try{
          const resp = await fetch(url, { cache: 'no-store' });
          if(!resp.ok) continue;
          const text = await resp.text();
          if(!text) continue;
          let normalized = null;
          try{
            const parsedJson = JSON.parse(text);
            normalized = parseUsersPayload(parsedJson);
          }catch(_err){
            const lines = text.split(/\r?\n/).map(line=>line.trim()).filter(Boolean);
            if(lines.length){
              normalized = lines.map((line, idx)=> normalizeUserRecord(line, idx)).filter(Boolean);
            }
          }
          if(normalized && normalized.length){
            userDataCache.fallbackUsers = normalized;
            userDataCache.lastFetched = now;
            return normalized;
          }
        }catch(_err){ /* ignore and try next */ }
      }
      return null;
    }

    function getOwnerFromFallback(usersList){
      if(!Array.isArray(usersList)) return OWNER_USERNAME ? { id: OWNER_USERNAME, username: OWNER_USERNAME } : null;
      const ownerMatch = usersList.find(u=> u && ((u.role || '').toLowerCase() === 'owner' || (u.username || '').toLowerCase() === OWNER_USERNAME_LOWER));
      if(ownerMatch) return { id: ownerMatch.id || ownerMatch.username, username: ownerMatch.username };
      return OWNER_USERNAME ? { id: OWNER_USERNAME, username: OWNER_USERNAME } : null;
    }

    function getModeratorsFromFallback(usersList){
      if(!Array.isArray(usersList)) return [];
      return usersList.filter(u=> (u.role || '').toLowerCase() === 'moderator').map(u=>({ id: u.id || u.username, username: u.username }));
    }

    function inferRoleFromPayload(payload){
      if(!payload) return 'member';
      if(payload.role) return payload.role;
      return inferRoleFromState(payload.username);
    }

    async function refreshUserCount(){
      const label = document.getElementById('currentUsersValue');
      if(!label) return;
      if(!USERS_URL){ label.textContent = 'n/a'; return; }
      label.textContent = '...';
      try{
        const resp = await fetch(USERS_URL + '?action=list');
        const data = await resp.json().catch(()=>null);
        if(!resp.ok || !data || !data.ok) throw new Error('Failed to load');
        label.textContent = Number(data.count) || 0;
        label.removeAttribute('title');
      }catch(err){
        try{
          const fallbackUsers = await fetchUsersFallback();
          if(fallbackUsers && fallbackUsers.length){
            label.textContent = fallbackUsers.length;
            label.title = 'Loaded from GitHub users file';
          }else{
            label.textContent = '??';
            label.title = 'Unable to load user count';
          }
        }catch(_fallbackErr){
          label.textContent = '??';
          label.title = 'Unable to load user count';
        }
      }
    }

    function updateTotalLibrariesDisplay(){
      const label = document.getElementById('totalLibrariesValue');
      if(!label) return;
      const viewer = getCurrentUser();
      const total = Array.isArray(libs) ? libs.filter(lib=>isLibVisibleToUser(lib, viewer)).length : 0;
      label.textContent = total;
    }

    async function refreshStaffDisplay(){
      const ownerEl = document.getElementById('staffOwnerValue');
      const modsWrap = document.getElementById('staffModerators');
      if(!ownerEl || !modsWrap) return;
      ownerEl.textContent = 'Loading...';
      modsWrap.innerHTML = '<span class="staffPill">Loading...</span>';
      let ownerRecord = null;
      let moderators = [];
      let usedFallback = false;
      let apiError = false;
      if(USERS_URL){
        try{
          const resp = await fetch(USERS_URL + '?action=staff');
          const data = await resp.json().catch(()=>null);
          if(!resp.ok || !data || !data.ok) throw new Error((data && data.error) || 'Failed to load staff');
          ownerRecord = data.owner || null;
          moderators = Array.isArray(data.moderators) ? data.moderators : [];
        }catch(_err){
          apiError = true;
        }
      }else{
        apiError = true;
      }
      let fallbackUsers = null;
      if(apiError || !ownerRecord || !moderators.length){
        try{
          fallbackUsers = await fetchUsersFallback();
        }catch(_err){ fallbackUsers = null; }
      }
      if(!ownerRecord && fallbackUsers){
        ownerRecord = getOwnerFromFallback(fallbackUsers);
        usedFallback = true;
      }
      if((!moderators.length) && fallbackUsers){
        const fallbackMods = getModeratorsFromFallback(fallbackUsers);
        if(fallbackMods.length){
          moderators = fallbackMods;
          usedFallback = true;
        }
      }
      if(!ownerRecord){
        ownerRecord = OWNER_USERNAME ? { id: OWNER_USERNAME, username: OWNER_USERNAME } : { id: 'owner', username: 'â€”' };
      }
      staffState.owner = ownerRecord;
      staffState.moderators = moderators;
      ownerEl.textContent = ownerRecord.username || 'â€”';
      if(usedFallback){
        ownerEl.title = 'Loaded from GitHub users file';
      }else{
        ownerEl.removeAttribute('title');
      }
      modsWrap.innerHTML = '';
      if(!moderators.length){
        const span = document.createElement('span');
        span.className = 'staffPill';
        span.textContent = apiError ? 'Staff unavailable' : 'No moderators yet';
        if(apiError) span.classList.add('staffError');
        modsWrap.appendChild(span);
      }else{
        moderators.forEach(mod=>{
          const span = document.createElement('span');
          span.className = 'staffPill';
          span.textContent = mod.username;
          modsWrap.appendChild(span);
        });
        modsWrap.removeAttribute('title');
      }
      updateAddModeratorButton();
      updateStaffConsoleVisibility();
      refreshOwnerControlFromServer().then(()=>{
        refreshListView({ refilter:true });
      }).catch(()=>{
        refreshListView({ refilter:true });
      });
    }

    function updateAddModeratorButton(){
      const btn = document.getElementById('addModeratorBtn');
      if(!btn) return;
      const user = getCurrentUser();
      const isOwner = permissionGuard.hasPermission(user, OWNER_PERMISSIONS.OWNER_PANEL);
      btn.style.display = isOwner ? 'inline-flex' : 'none';
      if(!isOwner){
        btn.disabled = false;
        btn.textContent = 'Add Moderator';
      }
    }

    async function promoteToModerator(username){
      const targetName = (username || '').trim();
      if(!targetName) throw new Error('username required');
      if(!USERS_URL) throw new Error('Users endpoint unavailable');
      const token = getToken();
      if(!token) throw new Error('Sign in as the owner to add staff');
      const resp = await fetch(USERS_URL + '?action=addModerator', {
        method:'POST',
        headers:{'Content-Type':'application/json','Authorization':'Bearer ' + token},
        body: JSON.stringify({ username: targetName })
      });
      const data = await resp.json().catch(()=>null);
      if(!resp.ok || !data || !data.ok) throw new Error((data && data.error) || 'Failed to update staff');
      try{ roleService.assignRole(targetName, 'moderator'); }catch(_e){}
      return data.user;
    }

    async function demoteModerator(username){
      const targetName = (username || '').trim();
      if(!targetName) throw new Error('username required');
      if(!USERS_URL) throw new Error('Users endpoint unavailable');
      const token = getToken();
      if(!token) throw new Error('Sign in as the owner to update staff');
      const resp = await fetch(USERS_URL + '?action=removeModerator', {
        method:'POST',
        headers:{'Content-Type':'application/json','Authorization':'Bearer ' + token},
        body: JSON.stringify({ username: targetName })
      });
      const data = await resp.json().catch(()=>null);
      if(!resp.ok || !data || !data.ok) throw new Error((data && data.error) || 'Failed to update staff');
      try{ roleService.removeRole(targetName, 'moderator'); }catch(_e){}
      return data.user;
    }

    async function handleAddModeratorClick(){
      const btn = document.getElementById('addModeratorBtn');
      if(!btn) return;
      const input = prompt('Enter username to promote to moderator');
      if(!input) return;
      const target = input.trim();
      if(!target) return;
      const original = btn.textContent;
      btn.disabled = true;
      btn.textContent = 'Adding...';
      try{
        const promoted = await promoteToModerator(target);
        const displayName = promoted && promoted.username ? promoted.username : target;
        addNotification(displayName + ' is now a moderator');
        await refreshStaffDisplay();
      }catch(err){
        alert(err && err.message ? err.message : 'Failed to add moderator');
      }finally{
        btn.disabled = false;
        btn.textContent = original;
      }
    }

    function refreshGlobalRoleBadgeUI(){
      refreshListView({ refilter:true });
      renderSidebar();
      const profileModal = document.getElementById('profileModal');
      if(profileModal){
        const heading = profileModal.querySelector('[data-profile-username]');
        if(heading){
          renderRoleBadgesInline(heading.parentElement || heading, heading.getAttribute('data-profile-username') || '');
        }
      }
    }

    function ensureOwnerAccess(user = getCurrentUser()){
      permissionGuard.requireOwner(user);
      return true;
    }

    function findLibraryByRef(ref){
      const text = String(ref || '').trim();
      if(!text) return null;
      const byId = libs.find(lib=> String(lib.id) === text);
      if(byId) return byId;
      const lower = text.toLowerCase();
      return libs.find(lib=> String(lib.title || '').toLowerCase() === lower) || null;
    }

    const commandHandler = {
      registry: {
        cmds: {
          usage: '?cmds',
          description: 'Open command help panel',
          run: async ()=>{
            openOwnerCommandPanel();
            return 'Opened command panel';
          }
        },
        mod: {
          usage: 'mod <user>',
          description: 'Grant moderator role',
          run: async ([username], user)=>{
            ensureOwnerAccess(user);
            if(!username) throw new Error('Usage: mod <user>');
            await promoteToModerator(username);
            await refreshStaffDisplay();
            refreshGlobalRoleBadgeUI();
            return `${username} promoted to moderator`;
          }
        },
        unmod: {
          usage: 'unmod <user>',
          description: 'Remove moderator role',
          run: async ([username], user)=>{
            ensureOwnerAccess(user);
            if(!username) throw new Error('Usage: unmod <user>');
            await demoteModerator(username);
            await refreshStaffDisplay();
            refreshGlobalRoleBadgeUI();
            return `${username} removed from moderators`;
          }
        },
        giverole: {
          usage: 'giverole <user> <role>',
          description: 'Assign a role to a user',
          run: async ([username, roleId], user)=>{
            ensureOwnerAccess(user);
            if(!username || !roleId) throw new Error('Usage: giverole <user> <role>');
            roleService.assignRole(username, roleId);
            refreshGlobalRoleBadgeUI();
            return `Assigned ${roleId} to ${username}`;
          }
        },
        removerole: {
          usage: 'removerole <user> <role>',
          description: 'Remove a role from a user',
          run: async ([username, roleId], user)=>{
            ensureOwnerAccess(user);
            if(!username || !roleId) throw new Error('Usage: removerole <user> <role>');
            roleService.removeRole(username, roleId);
            refreshGlobalRoleBadgeUI();
            return `Removed ${roleId} from ${username}`;
          }
        },
        givebadge: {
          usage: 'givebadge <user> <badge>',
          description: 'Assign a badge to a user',
          run: async ([username, badgeId], user)=>{
            ensureOwnerAccess(user);
            if(!username || !badgeId) throw new Error('Usage: givebadge <user> <badge>');
            badgeService.assignBadge(username, badgeId);
            refreshGlobalRoleBadgeUI();
            return `Assigned ${badgeId} to ${username}`;
          }
        },
        removebadge: {
          usage: 'removebadge <user> <badge>',
          description: 'Remove a badge from a user',
          run: async ([username, badgeId], user)=>{
            ensureOwnerAccess(user);
            if(!username || !badgeId) throw new Error('Usage: removebadge <user> <badge>');
            badgeService.removeBadge(username, badgeId);
            refreshGlobalRoleBadgeUI();
            return `Removed ${badgeId} from ${username}`;
          }
        },
        pinpost: {
          usage: 'pinpost <postId|title>',
          description: 'Pin a post',
          run: async ([...parts], user)=>{
            if(!permissionGuard.hasPermission(user, OWNER_PERMISSIONS.MODERATION_TOOLS)) throw new Error('Permission denied');
            const target = findLibraryByRef(parts.join(' '));
            if(!target) throw new Error('Post not found');
            target.pinned = true;
            await persistLibraryFile(target);
            refreshListView({ refilter:true });
            return `Pinned ${target.title || target.id}`;
          }
        },
        deletepost: {
          usage: 'deletepost <postId|title>',
          description: 'Delete a post',
          run: async ([...parts], user)=>{
            if(!permissionGuard.hasPermission(user, OWNER_PERMISSIONS.MODERATION_TOOLS)) throw new Error('Permission denied');
            const target = findLibraryByRef(parts.join(' '));
            if(!target) throw new Error('Post not found');
            const idx = libs.findIndex(lib=> lib && lib.id === target.id);
            if(idx < 0) throw new Error('Post not found');
            libs.splice(idx, 1);
            refreshListView({ refilter:true, resetPage:true });
            return `Deleted ${target.title || target.id}`;
          }
        },
        banuser: {
          usage: 'banuser <username>',
          description: 'Local ban list (optional)',
          run: async ([username], user)=>{
            if(!permissionGuard.hasPermission(user, OWNER_PERMISSIONS.MODERATION_TOOLS)) throw new Error('Permission denied');
            const target = String(username || '').trim();
            if(!target) throw new Error('Usage: banuser <username>');
            const key = 'jjs_banned_users';
            let list = [];
            try{ list = JSON.parse(localStorage.getItem(key) || '[]'); }catch(_e){ list = []; }
            list = dedupeStringList([...(Array.isArray(list) ? list : []), target]);
            try{ localStorage.setItem(key, JSON.stringify(list)); }catch(_e){}
            return `${target} added to local ban list`;
          }
        }
      },
      list(){
        return Object.entries(this.registry).map(([name, item])=>({ name, usage:item.usage, description:item.description }));
      },
      async run(rawCommand){
        const user = getCurrentUser();
        const text = String(rawCommand || '').trim();
        if(!text) throw new Error('Enter a command');
        const normalized = text.startsWith('?') ? text.slice(1) : text;
        const parts = normalized.split(/\s+/).filter(Boolean);
        const name = (parts.shift() || '').toLowerCase();
        const entry = this.registry[name];
        if(!entry) throw new Error('Unknown command. Run ?cmds');
        if(name !== 'cmds') ensureOwnerAccess(user);
        return await entry.run(parts, user);
      }
    };

    function openOwnerCommandPanel(){
      try{ ensureOwnerAccess(getCurrentUser()); }catch(_e){
        alert('Owner access required');
        return;
      }
      let modal = document.getElementById('ownerCommandsModal');
      if(modal) modal.remove();
      modal = document.createElement('div');
      modal.id = 'ownerCommandsModal';
      modal.className = 'ownerPanelOverlay';
      modal.innerHTML = `<div class="ownerPanelCard" style="grid-template-columns:1fr;max-width:760px">
        <div class="ownerPanelBody">
          <div class="ownerRow" style="justify-content:space-between">
            <h3 style="margin:0">Command Console</h3>
            <button class="ghost" id="closeOwnerCommands" type="button">Close</button>
          </div>
          <div class="ownerCommands" id="ownerCommandsList"></div>
          <form id="ownerCommandsForm" class="ownerRow">
            <input id="ownerCommandInput" placeholder="giverole username moderator" />
            <button class="ghost" type="submit">Run</button>
          </form>
          <div class="ownerStatus" id="ownerCommandStatus"></div>
        </div>
      </div>`;
      document.body.appendChild(modal);
      const listEl = modal.querySelector('#ownerCommandsList');
      if(listEl){
        listEl.innerHTML = commandHandler.list().map(item=>`<div><strong>${escapeHtml(item.usage)}</strong> â€” ${escapeHtml(item.description)}</div>`).join('');
      }
      const close = ()=> modal.remove();
      modal.querySelector('#closeOwnerCommands').addEventListener('click', close);
      modal.addEventListener('click', ev=>{ if(ev.target === modal) close(); });
      const form = modal.querySelector('#ownerCommandsForm');
      const input = modal.querySelector('#ownerCommandInput');
      const status = modal.querySelector('#ownerCommandStatus');
      form.addEventListener('submit', async ev=>{
        ev.preventDefault();
        const cmd = input.value.trim();
        if(!cmd){ status.textContent = 'Enter a command'; return; }
        status.textContent = 'Running...';
        try{
          const result = await commandHandler.run(cmd);
          status.textContent = result;
          input.value = '';
        }catch(err){
          status.textContent = err && err.message ? err.message : 'Command failed';
        }
      });
      input.focus();
    }

    async function openOwnerPanel(){
      const user = getCurrentUser();
      try{ ensureOwnerAccess(user); }catch(_e){
        alert('Owner access required');
        if(location.hash === '#owner-panel') history.replaceState(null, '', location.pathname + location.search);
        return;
      }
      loadOwnerControlState();
      await refreshOwnerControlFromServer(true);
      let panel = document.getElementById('ownerPanelModal');
      if(panel) panel.remove();
      panel = document.createElement('div');
      panel.id = 'ownerPanelModal';
      panel.className = 'ownerPanelOverlay';
      panel.innerHTML = `<div class="ownerPanelCard">
        <aside class="ownerPanelSide">
          <button class="ownerPanelTab active" data-owner-tab="roles" type="button">Role Management</button>
          <button class="ownerPanelTab" data-owner-tab="badges" type="button">Badge Management</button>
          <button class="ownerPanelTab" data-owner-tab="assign" type="button">User Assignment</button>
          <button class="ownerPanelTab" data-owner-tab="mods" type="button">Moderator Management</button>
          <button class="ownerPanelTab" data-owner-tab="commands" type="button">Command Console</button>
          <button class="ghost" id="closeOwnerPanel" type="button" style="margin-top:auto">Close</button>
        </aside>
        <section class="ownerPanelBody" id="ownerPanelBody"></section>
      </div>`;
      document.body.appendChild(panel);

      const body = panel.querySelector('#ownerPanelBody');
      const tabs = Array.from(panel.querySelectorAll('.ownerPanelTab'));

      const renderUserSearch = (container, onPick)=>{
        const wrap = document.createElement('div');
        wrap.className = 'ownerCard';
        wrap.innerHTML = `<div class="ownerRow"><input placeholder="Search user..." /><div class="ownerStatus">Fast search</div></div><div class="ownerSearchResults"></div>`;
        const input = wrap.querySelector('input');
        const results = wrap.querySelector('.ownerSearchResults');
        const renderResults = ()=>{
          const list = searchKnownUsers(input.value);
          results.innerHTML = '';
          if(!list.length){ results.innerHTML = '<div class="ownerStatus">No users found</div>'; return; }
          list.forEach(username=>{
            const row = document.createElement('div');
            row.className = 'ownerSearchResult';
            row.textContent = username;
            row.addEventListener('click', ()=> onPick(username));
            results.appendChild(row);
          });
        };
        input.addEventListener('input', renderResults);
        renderResults();
        container.appendChild(wrap);
      };

      const renderRolesTab = ()=>{
        const roles = roleService.getAll();
        body.innerHTML = `<h3 style="margin:0">Role Management</h3>
          <div class="ownerCard"><div class="ownerRow">
            <input id="newRoleName" placeholder="Role name" />
            <input id="newRoleColor" type="color" value="#a9b9d3" style="max-width:70px;padding:4px" />
            <input id="newRoleGradient" placeholder="Optional gradient (linear-gradient(...))" />
            <input id="newRoleIcon" placeholder="Icon" style="max-width:90px" />
            <input id="newRolePriority" type="number" value="100" placeholder="Priority" style="max-width:100px" />
            <input id="newRolePermissions" placeholder="permissions (comma separated)" />
            <button class="ghost" id="createRoleBtn" type="button">Create role</button>
          </div></div>
          <div class="ownerList" id="ownerRolesList"></div>`;
        const listEl = body.querySelector('#ownerRolesList');
        roles.forEach(role=>{
          const item = document.createElement('div');
          item.className = 'ownerListItem';
          item.innerHTML = `<div class="ownerListMeta"><span class="ownerDot" style="--dot-color:${escapeHtml(role.color)}"></span><b>${escapeHtml(role.icon ? `${role.icon} ${role.name}` : role.name)}</b><span class="ownerStatus">priority ${Number(role.priority)||0}</span></div>
          <div class="ownerRow"><button class="ghost" data-action="edit">Edit</button><button class="ghost" data-action="delete">Delete</button></div>`;
          item.querySelector('[data-action="edit"]').addEventListener('click', ()=>{
            const name = prompt('Role name', role.name);
            if(name === null) return;
            const color = prompt('Role color (hex)', role.color);
            if(color === null) return;
            const gradient = prompt('Role gradient (optional, e.g. linear-gradient(...))', role.gradient || '');
            if(gradient === null) return;
            const icon = prompt('Role icon (optional)', role.icon || '');
            if(icon === null) return;
            const priorityInput = prompt('Priority number', String(role.priority || 0));
            if(priorityInput === null) return;
            const permissionsInput = prompt('Permissions (comma separated)', (role.permissions || []).join(','));
            if(permissionsInput === null) return;
            try{
              roleService.update(role.id, {
                name,
                color,
                gradient,
                icon,
                priority: Number(priorityInput) || 0,
                permissions: permissionsInput.split(',').map(v=>v.trim()).filter(Boolean)
              });
              refreshGlobalRoleBadgeUI();
              renderRolesTab();
            }catch(err){ alert(err && err.message ? err.message : 'Update failed'); }
          });
          item.querySelector('[data-action="delete"]').addEventListener('click', ()=>{
            if(role.id === 'owner') return alert('Owner role cannot be deleted');
            if(!confirm(`Delete role ${role.name}? This removes it from all users.`)) return;
            try{
              roleService.delete(role.id);
              refreshGlobalRoleBadgeUI();
              renderRolesTab();
            }catch(err){ alert(err && err.message ? err.message : 'Delete failed'); }
          });
          listEl.appendChild(item);
        });
        body.querySelector('#createRoleBtn').addEventListener('click', ()=>{
          const name = body.querySelector('#newRoleName').value.trim();
          const color = body.querySelector('#newRoleColor').value;
          const gradient = body.querySelector('#newRoleGradient').value.trim();
          const icon = body.querySelector('#newRoleIcon').value.trim();
          const priority = Number(body.querySelector('#newRolePriority').value || 0);
          const permissions = body.querySelector('#newRolePermissions').value.split(',').map(v=>v.trim()).filter(Boolean);
          try{
            roleService.create({ name, color, gradient, icon, priority, permissions });
            refreshGlobalRoleBadgeUI();
            renderRolesTab();
          }catch(err){ alert(err && err.message ? err.message : 'Create failed'); }
        });
      };

      const renderBadgesTab = ()=>{
        const badges = badgeService.getAll();
        body.innerHTML = `<h3 style="margin:0">Badge Management</h3>
          <div class="ownerCard"><div class="ownerRow">
            <input id="newBadgeName" placeholder="Badge name" />
            <input id="newBadgeIcon" placeholder="Icon" style="max-width:90px" value="ðŸ…" />
            <input id="newBadgeColor" type="color" value="#a9b9d3" style="max-width:70px;padding:4px" />
            <input id="newBadgeGradient" placeholder="Optional gradient (linear-gradient(...))" />
            <input id="newBadgeTooltip" placeholder="Tooltip description" />
            <button class="ghost" id="createBadgeBtn" type="button">Create badge</button>
          </div></div>
          <div class="ownerList" id="ownerBadgesList"></div>`;
        const listEl = body.querySelector('#ownerBadgesList');
        badges.forEach(badge=>{
          const item = document.createElement('div');
          item.className = 'ownerListItem';
          item.innerHTML = `<div class="ownerListMeta"><span class="ownerDot" style="--dot-color:${escapeHtml(badge.color)}"></span><b>${escapeHtml(`${badge.icon} ${badge.name}`)}</b><span class="ownerStatus">${escapeHtml(badge.tooltip || 'No tooltip')}</span></div>
          <div class="ownerRow"><button class="ghost" data-action="edit">Edit</button><button class="ghost" data-action="delete">Delete</button></div>`;
          item.querySelector('[data-action="edit"]').addEventListener('click', ()=>{
            const name = prompt('Badge name', badge.name);
            if(name === null) return;
            const icon = prompt('Badge icon', badge.icon || 'ðŸ…');
            if(icon === null) return;
            const color = prompt('Badge color (hex)', badge.color);
            if(color === null) return;
            const gradient = prompt('Badge gradient (optional, e.g. linear-gradient(...))', badge.gradient || '');
            if(gradient === null) return;
            const tooltip = prompt('Tooltip description', badge.tooltip || '');
            if(tooltip === null) return;
            const showInComments = confirm('Show badge in comments? (OK = Yes, Cancel = No)');
            try{
              badgeService.update(badge.id, { name, icon, color, gradient, tooltip, showInComments });
              refreshGlobalRoleBadgeUI();
              renderBadgesTab();
            }catch(err){ alert(err && err.message ? err.message : 'Update failed'); }
          });
          item.querySelector('[data-action="delete"]').addEventListener('click', ()=>{
            if(!confirm(`Delete badge ${badge.name}? It will be removed from all users.`)) return;
            try{
              badgeService.delete(badge.id);
              refreshGlobalRoleBadgeUI();
              renderBadgesTab();
            }catch(err){ alert(err && err.message ? err.message : 'Delete failed'); }
          });
          listEl.appendChild(item);
        });
        body.querySelector('#createBadgeBtn').addEventListener('click', ()=>{
          const name = body.querySelector('#newBadgeName').value.trim();
          const icon = body.querySelector('#newBadgeIcon').value.trim() || 'ðŸ…';
          const color = body.querySelector('#newBadgeColor').value;
          const gradient = body.querySelector('#newBadgeGradient').value.trim();
          const tooltip = body.querySelector('#newBadgeTooltip').value.trim();
          try{
            badgeService.create({ name, icon, color, gradient, tooltip, showInComments:true });
            refreshGlobalRoleBadgeUI();
            renderBadgesTab();
          }catch(err){ alert(err && err.message ? err.message : 'Create failed'); }
        });
      };

      const renderAssignTab = ()=>{
        body.innerHTML = `<h3 style="margin:0">User Role & Badge Assignment</h3><div id="ownerAssignMount"></div><div class="ownerStatus" id="ownerAssignStatus"></div>`;
        const mount = body.querySelector('#ownerAssignMount');
        const status = body.querySelector('#ownerAssignStatus');
        renderUserSearch(mount, username=>{
          const roles = roleService.getAll();
          const badges = badgeService.getAll();
          const roleId = prompt(`Assign role to ${username}. Available: ${roles.map(r=>r.id).join(', ')}`);
          if(roleId){
            try{ roleService.assignRole(username, roleId); status.textContent = `Assigned role ${roleId} to ${username}`; }catch(err){ status.textContent = err && err.message ? err.message : 'Role assignment failed'; }
          }
          const removeRoleId = prompt(`Remove role from ${username} (optional). Leave empty to skip.`);
          if(removeRoleId){
            try{ roleService.removeRole(username, removeRoleId); status.textContent = `Removed role ${removeRoleId} from ${username}`; }catch(err){ status.textContent = err && err.message ? err.message : 'Role remove failed'; }
          }
          if(badges.length){
            const badgeId = prompt(`Assign badge to ${username}. Available: ${badges.map(b=>b.id).join(', ')}`);
            if(badgeId){
              try{ badgeService.assignBadge(username, badgeId); status.textContent = `Assigned badge ${badgeId} to ${username}`; }catch(err){ status.textContent = err && err.message ? err.message : 'Badge assignment failed'; }
            }
            const removeBadgeId = prompt(`Remove badge from ${username} (optional). Leave empty to skip.`);
            if(removeBadgeId){
              try{ badgeService.removeBadge(username, removeBadgeId); status.textContent = `Removed badge ${removeBadgeId} from ${username}`; }catch(err){ status.textContent = err && err.message ? err.message : 'Badge remove failed'; }
            }
          }
          refreshGlobalRoleBadgeUI();
        });
      };

      const renderModeratorsTab = ()=>{
        body.innerHTML = `<h3 style="margin:0">Moderator Management</h3><div id="ownerModsMount"></div><div class="ownerStatus" id="ownerModsStatus"></div><div class="ownerList" id="ownerModsList"></div>`;
        const status = body.querySelector('#ownerModsStatus');
        const list = body.querySelector('#ownerModsList');
        const renderMods = ()=>{
          list.innerHTML = '';
          const mods = (staffState.moderators || []).slice();
          if(!mods.length){ list.innerHTML = '<div class="ownerStatus">No moderators yet</div>'; return; }
          mods.forEach(mod=>{
            const row = document.createElement('div');
            row.className = 'ownerListItem';
            row.innerHTML = `<div class="ownerListMeta"><b>${escapeHtml(mod.username || 'unknown')}</b></div><button class="ghost" type="button">Remove moderator</button>`;
            row.querySelector('button').addEventListener('click', async ()=>{
              if(!confirm(`Remove moderator ${mod.username}?`)) return;
              try{
                await demoteModerator(mod.username);
                roleService.removeRole(mod.username, 'moderator');
                await refreshStaffDisplay();
                refreshGlobalRoleBadgeUI();
                renderMods();
                status.textContent = `${mod.username} removed from moderators`;
              }catch(err){ status.textContent = err && err.message ? err.message : 'Failed to remove moderator'; }
            });
            list.appendChild(row);
          });
        };
        renderUserSearch(body.querySelector('#ownerModsMount'), async username=>{
          try{
            await promoteToModerator(username);
            roleService.assignRole(username, 'moderator');
            await refreshStaffDisplay();
            refreshGlobalRoleBadgeUI();
            renderMods();
            status.textContent = `${username} is now a moderator`;
          }catch(err){ status.textContent = err && err.message ? err.message : 'Failed to add moderator'; }
        });
        renderMods();
      };

      const renderCommandsTab = ()=>{
        body.innerHTML = `<h3 style="margin:0">Command Console</h3>
          <div class="ownerCommands">${commandHandler.list().map(item=>`<div><strong>${escapeHtml(item.usage)}</strong> â€” ${escapeHtml(item.description)}</div>`).join('')}</div>
          <form id="ownerPanelCommandForm" class="ownerRow"><input id="ownerPanelCommandInput" placeholder="giverole user moderator"/><button class="ghost" type="submit">Run</button></form>
          <div class="ownerStatus" id="ownerPanelCommandStatus"></div>`;
        const form = body.querySelector('#ownerPanelCommandForm');
        const input = body.querySelector('#ownerPanelCommandInput');
        const status = body.querySelector('#ownerPanelCommandStatus');
        form.addEventListener('submit', async ev=>{
          ev.preventDefault();
          const cmd = input.value.trim();
          if(!cmd){ status.textContent = 'Enter a command'; return; }
          status.textContent = 'Running...';
          try{
            const result = await commandHandler.run(cmd);
            status.textContent = result;
            input.value = '';
          }catch(err){
            status.textContent = err && err.message ? err.message : 'Command failed';
          }
        });
      };

      const renderTab = (tab)=>{
        tabs.forEach(btn=> btn.classList.toggle('active', btn.getAttribute('data-owner-tab') === tab));
        if(tab === 'roles') return renderRolesTab();
        if(tab === 'badges') return renderBadgesTab();
        if(tab === 'assign') return renderAssignTab();
        if(tab === 'mods') return renderModeratorsTab();
        return renderCommandsTab();
      };

      tabs.forEach(btn=> btn.addEventListener('click', ()=> renderTab(btn.getAttribute('data-owner-tab') || 'roles')));
      panel.querySelector('#closeOwnerPanel').addEventListener('click', ()=>{
        panel.remove();
        if(location.hash === '#owner-panel') history.replaceState(null, '', location.pathname + location.search);
      });
      panel.addEventListener('click', ev=>{
        if(ev.target === panel){
          panel.remove();
          if(location.hash === '#owner-panel') history.replaceState(null, '', location.pathname + location.search);
        }
      });
      renderTab('roles');
    }

    async function runStaffConsoleCommand(command){
      const text = String(command || '').trim();
      if(!text) throw new Error('Enter a command');
      if(/^\?cmds$/i.test(text)){
        openOwnerCommandPanel();
        return 'Opened command panel';
      }
      return await commandHandler.run(text);
    }

    async function runStaffConsoleCommand(command){
      const match = command.match(/^\?(mod|unmod)\s+(.+)$/i);
      if(!match) throw new Error('Use ?mod username or ?unmod username');
      const action = match[1].toLowerCase();
      let target = match[2].trim();
      if(target.startsWith('(') && target.endsWith(')')) target = target.slice(1, -1).trim();
      if(!target) throw new Error('Username required');
      if(action === 'mod'){
        const promoted = await promoteToModerator(target);
        const name = promoted && promoted.username ? promoted.username : target;
        addNotification(name + ' promoted to moderator');
        await refreshStaffDisplay();
        return name + ' promoted to moderator';
      }
      const demoted = await demoteModerator(target);
      const name = demoted && demoted.username ? demoted.username : target;
      addNotification(name + ' removed from moderators');
      await refreshStaffDisplay();
      return name + ' removed from moderators';
    }

    async function handleStaffConsoleSubmit(ev){
      if(ev) ev.preventDefault();
      const inputEl = document.getElementById('staffConsoleInput');
      const statusEl = document.getElementById('staffConsoleStatus');
      if(!inputEl) return;
      const command = inputEl.value.trim();
      if(!command){
        if(statusEl) statusEl.textContent = 'Enter a command';
        return;
      }
      if(statusEl) statusEl.textContent = 'Running...';
      try{
        const resultText = await runStaffConsoleCommand(command);
        if(statusEl) statusEl.textContent = resultText;
        inputEl.value = '';
      }catch(err){
        if(statusEl) statusEl.textContent = err && err.message ? err.message : 'Command failed';
      }
    }

    function updateStaffConsoleVisibility(){
      const consoleBlock = document.getElementById('staffConsoleBlock');
      if(!consoleBlock) return;
      const user = getCurrentUser();
      const isOwner = permissionGuard.hasPermission(user, OWNER_PERMISSIONS.OWNER_PANEL);
      const ownerShortcut = document.getElementById('openOwnerPanelBtn');
      if(ownerShortcut){
        ownerShortcut.style.display = isOwner ? 'inline-flex' : 'none';
      }
      const reportsBtn = document.getElementById('reviewReportsBtn');
      if(reportsBtn){
        reportsBtn.style.display = isStaffUser(user) ? 'inline-flex' : 'none';
      }
      consoleBlock.style.display = isOwner ? 'block' : 'none';
      if(!isOwner){
        const statusEl = document.getElementById('staffConsoleStatus');
        if(statusEl) statusEl.textContent = '';
        const inputEl = document.getElementById('staffConsoleInput');
        if(inputEl) inputEl.value = '';
        const ownerPanel = document.getElementById('ownerPanelModal');
        if(ownerPanel) ownerPanel.remove();
        const ownerCmds = document.getElementById('ownerCommandsModal');
        if(ownerCmds) ownerCmds.remove();
        if(location.hash === '#owner-panel'){
          history.replaceState(null, '', location.pathname + location.search);
        }
      }
      const me = getCurrentUser();
      const feedModeSelect = document.getElementById('feedModeSelect');
      if(feedModeSelect){
        feedModeSelect.disabled = !me;
        if(!me){
          feedModeSelect.value = 'all';
          activeFeedMode = 'all';
        }
      }
    }

    function handleOwnerHashRoute(){
      if(location.hash !== '#owner-panel') return;
      const user = getCurrentUser();
      if(!permissionGuard.hasPermission(user, OWNER_PERMISSIONS.OWNER_PANEL)){
        history.replaceState(null, '', location.pathname + location.search);
        const openPanel = document.getElementById('ownerPanelModal');
        if(openPanel) openPanel.remove();
        return;
      }
      if(!document.getElementById('ownerPanelModal')) openOwnerPanel();
    }

    function normalizeUsernameForPath(username){
      return (username || '').toString().trim().replace(/[^a-z0-9_-]/gi,'_');
    }

    function getUsernameLookupVariants(username){
      const raw = String(username || '').trim();
      if(!raw) return [];
      const base = [raw];
      const dashParts = raw.split(/\s*-\s*/).map(part=>part.trim()).filter(Boolean);
      if(dashParts.length > 1) base.push(dashParts[dashParts.length - 1]);
      const wordParts = raw.split(/\s+/).map(part=>part.trim()).filter(Boolean);
      if(wordParts.length > 1) base.push(wordParts[wordParts.length - 1]);

      const out = [];
      const seen = new Set();
      base.forEach(item=>{
        const normalized = normalizeUsernameForPath(item);
        if(!normalized) return;
        [normalized, normalized.toLowerCase(), normalized.toUpperCase()].forEach(value=>{
          const key = String(value || '').trim();
          if(!key) return;
          if(seen.has(key)) return;
          seen.add(key);
          out.push(key);
        });
      });
      return out;
    }

    function normalizeUsernameKey(username){
      return normalizeUsernameForPath(username).toLowerCase();
    }

    function getSocialStorageKey(username){
      return 'jjs_social_' + normalizeUsernameKey(username);
    }

    function getAvatarStorageKey(username){
      return 'jjs_avatar_url_' + normalizeUsernameKey(username);
    }

    function getStoredAvatarUrl(username){
      try{
        if(username){
          return localStorage.getItem(getAvatarStorageKey(username)) || '';
        }
        return localStorage.getItem('jjs_avatar_url') || '';
      }catch(_e){
        return '';
      }
    }

    function getHomeCachedAvatarUrl(username){
      const normalized = normalizeUsernameKey(username);
      if(!normalized) return '';
      try{
        const map = JSON.parse(localStorage.getItem('jjs_cached_user_info') || '{}') || {};
        const fromMap = map[normalized] || map[username] || null;
        if(fromMap && typeof fromMap.avatarUrl === 'string' && fromMap.avatarUrl.trim()) return fromMap.avatarUrl.trim();
      }catch(_e){}
      try{
        const homeProfile = JSON.parse(localStorage.getItem('jjs_profile_v2') || '{}') || {};
        if(homeProfile && normalizeUsernameKey(homeProfile.username) === normalized && typeof homeProfile.avatarUrl === 'string'){
          return homeProfile.avatarUrl.trim();
        }
      }catch(_e){}
      return '';
    }

    function getAvatarBasePath(){
      const configured = (GITHUB.avatarsPath || '').replace(/^\/+/, '').replace(/\/+$/, '');
      if(configured) return configured;
      const basePath = (GITHUB.path || '').replace(/^\/+/, '').replace(/\/+$/, '');
      return basePath ? `${basePath}/avatars` : 'avatars';
    }

    function buildAvatarUrls(username){
      const safeUsers = getUsernameLookupVariants(username);
      if(!safeUsers.length) return [];
      const owner = GITHUB.owner || 'ItzKuroYT';
      const repo = GITHUB.repo || 'JJS-Libraries';
      const branch = GITHUB.branch || 'main';
      const avatarBasePath = getAvatarBasePath();
      const exts = ['png','jpg','jpeg','webp','gif'];
      const urls = [];
      const seen = new Set();
      safeUsers.forEach(safeUser=>{
        exts.forEach(ext=>{
          const remotePath = avatarBasePath ? `${avatarBasePath}/${safeUser}.${ext}` : `${safeUser}.${ext}`;
          const url = `https://raw.githubusercontent.com/${owner}/${repo}/${branch}/${encodePathForRaw(remotePath)}`;
          if(seen.has(url)) return;
          seen.add(url);
          urls.push(url);
        });
      });
      return urls;
    }

    function buildAvatarUrl(username){
      const urls = buildAvatarUrls(username);
      return urls[0] || DEFAULT_AVATAR_URL;
    }

    function getAvatarSourceBundle(username, social){
      const sanitizeAvatarSource = (value)=>{
        const raw = String(value || '').trim();
        if(!raw) return '';
        const lowered = raw.toLowerCase();
        if(lowered.endsWith('/default.png') || lowered === 'default.png') return '';
        return raw;
      };
      const normalizedSocialUrl = sanitizeAvatarSource(social && typeof social.avatar_url === 'string' ? social.avatar_url : '');
      const storedAvatarUrl = sanitizeAvatarSource(getStoredAvatarUrl(username));
      const homeCachedAvatarUrl = sanitizeAvatarSource(getHomeCachedAvatarUrl(username));
      const candidateUrls = buildAvatarUrls(username);
      const primary = normalizedSocialUrl || homeCachedAvatarUrl || storedAvatarUrl || candidateUrls[0] || '';
      const fallbackSources = [];
      const seen = new Set([primary, DEFAULT_AVATAR_URL, FALLBACK_AVATAR_DATA_URI]);
      candidateUrls.forEach(url=>{
        if(!url || seen.has(url)) return;
        seen.add(url);
        fallbackSources.push(url);
      });
      return {
        src: primary,
        stage: primary && primary !== DEFAULT_AVATAR_URL && primary !== FALLBACK_AVATAR_DATA_URI ? 'remote' : 'none',
        fallbackSources
      };
    }

    function resolveAvatarUrl(username, social){
      return getAvatarSourceBundle(username, social).src || DEFAULT_AVATAR_URL;
    }

    function setAvatarImage(imgEl, opts = {}){
      if(!imgEl) return;
      const wrapper = opts.wrapper || null;
      const requestedSrc = typeof opts.src === 'string' ? opts.src.trim() : '';
      const resolvedSrc = requestedSrc || DEFAULT_AVATAR_URL;
      const resolvedStage = opts.stage || ((requestedSrc && requestedSrc !== DEFAULT_AVATAR_URL && requestedSrc !== FALLBACK_AVATAR_DATA_URI) ? 'remote' : 'none');
      const fallbackSources = Array.isArray(opts.fallbackSources)
        ? opts.fallbackSources.filter(src=> typeof src === 'string' && src.trim() && src.trim() !== requestedSrc)
        : [];
      const updateWrapper = (filled)=>{
        if(!wrapper) return;
        wrapper.style.background = filled ? 'none' : 'rgba(255,255,255,0.08)';
      };
      const clearImage = ()=>{
        imgEl.dataset.avatarStage = 'none';
        imgEl.removeAttribute('src');
        imgEl.style.display = 'none';
      };
      const applySource = (srcValue, stageValue)=>{
        imgEl.dataset.avatarStage = stageValue;
        imgEl.style.display = '';
        imgEl.src = srcValue;
      };
      imgEl.onload = ()=> updateWrapper(true);
      imgEl.onerror = ()=>{
        const stage = imgEl.dataset.avatarStage || 'remote';
        if(stage === 'remote'){
          if(fallbackSources.length){
            const nextSrc = fallbackSources.shift();
            applySource(nextSrc, 'remote');
            return;
          }
          clearImage();
          updateWrapper(false);
          return;
        }
        imgEl.onerror = null;
      };
      if(!resolvedSrc){
        clearImage();
        updateWrapper(false);
        return;
      }
      applySource(resolvedSrc, resolvedStage);
      updateWrapper(resolvedStage === 'remote');
    }

    // --- Authentication helpers (client-side) ---
    const GUEST_KEY = 'jjs_guest_mode';

    function isGuestModeActive(){
      try{ return localStorage.getItem(GUEST_KEY) === '1'; }catch(_e){ return false; }
    }

    function getSessionUser(){
      const authed = getCurrentUser();
      if(authed) return authed;
      if(isGuestModeActive()) return { username: 'Guest', id: 'guest', role: 'guest' };
      return null;
    }

    function hasFullAccountAccess(){
      return !!getCurrentUser();
    }

    function setToken(tok){
      try{
        if(tok) localStorage.setItem('jjs_token', tok);
        else localStorage.removeItem('jjs_token');
      }catch(e){}
      ensureCurrentUserJoinDate();
      updateUserLabel();
      updateAddModeratorButton();
      updateStaffConsoleVisibility();
      refreshListView({ refilter:true });
    }
    function getToken(){ try{ return localStorage.getItem('jjs_token'); }catch(e){return null;} }
    function decodeToken(tok){ if(!tok) return null; try{ const parts = tok.split('.'); if(parts.length<2) return null; const payload = parts[1]; const json = JSON.parse(atob(payload.replace(/-/g,'+').replace(/_/g,'/'))); return json; }catch(e){return null;} }
    function getCurrentUser(){
      const tok = getToken();
      const p = decodeToken(tok);
      if(!p || !p.username) return null;
      const role = inferRoleFromState(p.username) || inferRoleFromPayload(p) || 'member';
      return { username: p.username, id: p.id, role };
    }

    function canDeleteLibrary(user, lib){
      if(!user || !lib) return false;
      if(isStaffUser(user)) return true;
      return isLibraryAuthor(user, lib);
    }

    function updateRestrictedActionsUI(){
      const canUse = hasFullAccountAccess();
      const dmToInput = document.getElementById('dmTo');
      const openDmBtn = document.getElementById('openDm');
      const createBtn = document.getElementById('createEntry');
      const avatarFileInput = document.getElementById('avatarFile');
      const saveBioBtn = document.getElementById('saveBio');
      const saveAvatarBtn = document.getElementById('saveAvatar');
      const refreshProfileBtn = document.getElementById('refreshProfile');
      const addProfileLinkBtn = document.getElementById('addProfileLink');
      const saveProfileLinksBtn = document.getElementById('saveProfileLinks');
      const clearProfileLinksBtn = document.getElementById('clearProfileLinks');

      if(dmToInput){
        dmToInput.disabled = !canUse;
        dmToInput.title = canUse ? '' : 'Sign in to use DMs';
      }
      if(openDmBtn){
        openDmBtn.disabled = !canUse;
        openDmBtn.title = canUse ? '' : 'Sign in to use DMs';
      }
      if(createBtn){
        createBtn.disabled = !canUse;
        createBtn.title = canUse ? '' : 'Sign in to create posts';
      }
      if(avatarFileInput){
        avatarFileInput.disabled = !canUse;
        avatarFileInput.title = canUse ? '' : 'Sign in to edit profile';
      }
      [saveBioBtn, saveAvatarBtn, refreshProfileBtn, addProfileLinkBtn, saveProfileLinksBtn, clearProfileLinksBtn].forEach(btn=>{
        if(!btn) return;
        btn.disabled = !canUse;
        btn.title = canUse ? '' : 'Sign in to edit profile';
      });
    }

    function updateUserLabel(){
      const lbl = document.getElementById('userLabel');
      if(!lbl) return;
      const u = getCurrentUser();
      const sessionUser = getSessionUser();
      if(u){
        const roleLabel = u.role && u.role !== 'member' ? ` (${u.role})` : '';
        lbl.textContent = `Signed in: ${u.username}${roleLabel}`;
      }else if(sessionUser){
        lbl.textContent = 'Browsing as Guest';
      }else{
        lbl.textContent = 'Not signed in';
      }
      const homeBtn = document.getElementById('openHomeAuth');
      if(homeBtn){
        homeBtn.style.display = u ? 'none' : 'inline-flex';
        homeBtn.textContent = sessionUser ? 'Sign in for full access' : 'Sign in on Home';
      }
      updateRestrictedActionsUI();
    }

    updateUserLabel();
    updateStaffConsoleVisibility();
    const openHomeAuthBtn = document.getElementById('openHomeAuth');
    if(openHomeAuthBtn){
      openHomeAuthBtn.addEventListener('click', ()=>{
        location.href = 'index.html';
      });
    }
    window.addEventListener('storage', (event)=>{
      if(event && (event.key === 'jjs_token' || event.key === GUEST_KEY)){
        updateUserLabel();
        updateAddModeratorButton();
        updateStaffConsoleVisibility();
        refreshListView({ refilter:true });
      }
    });

    // --- Tag picker ---
    const PRESET_TAGS = ['Beginner moveset','Intermediate moveset','Advanced moveset','Custom','JJK','Dragonball','Sololeveling','Video-game','OP'];
    function renderTagPicker(){
      const wrap = document.getElementById('tagPicker'); if(!wrap) return;
      wrap.innerHTML = '';
      PRESET_TAGS.forEach(t=>{
        const id = 'tag_' + t.replace(/[^a-z0-9]/gi,'_');
        const label = document.createElement('label'); label.style.display='inline-flex'; label.style.alignItems='center'; label.style.gap='6px';
        const cb = document.createElement('input'); cb.type='checkbox'; cb.value = t; cb.id = id;
        const span = document.createElement('span'); span.textContent = t; span.className='small';
        label.appendChild(cb); label.appendChild(span); wrap.appendChild(label);
      });
    }

    function getSelectedTags(){
      const wrap = document.getElementById('tagPicker'); if(!wrap) return [];
      const checks = Array.from(wrap.querySelectorAll('input[type="checkbox"]'));
      return checks.filter(i=>i.checked).map(i=>i.value);
    }

    function cloneTagPickerElement(){
      const source = document.getElementById('tagPicker');
      if(!source){
        const fallback = document.createElement('div');
        fallback.className = 'tagPicker';
        return fallback;
      }
      const clone = source.cloneNode(true);
      clone.removeAttribute('id');
      return clone;
    }

    function applySelectedTagsToPicker(pickerEl, selectedTags){
      if(!pickerEl) return;
      const selected = new Set((selectedTags || []).map(tag=> (tag || '').toLowerCase()));
      const checkboxes = pickerEl.querySelectorAll('input[type="checkbox"]');
      checkboxes.forEach(cb=>{
        cb.checked = selected.has((cb.value || '').toLowerCase());
      });
    }

    function collectTagsFromPicker(pickerEl){
      if(!pickerEl) return [];
      const checkboxes = Array.from(pickerEl.querySelectorAll('input[type="checkbox"]'));
      return checkboxes.filter(cb=>cb.checked).map(cb=>cb.value);
    }

    function openLibraryModal(options = {}){
      const { mode = 'create', lib = null, onSubmit } = options;
      if(typeof onSubmit !== 'function') throw new Error('onSubmit callback required');
      const isEdit = mode === 'edit';
      const heading = isEdit ? 'Edit Library' : 'Create New Library';
      const submitLabel = isEdit ? 'Save changes' : 'Post';
      const savingLabel = isEdit ? 'Saving...' : 'Posting...';
      const existing = document.getElementById('libraryModal');
      if(existing) existing.remove();
      const modal = document.createElement('div');
      modal.id = 'libraryModal';
      Object.assign(modal.style, {
        position: 'fixed',
        left: '0',
        top: '0',
        width: '100vw',
        height: '100vh',
        background: 'rgba(0,0,0,0.55)',
        zIndex: '9999',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center'
      });
      modal.innerHTML = `<div style="background:var(--card);padding:24px 18px 18px 18px;min-width:340px;max-width:98vw;max-height:90vh;overflow:auto;border-radius:12px;box-shadow:0 8px 32px #000a;position:relative;">
        <button id="closeLibraryModal" style="position:absolute;top:10px;right:10px;" class="ghost" type="button">Close</button>
        <h3 style="margin-top:0">${heading}</h3>
        <form id="libraryForm">
          <div style="margin-bottom:10px"><input id="libraryTitle" placeholder="Title" style="width:100%;padding:8px;border-radius:6px;border:1px solid #333" maxlength="60" required></div>
          <div style="margin-bottom:10px"><textarea id="libraryDesc" placeholder="Description (max 250 chars)" maxlength="250" style="width:100%;min-height:48px;padding:8px;border-radius:6px;border:1px solid #333" required></textarea><div class="smallMuted" id="libraryDescCount"></div></div>
          <div style="margin-bottom:10px"><input id="libraryCredit" placeholder="Credit / original link (optional)" style="width:100%;padding:8px;border-radius:6px;border:1px solid #333"></div>
          <div style="margin-bottom:10px"><textarea id="libraryCode" placeholder="Paste code here" style="width:100%;min-height:80px;padding:8px;border-radius:6px;border:1px solid #333" required></textarea></div>
          <div style="margin-bottom:12px">
            <label class="smallMuted" style="display:block;margin-bottom:4px">Attach a gameplay video (optional, max 60s, under ${formatBytes(VIDEO_MAX_SIZE_BYTES)})</label>
            <input id="libraryVideoInput" type="file" accept="video/mp4,video/webm,video/ogg" style="width:100%;padding:8px;border-radius:6px;border:1px solid #333">
            <div style="display:flex;gap:8px;align-items:center;margin-top:6px">
              <div class="smallMuted" id="libraryVideoStatus"></div>
              <button type="button" class="ghost" id="libraryVideoRemove" style="display:none">Remove video</button>
            </div>
          </div>
          <div style="margin-bottom:10px;display:flex;align-items:center;justify-content:space-between;gap:12px">
            <span class="smallMuted">Visibility</span>
            <div id="libraryVisibilitySegment" style="display:inline-flex;border:1px solid rgba(255,255,255,0.18);border-radius:999px;padding:2px;gap:4px;background:rgba(255,255,255,0.03)">
              <button type="button" id="libraryVisibilityPublic" class="ghost" data-visibility="public" style="padding:5px 10px;border-radius:999px;font-size:12px">ðŸŒ Public</button>
              <button type="button" id="libraryVisibilityPrivate" class="ghost" data-visibility="private" style="padding:5px 10px;border-radius:999px;font-size:12px">ðŸ”’ Private</button>
            </div>
          </div>
          <div id="libraryWhitelistSection" style="margin-bottom:12px;max-height:0;opacity:0;overflow:hidden;transform:translateY(-6px);transition:max-height .24s ease,opacity .24s ease,transform .24s ease">
            <label class="smallMuted" style="display:block;margin-bottom:6px">Whitelisted users (private only)</label>
            <div style="display:flex;gap:8px;align-items:center;margin-bottom:6px">
              <input id="libraryWhitelistInput" placeholder="username" style="flex:1;min-width:140px;padding:7px 8px;border-radius:6px;border:1px solid #333">
              <button type="button" class="ghost" id="libraryWhitelistAdd">Add</button>
            </div>
            <div class="smallMuted" style="margin-bottom:6px">Only you, whitelisted users, and staff can view this post.</div>
            <div id="libraryWhitelistList" style="display:flex;flex-wrap:wrap;gap:6px"></div>
          </div>
          <div style="margin-bottom:10px"><span class="smallMuted">Tags: (select below before posting)</span></div>
          <div id="libraryModalTagContainer" style="display:flex;gap:8px;align-items:center;margin-bottom:10px;flex-wrap:wrap"></div>
          <button type="submit" class="ghost" id="librarySubmitBtn">${submitLabel}</button>
        </form>
      </div>`;
      document.body.appendChild(modal);
      const closeBtn = modal.querySelector('#closeLibraryModal');
      if(closeBtn) closeBtn.addEventListener('click', ()=>modal.remove());
      const form = modal.querySelector('#libraryForm');
      const titleInput = form.querySelector('#libraryTitle');
      const descInput = form.querySelector('#libraryDesc');
      const descCount = form.querySelector('#libraryDescCount');
      const creditInput = form.querySelector('#libraryCredit');
      const codeInput = form.querySelector('#libraryCode');
      const submitBtn = form.querySelector('#librarySubmitBtn');
      const visibilityPublicBtn = form.querySelector('#libraryVisibilityPublic');
      const visibilityPrivateBtn = form.querySelector('#libraryVisibilityPrivate');
      const whitelistSection = form.querySelector('#libraryWhitelistSection');
      const whitelistInput = form.querySelector('#libraryWhitelistInput');
      const whitelistAddBtn = form.querySelector('#libraryWhitelistAdd');
      const whitelistList = form.querySelector('#libraryWhitelistList');
      const tagContainer = form.querySelector('#libraryModalTagContainer');
      const initial = {
        title: lib && typeof lib.title === 'string' ? lib.title : '',
        description: lib && typeof lib.description === 'string' ? lib.description : '',
        credit: lib && typeof lib.credit === 'string' ? lib.credit : '',
        code: lib && typeof lib.code === 'string' ? lib.code : '',
        tags: Array.isArray(lib && lib.tags) ? lib.tags.slice() : [],
        visibility: normalizeVisibility(lib && lib.visibility),
        whitelist: getLibraryWhitelist(lib)
      };
      titleInput.value = initial.title;
      descInput.value = initial.description;
      if(descCount) descCount.textContent = initial.description ? `${initial.description.length}/250` : '';
      descInput.addEventListener('input', ()=>{
        descCount.textContent = descInput.value.length ? descInput.value.length + '/250' : '';
      });
      creditInput.value = initial.credit;
      codeInput.value = initial.code;
      const modalTagPicker = cloneTagPickerElement();
      if(tagContainer){
        tagContainer.innerHTML = '';
        tagContainer.appendChild(modalTagPicker);
      }
      applySelectedTagsToPicker(modalTagPicker, initial.tags);
      let currentVisibility = initial.visibility;
      const modalUser = getCurrentUser();
      const modalAuthor = (lib && lib.author) || (modalUser && modalUser.username) || '';
      let currentWhitelist = normalizeWhitelistUsers(initial.whitelist, modalAuthor);

      const renderWhitelistList = ()=>{
        if(!whitelistList) return;
        whitelistList.innerHTML = '';
        if(!currentWhitelist.length){
          const empty = document.createElement('span');
          empty.className = 'smallMuted';
          empty.textContent = 'No users added yet.';
          whitelistList.appendChild(empty);
          return;
        }
        currentWhitelist.forEach(name=>{
          const chip = document.createElement('span');
          chip.style.display = 'inline-flex';
          chip.style.alignItems = 'center';
          chip.style.gap = '6px';
          chip.style.padding = '4px 8px';
          chip.style.borderRadius = '999px';
          chip.style.border = '1px solid rgba(255,255,255,0.18)';
          chip.style.background = 'rgba(255,255,255,0.03)';
          const label = document.createElement('span');
          label.className = 'small';
          label.textContent = name;
          const removeBtn = document.createElement('button');
          removeBtn.type = 'button';
          removeBtn.className = 'ghost';
          removeBtn.style.padding = '0 6px';
          removeBtn.style.lineHeight = '1.2';
          removeBtn.textContent = 'Ã—';
          removeBtn.title = `Remove ${name}`;
          removeBtn.addEventListener('click', ()=>{
            currentWhitelist = currentWhitelist.filter(item=> normalizeUsername(item) !== normalizeUsername(name));
            renderWhitelistList();
          });
          chip.appendChild(label);
          chip.appendChild(removeBtn);
          whitelistList.appendChild(chip);
        });
      };

      const updateWhitelistVisibility = ()=>{
        if(!whitelistSection) return;
        const isPrivate = currentVisibility === VISIBILITY.PRIVATE;
        whitelistSection.style.maxHeight = isPrivate ? '180px' : '0';
        whitelistSection.style.opacity = isPrivate ? '1' : '0';
        whitelistSection.style.transform = isPrivate ? 'translateY(0)' : 'translateY(-6px)';
        if(whitelistInput) whitelistInput.disabled = !isPrivate;
        if(whitelistAddBtn) whitelistAddBtn.disabled = !isPrivate;
      };

      const setSegmentActive = ()=>{
        const isPrivate = currentVisibility === VISIBILITY.PRIVATE;
        if(visibilityPublicBtn){
          visibilityPublicBtn.dataset.active = isPrivate ? 'false' : 'true';
          visibilityPublicBtn.style.background = isPrivate ? 'transparent' : 'rgba(126,249,194,0.2)';
          visibilityPublicBtn.style.borderColor = isPrivate ? 'transparent' : 'rgba(126,249,194,0.35)';
        }
        if(visibilityPrivateBtn){
          visibilityPrivateBtn.dataset.active = isPrivate ? 'true' : 'false';
          visibilityPrivateBtn.style.background = isPrivate ? 'rgba(123,91,255,0.24)' : 'transparent';
          visibilityPrivateBtn.style.borderColor = isPrivate ? 'rgba(123,91,255,0.4)' : 'transparent';
        }
      };

      const applyVisibilityState = ()=>{
        setSegmentActive();
        updateWhitelistVisibility();
      };

      if(visibilityPublicBtn){
        visibilityPublicBtn.addEventListener('click', ()=>{
          currentVisibility = VISIBILITY.PUBLIC;
          applyVisibilityState();
        });
      }
      if(visibilityPrivateBtn){
        visibilityPrivateBtn.addEventListener('click', ()=>{
          currentVisibility = VISIBILITY.PRIVATE;
          applyVisibilityState();
        });
      }

      const addWhitelistUser = ()=>{
        if(!whitelistInput) return;
        const raw = whitelistInput.value.trim();
        if(!raw) return;
        const normalized = normalizeUsername(raw);
        if(!normalized) return;
        if(normalizeUsername(modalAuthor) === normalized){
          whitelistInput.value = '';
          return;
        }
        if(currentWhitelist.some(name=> normalizeUsername(name) === normalized)){
          whitelistInput.value = '';
          return;
        }
        currentWhitelist.push(raw);
        currentWhitelist = normalizeWhitelistUsers(currentWhitelist, modalAuthor);
        whitelistInput.value = '';
        renderWhitelistList();
      };

      if(whitelistAddBtn){
        whitelistAddBtn.addEventListener('click', addWhitelistUser);
      }
      if(whitelistInput){
        whitelistInput.addEventListener('keydown', (ev)=>{
          if(ev.key === 'Enter'){
            ev.preventDefault();
            addWhitelistUser();
          }
        });
      }

      renderWhitelistList();
      applyVisibilityState();
      const videoInput = form.querySelector('#libraryVideoInput');
      const videoStatus = form.querySelector('#libraryVideoStatus');
      const videoRemoveBtn = form.querySelector('#libraryVideoRemove');
      const originalVideo = lib && lib.video ? lib.video : null;
      let selectedVideo = null;
      let videoRemoved = false;
      const describeVideo = (video)=>{
        if(!video) return '';
        const parts = [];
        if(Number.isFinite(video.duration)) parts.push(`Duration ${formatVideoDuration(video.duration)}`);
        if(typeof video.size === 'number') parts.push(formatBytes(video.size));
        if(video.name) parts.push(censorBadWords(video.name));
        return parts.join(' â€¢ ');
      };
      const updateVideoStatus = ()=>{
        if(!videoStatus) return;
        if(videoRemoved){
          videoStatus.textContent = 'Video will be removed when you save.';
          if(videoRemoveBtn){
            videoRemoveBtn.style.display = originalVideo ? 'inline-flex' : 'none';
            videoRemoveBtn.textContent = 'Undo remove';
          }
          return;
        }
        if(selectedVideo){
          videoStatus.textContent = describeVideo(selectedVideo) || 'Ready to attach.';
          if(videoRemoveBtn){
            videoRemoveBtn.style.display = 'inline-flex';
            videoRemoveBtn.textContent = originalVideo ? 'Remove video' : 'Clear video';
          }
          return;
        }
        if(originalVideo){
          videoStatus.textContent = describeVideo(originalVideo) || 'Current video attached.';
          if(videoRemoveBtn){
            videoRemoveBtn.style.display = 'inline-flex';
            videoRemoveBtn.textContent = 'Remove video';
          }
          return;
        }
        videoStatus.textContent = 'No video attached.';
        if(videoRemoveBtn){
          videoRemoveBtn.style.display = 'none';
        }
      };
      updateVideoStatus();
      if(videoInput){
        videoInput.addEventListener('change', async ()=>{
          if(!videoInput.files || !videoInput.files[0]){
            selectedVideo = null;
            if(!originalVideo) videoRemoved = false;
            updateVideoStatus();
            return;
          }
          if(videoStatus) videoStatus.textContent = 'Processing video...';
          try{
            selectedVideo = await processVideoFile(videoInput.files[0]);
            videoRemoved = false;
            updateVideoStatus();
          }catch(err){
            alert(err && err.message ? err.message : 'Video processing failed');
            videoInput.value = '';
            selectedVideo = null;
            if(!originalVideo) videoRemoved = false;
            updateVideoStatus();
          }
        });
      }
      if(videoRemoveBtn){
        videoRemoveBtn.addEventListener('click', ()=>{
          if(videoRemoved){
            videoRemoved = false;
            updateVideoStatus();
            return;
          }
          if(selectedVideo){
            selectedVideo = null;
            if(videoInput) videoInput.value = '';
            if(!originalVideo) videoRemoved = false;
            updateVideoStatus();
            return;
          }
          if(originalVideo){
            videoRemoved = true;
            if(videoInput) videoInput.value = '';
            updateVideoStatus();
          }
        });
      }
      form.addEventListener('submit', async (ev)=>{
        ev.preventDefault();
        const payload = {
          title: titleInput.value.trim(),
          description: descInput.value.trim(),
          credit: creditInput.value.trim(),
          code: codeInput.value,
          tags: collectTagsFromPicker(modalTagPicker),
          visibility: currentVisibility,
          whitelist: currentVisibility === VISIBILITY.PRIVATE ? currentWhitelist.slice() : [],
          video: selectedVideo || (videoRemoved ? null : originalVideo),
          videoRemoved: !!videoRemoved
        };
        if(submitBtn){
          submitBtn.disabled = true;
          submitBtn.textContent = savingLabel;
        }
        try{
          await onSubmit(payload);
          modal.remove();
        }catch(err){
          alert(err && err.message ? err.message : 'Failed to save post');
          if(submitBtn){
            submitBtn.disabled = false;
            submitBtn.textContent = submitLabel;
          }
        }
      });
    }

    document.getElementById('addTagBtn').addEventListener('click', ()=>{
      const v = (document.getElementById('customTag').value||'').trim();
      if(!v) return; const wrap = document.getElementById('tagPicker');
      // avoid duplicates
      const exists = Array.from(wrap.querySelectorAll('input')).some(i=>i.value.toLowerCase()===v.toLowerCase());
      if(exists){ document.getElementById('customTag').value=''; return; }
      const id = 'tag_' + v.replace(/[^a-z0-9]/gi,'_');
      const label = document.createElement('label'); label.style.display='inline-flex'; label.style.alignItems='center'; label.style.gap='6px';
      const cb = document.createElement('input'); cb.type='checkbox'; cb.value = v; cb.id = id; cb.checked = true;
      const span = document.createElement('span'); span.textContent = v; span.className='small';
      label.appendChild(cb); label.appendChild(span); wrap.appendChild(label);
      document.getElementById('customTag').value = '';
    });

    renderTagPicker();

    const addModeratorBtnEl = document.getElementById('addModeratorBtn');
    if(addModeratorBtnEl){
      addModeratorBtnEl.addEventListener('click', handleAddModeratorClick);
    }

    document.getElementById('createEntry').addEventListener('click', ()=>{
      const currentUser = getCurrentUser();
      if(!currentUser) return alert(isGuestModeActive() ? 'Guest mode cannot create posts. Sign in for full access.' : 'You must be signed in to create a library.');
      const cooldownRemaining = getUserPostCooldownRemaining(currentUser);
      if(cooldownRemaining > 0){
        return alert(`Please wait ${formatMs(cooldownRemaining)} before creating another post.`);
      }
      openLibraryModal({
        mode: 'create',
        onSubmit: async (payload)=>{
          const { title, description, credit, code, tags, visibility, whitelist, video } = payload;
          if(!title) throw new Error('Title required');
          if(!description) throw new Error('Description required');
          if(description.length > 250) throw new Error('Description too long');
          if(!code) throw new Error('Code required');
          const safeTags = (tags || []).map(tag=>censorBadWords(tag));
          const safeLib = {
            id: Date.now().toString(),
            title: censorBadWords(title),
            description: censorBadWords(description),
            author: censorBadWords(currentUser.username),
            credit,
            code,
            tags: safeTags,
            visibility,
            whitelist: normalizeVisibility(visibility) === VISIBILITY.PRIVATE ? normalizeWhitelistUsers(whitelist, currentUser.username) : [],
            createdAt: Date.now(),
            views: 0,
            pinned: false,
            reactions: {},
            comments: []
          };
          if(video){
            const attachment = buildVideoAttachment(video);
            if(attachment) safeLib.video = attachment;
          }
          const lib = sanitizeLibraryContent(safeLib);
          libs.push(lib);
          setUserPostCooldown(currentUser);
          getUserJoinDate(currentUser.username);
          notifyFollowersOfNewPost(lib);
          refreshListView({ refilter:true });
          try{
            const persistResult = await persistLibraryFile(lib, { downloadOnMissingConfig: true, downloadOnFailure: true });
            if(persistResult && persistResult.method === 'github'){
              alert('Saved to repository path: ' + (GITHUB.path ? GITHUB.path + '/' : '') + persistResult.filename);
            }else if(persistResult && persistResult.method === 'download'){
              const reason = persistResult.reason && persistResult.reason.message ? persistResult.reason.message : '';
              const videoNote = lib.video ? '\nVideo attachments are large, so configure SERVERLESS_URL or GitHub to publish automatically.' : '';
              alert('Remote save unavailable â€” downloaded JSON locally for manual upload.' + (reason ? `\nReason: ${reason}` : '') + videoNote);
            }
          }catch(err){
            console.error('persistLibraryFile failed', err);
            const fallbackName = lib.__filename || `${lib.id || Date.now()}-${sanitizeFilename(lib.title || 'library')}.json`;
            downloadJSON(lib, fallbackName);
            alert('Could not save remotely. Downloaded JSON locally for manual upload.');
          }
        }
      });
    });

    // --- Sidebar / Profile / Notifications / DMs ---
    function fileToDataUrl(file){
      return new Promise((resolve, reject)=>{
        const reader = new FileReader();
        reader.onload = ()=>resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    }

    async function applyAvatarUpdate(username, url){
      if(!username || !url) return;
      const normalizedUser = normalizeUsernameKey(username);
      let social = socialCache.get(normalizedUser) || socialCache.get(username);
      if(!social){
        try{ social = JSON.parse(localStorage.getItem(getSocialStorageKey(username)) || localStorage.getItem('jjs_social_' + username) || '{}'); }
        catch(_e){ social = {}; }
      }
      social = social || {};
      social.avatar_url = url;
      await updateSocial(username, social);
      socialCache.set(normalizedUser, social);
      socialCache.set(username, social);
      try{
        localStorage.setItem(getAvatarStorageKey(username), url);
        localStorage.setItem('jjs_avatar_url', url);
      }catch(_e){}
    }

    async function saveAvatarToServer(file){
      const user = getCurrentUser();
      if(!user) throw new Error('Sign in to upload an avatar.');
      if(!file) throw new Error('No file selected.');
      if(file.size && file.size > 1024 * 1024) throw new Error('Avatar max size is 1MB.');
      const dataUrl = await fileToDataUrl(file);
      const username = user.username;
      if(SERVERLESS_URL){
        try{
          const resp = await fetch(SERVERLESS_URL + '?action=uploadAvatar', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ dataUrl, username }) });
          if(resp.ok){
            const j = await resp.json().catch(()=>null);
            const remoteUrl = (j && j.url) || (j && j.result && j.result.content && j.result.content.download_url);
            if(remoteUrl){
              await applyAvatarUpdate(username, remoteUrl);
              return { url: remoteUrl };
            }
          }
        }catch(_err){ /* fall through to local */ }
      }
      await applyAvatarUpdate(username, dataUrl);
      return { url: dataUrl, local: true };
    }

    document.getElementById('avatarFile').addEventListener('change', async (ev)=>{
      const file = ev.target.files && ev.target.files[0];
      if(!file) return;
      try{
        const result = await saveAvatarToServer(file);
        if(result && result.url){
          const avatarEl = document.getElementById('avatarImg');
          const avatarWrapper = document.getElementById('avatarWrap');
          setAvatarImage(avatarEl, { src: result.url, wrapper: avatarWrapper, stage: 'remote' });
          addNotification('Avatar updated');
          refreshListView({});
        }
      }catch(e){
        alert(e && e.message ? e.message : 'Avatar upload failed.');
      }finally{
        ev.target.value = '';
      }
    });

    function renderSidebar(){
      const u = getCurrentUser();
      const sessionUser = getSessionUser();
      document.getElementById('sideUsername').textContent = sessionUser ? sessionUser.username : 'Not signed in';
      const avatarEl = document.getElementById('avatarImg');
      const avatarWrapper = document.getElementById('avatarWrap');
      if(avatarEl){
        const avatarSource = u ? getAvatarSourceBundle(u.username) : { src: DEFAULT_AVATAR_URL, stage: 'default', fallbackSources: [] };
        setAvatarImage(avatarEl, {
          src: avatarSource.src || DEFAULT_AVATAR_URL,
          wrapper: avatarWrapper,
          stage: avatarSource.stage,
          fallbackSources: avatarSource.fallbackSources
        });
      }
      const followSummaryEl = document.getElementById('sideFollowSummary');
      if(followSummaryEl){
        if(!u && isGuestModeActive()){
          followSummaryEl.textContent = 'Guest mode: sign in to follow creators';
        }else if(!u){
          followSummaryEl.textContent = 'Sign in to follow creators';
        }else{
          followSummaryEl.textContent = 'Loading followers...';
          const viewerName = u.username;
          fetchSocial(viewerName).then(s=>{
            const active = getCurrentUser();
            if(!active || active.username !== viewerName) return;
            const followerCount = Array.isArray(s.followers) ? s.followers.length : 0;
            const followingCount = Array.isArray(s.following) ? s.following.length : 0;
            const followerLabel = followerCount === 1 ? 'follower' : 'followers';
            followSummaryEl.textContent = `${followerCount} ${followerLabel} â€¢ ${followingCount} following`;
          }).catch(()=>{ followSummaryEl.textContent = 'Followers unavailable'; });
        }
      }
      // my libs
      const myLibsWrap = document.getElementById('myLibs'); myLibsWrap.innerHTML = '';
      const author = u ? u.username : null;
      const my = author ? libs.filter(l=>l.author===author) : [];
      document.getElementById('myLibCount').textContent = my.length;
      my.slice(0,10).forEach(l=>{ const d = document.createElement('div'); d.className='libItem'; d.textContent = censorBadWords(l.title || ''); myLibsWrap.appendChild(d); });
      renderFriendRequests(); renderNotifications(); renderDMList();
      updateRestrictedActionsUI();
      updateStaffConsoleVisibility();
      if(typeof window.__hydrateProfileEditor === 'function'){
        window.__hydrateProfileEditor();
      }
    }

    // Profile edit UI in sidebar
    (function addProfileEditor(){
      const wrap = document.getElementById('sidebar');
      if(!wrap) return;
      const div = document.createElement('div'); div.className='sideSection';
      div.innerHTML = `<div class="smallMuted">Edit Profile</div>
        <div style="margin-top:6px">
          <textarea id="profileBio" placeholder="Bio" style="width:100%;min-height:60px;padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.04)"></textarea>
          <div style="display:flex;gap:6px;margin-top:6px">
            <button id="saveBio" class="ghost">Save Bio</button>
            <button id="saveAvatar" class="ghost">Save Avatar</button>
            <button id="refreshProfile" class="ghost">Refresh</button>
          </div>
          <div style="margin-top:12px">
            <div class="smallMuted">Profile links</div>
            <div id="profileLinksList" class="profileLinksList smallMuted"></div>
            <div style="display:flex;gap:6px;margin-top:6px;flex-wrap:wrap">
              <input id="profileLinkLabel" placeholder="Label" style="flex:1;padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.04)" />
              <input id="profileLinkUrl" placeholder="https://example.com" style="flex:1;padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.04)" />
              <button id="addProfileLink" type="button" class="ghost">Add</button>
            </div>
            <div style="display:flex;gap:6px;margin-top:6px">
              <button id="saveProfileLinks" class="ghost" style="flex:1">Save Links</button>
              <button id="clearProfileLinks" class="ghost" style="flex:1">Clear All</button>
            </div>
          </div>
          <div id="staffConsoleBlock" style="margin-top:10px;display:none">
            <div class="smallMuted">Owner Console (?cmds)</div>
            <form id="staffConsoleForm" style="display:flex;gap:6px;margin-top:6px">
              <input id="staffConsoleInput" placeholder="?cmds or giverole user moderator" style="flex:1;padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.04)" />
              <button type="submit" class="ghost">Run</button>
            </form>
            <div class="smallMuted" id="staffConsoleStatus"></div>
          </div>
          <button id="openOwnerPanelBtn" class="ghost ownerPanelShortcut" type="button" style="display:none">Open Owner Panel</button>
        </div>`;
      wrap.appendChild(div);
      const bioInput = document.getElementById('profileBio');
      const linkListEl = document.getElementById('profileLinksList');
      const linkLabelInput = document.getElementById('profileLinkLabel');
      const linkUrlInput = document.getElementById('profileLinkUrl');
      const addLinkBtn = document.getElementById('addProfileLink');
      const saveLinksBtn = document.getElementById('saveProfileLinks');
      const clearLinksBtn = document.getElementById('clearProfileLinks');
      let pendingProfileLinks = [];

      function renderProfileLinksEditor(){
        if(!linkListEl) return;
        if(!pendingProfileLinks.length){
          linkListEl.innerHTML = '<div class="smallMuted">No links added yet</div>';
          return;
        }
        linkListEl.innerHTML = '';
        pendingProfileLinks.forEach((link, idx)=>{
          const row = document.createElement('div');
          row.className = 'profileLinkRow';
          const anchor = document.createElement('a');
          anchor.href = link.url;
          anchor.target = '_blank';
          anchor.rel = 'noopener noreferrer';
          anchor.textContent = link.label;
          anchor.className = 'link';
          anchor.style.flex = '1';
          row.appendChild(anchor);
          const removeBtn = document.createElement('button');
          removeBtn.type = 'button';
          removeBtn.className = 'ghost';
          removeBtn.textContent = 'Remove';
          removeBtn.addEventListener('click', ()=>{
            pendingProfileLinks.splice(idx, 1);
            renderProfileLinksEditor();
          });
          row.appendChild(removeBtn);
          linkListEl.appendChild(row);
        });
      }

      function setProfileLinks(list){
        pendingProfileLinks = sanitizeProfileLinks(list || []);
        renderProfileLinksEditor();
      }

      async function hydrateProfileEditor(){
        const me = getCurrentUser();
        if(!me){
          if(bioInput) bioInput.value = '';
          setProfileLinks([]);
          return;
        }
        const social = await fetchSocial(me.username) || {};
        if(bioInput) bioInput.value = social.bio || '';
        setProfileLinks(Array.isArray(social.links) ? social.links : []);
      }

      if(addLinkBtn && linkLabelInput && linkUrlInput){
        addLinkBtn.addEventListener('click', ()=>{
          const raw = { label: linkLabelInput.value, url: linkUrlInput.value };
          const normalized = normalizeProfileLinkEntry(raw);
          if(!normalized) return alert('Enter a valid URL (example: https://example.com)');
          pendingProfileLinks.push(normalized);
          pendingProfileLinks = sanitizeProfileLinks(pendingProfileLinks);
          renderProfileLinksEditor();
          linkLabelInput.value = '';
          linkUrlInput.value = '';
        });
      }

      if(clearLinksBtn){
        clearLinksBtn.addEventListener('click', ()=>{
          pendingProfileLinks = [];
          renderProfileLinksEditor();
        });
      }

      if(saveLinksBtn){
        saveLinksBtn.addEventListener('click', async ()=>{
          const me = getCurrentUser(); if(!me) return alert('Sign in to edit profile');
          const social = await fetchSocial(me.username) || {};
          social.links = sanitizeProfileLinks(pendingProfileLinks);
          await updateSocial(me.username, social);
          addNotification('Profile links saved');
        });
      }

      document.getElementById('saveBio').addEventListener('click', async ()=>{
        const me = getCurrentUser(); if(!me) return alert('Sign in to edit profile');
        const bio = (bioInput && bioInput.value ? bioInput.value : '').trim();
        const social = await fetchSocial(me.username) || {};
        social.bio = bio;
        await updateSocial(me.username, social);
        addNotification('Bio saved');
        refreshListView({});
      });
      document.getElementById('saveAvatar').addEventListener('click', ()=>{
        const me = getCurrentUser(); if(!me) return alert('Sign in to edit profile');
        const picker = document.createElement('input');
        picker.type = 'file';
        picker.accept = 'image/*';
        picker.onchange = async ()=>{
          const file = picker.files && picker.files[0];
          if(!file) return;
          try{
            const result = await saveAvatarToServer(file);
            if(result && result.url){
              const avatarEl = document.getElementById('avatarImg');
              const avatarWrapper = document.getElementById('avatarWrap');
              setAvatarImage(avatarEl, { src: result.url, wrapper: avatarWrapper, stage: 'remote' });
              addNotification('Avatar saved');
              refreshListView({});
            }
          }catch(e){
            alert(e && e.message ? e.message : 'Failed to upload avatar');
          }
        };
        picker.click();
      });
      document.getElementById('refreshProfile').addEventListener('click', ()=>{
        const me = getCurrentUser(); if(!me) return alert('Sign in');
        hydrateProfileEditor();
      });
      const staffForm = document.getElementById('staffConsoleForm');
      if(staffForm){
        staffForm.addEventListener('submit', handleStaffConsoleSubmit);
      }
      const ownerPanelBtn = document.getElementById('openOwnerPanelBtn');
      if(ownerPanelBtn){
        ownerPanelBtn.addEventListener('click', ()=>{
          location.hash = 'owner-panel';
          openOwnerPanel();
        });
      }
      updateStaffConsoleVisibility();
      window.__hydrateProfileEditor = hydrateProfileEditor;
      hydrateProfileEditor();
    })();

    // --- Social helpers (friend requests, blocking, profiles) ---
    function syncSocialToHomepageProfile(username, social){
      const user = getCurrentUser();
      const target = (username || '').toLowerCase();
      const viewer = user && user.username ? user.username.toLowerCase() : '';
      if(!target || !viewer || target !== viewer || !social || typeof social !== 'object') return;
      try{
        const prev = JSON.parse(localStorage.getItem('jjs_profile_v2') || '{}') || {};
        const next = Object.assign({}, prev, {
          username,
          pronouns: String(social.pronouns || prev.pronouns || '').trim(),
          bio: String(social.bio || prev.bio || '').trim(),
          avatarUrl: String(social.avatar_url || prev.avatarUrl || '').trim(),
          bannerUrl: String(social.banner_url || prev.bannerUrl || '').trim(),
          socialLinks: sanitizeProfileLinks(Array.isArray(social.links) ? social.links : (prev.socialLinks || []))
            .slice(0, 5)
            .map(link=>({ label: String(link.label || 'Link').slice(0, 40), url: String(link.url || '').trim() }))
        });
        localStorage.setItem('jjs_profile_v2', JSON.stringify(next));
      }catch(_e){}
    }

    function mergeHomepageProfileIntoSocial(username, social){
      const user = getCurrentUser();
      const target = (username || '').toLowerCase();
      const viewer = user && user.username ? user.username.toLowerCase() : '';
      if(!target || !viewer || target !== viewer) return social || {};
      let homeProfile = null;
      try{ homeProfile = JSON.parse(localStorage.getItem('jjs_profile_v2') || '{}'); }catch(_e){ homeProfile = null; }
      if(!homeProfile || typeof homeProfile !== 'object') return social || {};
      return Object.assign({}, social || {});
    }

    async function fetchSocial(username){
      if(!username) return {};
      const candidates = getUsernameLookupVariants(username);
      if(!candidates.length) return {};

      function hasMeaningfulSocial(value){
        if(!value || typeof value !== 'object') return false;
        if(typeof value.avatar_url === 'string' && value.avatar_url.trim()) return true;
        if(typeof value.bio === 'string' && value.bio.trim()) return true;
        if(typeof value.pronouns === 'string' && value.pronouns.trim()) return true;
        if(Array.isArray(value.links) && value.links.length) return true;
        if(Array.isArray(value.socialLinks) && value.socialLinks.length) return true;
        return Object.keys(value).length > 0;
      }

      for(const candidate of candidates){
        const normalizedCandidate = normalizeUsernameKey(candidate);
        if(socialCache.has(normalizedCandidate)){
          const cached = socialCache.get(normalizedCandidate);
          if(hasMeaningfulSocial(cached)) return cached;
        }
        if(socialCache.has(candidate)){
          const cached = socialCache.get(candidate);
          if(hasMeaningfulSocial(cached)) return cached;
        }
      }

      for(const endpoint of saveEndpointCandidates()){
        for(const candidate of candidates){
          try{
            const resp = await fetch(endpoint + '?action=getSocial&username=' + encodeURIComponent(candidate), { cache:'no-store' });
            if(!resp.ok) continue;
            const j = await resp.json().catch(()=>null);
            if(!j || !j.social) continue;
            const mergedSocial = mergeHomepageProfileIntoSocial(username, j.social);
            if(!hasMeaningfulSocial(mergedSocial)) continue;
            for(const keyName of candidates){
              const key = getSocialStorageKey(keyName);
              const legacyKey = 'jjs_social_' + keyName;
              try{
                localStorage.setItem(key, JSON.stringify(mergedSocial));
                if(legacyKey !== key) localStorage.setItem(legacyKey, JSON.stringify(mergedSocial));
              }catch(_e){}
              socialCache.set(normalizeUsernameKey(keyName), mergedSocial);
              socialCache.set(keyName, mergedSocial);
            }
            syncSocialToHomepageProfile(username, mergedSocial);
            return mergedSocial;
          }catch(_err){}
        }
      }

      for(const candidate of candidates){
        const key = getSocialStorageKey(candidate);
        const legacyKey = 'jjs_social_' + candidate;
        try{
          const cached = JSON.parse(localStorage.getItem(key) || localStorage.getItem(legacyKey) || '{}');
          const mergedCached = mergeHomepageProfileIntoSocial(username, cached);
          if(!hasMeaningfulSocial(mergedCached)) continue;
          socialCache.set(normalizeUsernameKey(candidate), mergedCached);
          socialCache.set(candidate, mergedCached);
          syncSocialToHomepageProfile(username, mergedCached);
          return mergedCached;
        }catch(_e){}
      }

      return {};
    }

    async function updateSocial(username, social){
      if(!username || !social) return null;
      const normalizedUser = normalizeUsernameKey(username);
      const key = getSocialStorageKey(username);
      const legacyKey = 'jjs_social_' + username;
      try{
        localStorage.setItem(key, JSON.stringify(social));
        if(legacyKey !== key) localStorage.setItem(legacyKey, JSON.stringify(social));
      }catch(_e){}
      socialCache.set(normalizedUser, social);
      socialCache.set(username, social);
      syncSocialToHomepageProfile(username, social);
      for(const endpoint of saveEndpointCandidates()){
        try{
          const resp = await fetch(endpoint + '?action=updateSocial', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ username, social }) });
          if(resp.ok) return await resp.json();
        }catch(_err){}
      }
      return null;
    }

    function normalizeUserList(list){
      if(!Array.isArray(list)) return [];
      const seen = new Set();
      const result = [];
      list.forEach(name=>{
        const trimmed = (name || '').toString().trim();
        if(!trimmed) return;
        const lower = trimmed.toLowerCase();
        if(seen.has(lower)) return;
        seen.add(lower);
        result.push(trimmed);
      });
      return result;
    }

    function removeUserFromList(list, username){
      if(!Array.isArray(list) || !username) return Array.isArray(list) ? list.slice() : [];
      const lower = username.toLowerCase();
      return list.filter(name => (name || '').toLowerCase() !== lower);
    }

    function userIsInList(list, username){
      if(!Array.isArray(list) || !username) return false;
      const lower = username.toLowerCase();
      return list.some(name => (name || '').toLowerCase() === lower);
    }

    function getFollowerUsernames(username){
      if(!username) return [];
      const normalizedUser = normalizeUsernameKey(username);
      const cached = socialCache.get(normalizedUser) || socialCache.get(username);
      if(cached && Array.isArray(cached.followers)){
        return normalizeUserList(cached.followers);
      }
      try{
        const stored = JSON.parse(localStorage.getItem(getSocialStorageKey(username)) || localStorage.getItem('jjs_social_' + username) || '{}');
        return normalizeUserList(Array.isArray(stored.followers) ? stored.followers : []);
      }catch(_e){
        return [];
      }
    }

    async function toggleFollowUser(username){
      const viewer = getCurrentUser();
      if(!viewer) return alert('Sign in to follow users');
      if(!username || viewer.username === username) return alert('You cannot follow yourself.');
      const [mySocialRaw, targetSocialRaw] = await Promise.all([fetchSocial(viewer.username), fetchSocial(username)]);
      const mySocial = mySocialRaw || {};
      const targetSocial = targetSocialRaw || {};
      if(userIsInList(targetSocial.blocked, viewer.username)) return alert('You cannot follow this user.');
      if(userIsInList(mySocial.blocked, username)) return alert('Unblock this user first.');
      const targetFollowers = normalizeUserList(targetSocial.followers || []);
      const myFollowing = normalizeUserList(mySocial.following || []);
      const isFollowing = userIsInList(targetFollowers, viewer.username);
      if(isFollowing){
        targetSocial.followers = removeUserFromList(targetFollowers, viewer.username);
        mySocial.following = removeUserFromList(myFollowing, username);
        await updateSocial(username, targetSocial);
        await updateSocial(viewer.username, mySocial);
        addNotification('Unfollowed ' + username);
      }else{
        targetSocial.followers = normalizeUserList([...targetFollowers, viewer.username]);
        mySocial.following = normalizeUserList([...myFollowing, username]);
        await updateSocial(username, targetSocial);
        await updateSocial(viewer.username, mySocial);
        addNotification('You are now following ' + username);
      }
      renderSidebar();
      openProfile(username);
    }

    function notifyFollowersOfNewPost(lib){
      if(!lib || !lib.author) return;
      if(normalizeVisibility(lib.visibility) === VISIBILITY.PRIVATE) return;
      const followers = normalizeUserList(getFollowerUsernames(lib.author));
      if(!followers.length) return;
      const safeTitle = censorBadWords(lib.title || 'a new library');
      const truncatedTitle = safeTitle.length > 80 ? safeTitle.slice(0,77) + '...' : safeTitle;
      const message = `${lib.author} posted "${truncatedTitle}"`;
      followers.forEach(follower=>{
        if(!follower || follower.toLowerCase() === lib.author.toLowerCase()) return;
        addNotification(message, { targetUser: follower });
      });
    }

    async function sendFriendRequest(to){
      const me = getCurrentUser(); if(!me) return alert('Sign in to add friends');
      const from = me.username; if(from === to) return;
      const mySocial = await fetchSocial(from) || {};
      const theirSocial = await fetchSocial(to) || {};
      if((theirSocial.blocked||[]).includes(from)) return alert('User has blocked you.');
      if((mySocial.blocked||[]).includes(to)) return alert('You have blocked this user.');
      mySocial.outgoingRequests = Array.from(new Set([...(mySocial.outgoingRequests||[]), to]));
      theirSocial.incomingRequests = Array.from(new Set([...(theirSocial.incomingRequests||[]), from]));
      await updateSocial(from, mySocial);
      await updateSocial(to, theirSocial);
      addNotification('Friend request sent to ' + to);
      renderSidebar();
    }

    async function acceptFriendRequest(from){
      const me = getCurrentUser(); if(!me) return alert('Sign in');
      const meName = me.username;
      const mySocial = await fetchSocial(meName) || {};
      const theirSocial = await fetchSocial(from) || {};
      mySocial.incomingRequests = (mySocial.incomingRequests||[]).filter(x=>x!==from);
      theirSocial.outgoingRequests = (theirSocial.outgoingRequests||[]).filter(x=>x!==meName);
      mySocial.friends = Array.from(new Set([...(mySocial.friends||[]), from]));
      theirSocial.friends = Array.from(new Set([...(theirSocial.friends||[]), meName]));
      await updateSocial(meName, mySocial);
      await updateSocial(from, theirSocial);
      addNotification('You and ' + from + ' are now friends');
      renderSidebar();
    }

    async function declineFriendRequest(from){
      const me = getCurrentUser(); if(!me) return alert('Sign in');
      const meName = me.username;
      const mySocial = await fetchSocial(meName) || {};
      const theirSocial = await fetchSocial(from) || {};
      mySocial.incomingRequests = (mySocial.incomingRequests||[]).filter(x=>x!==from);
      theirSocial.outgoingRequests = (theirSocial.outgoingRequests||[]).filter(x=>x!==meName);
      await updateSocial(meName, mySocial);
      await updateSocial(from, theirSocial);
      renderSidebar();
    }

    async function blockUser(target){
      const me = getCurrentUser(); if(!me) return alert('Sign in');
      const meName = me.username; if(meName === target) return;
      const mySocial = await fetchSocial(meName) || {};
      const theirSocial = await fetchSocial(target) || {};
      mySocial.blocked = Array.from(new Set([...(mySocial.blocked||[]), target]));
      mySocial.friends = (mySocial.friends||[]).filter(x=>x!==target);
      mySocial.outgoingRequests = (mySocial.outgoingRequests||[]).filter(x=>x!==target);
      mySocial.incomingRequests = (mySocial.incomingRequests||[]).filter(x=>x!==target);
      mySocial.followers = removeUserFromList(mySocial.followers || [], target);
      mySocial.following = removeUserFromList(mySocial.following || [], target);
      theirSocial.friends = (theirSocial.friends||[]).filter(x=>x!==meName);
      theirSocial.outgoingRequests = (theirSocial.outgoingRequests||[]).filter(x=>x!==meName);
      theirSocial.incomingRequests = (theirSocial.incomingRequests||[]).filter(x=>x!==meName);
      theirSocial.followers = removeUserFromList(theirSocial.followers || [], meName);
      theirSocial.following = removeUserFromList(theirSocial.following || [], meName);
      await updateSocial(meName, mySocial);
      await updateSocial(target, theirSocial);
      addNotification('Blocked ' + target);
      renderSidebar();
    }

    async function unblockUser(target){
      const me = getCurrentUser(); if(!me) return alert('Sign in');
      const meName = me.username;
      const mySocial = await fetchSocial(meName) || {};
      mySocial.blocked = (mySocial.blocked||[]).filter(x=>x!==target);
      await updateSocial(meName, mySocial);
      addNotification('Unblocked ' + target);
      renderSidebar();
    }

    function renderFriendRequests(){
      const wrap = document.getElementById('friendRequests'); if(!wrap) return;
      wrap.innerHTML = '';
      const u = getCurrentUser(); if(!u) { wrap.innerHTML = '<div class="smallMuted">Sign in to manage friends</div>'; return; }
      fetchSocial(u.username).then(s=>{
        const inc = s.incomingRequests||[];
        if(inc.length===0) { wrap.innerHTML = '<div class="smallMuted">No incoming requests</div>'; return; }
        inc.forEach(from=>{
          const row = document.createElement('div'); row.style.display='flex'; row.style.justifyContent='space-between'; row.style.alignItems='center'; row.style.marginBottom='6px';
          const link = document.createElement('a'); link.href = '#'; link.textContent = from; link.className='small'; link.addEventListener('click',(e)=>{ e.preventDefault(); openProfile(from); });
          const left = document.createElement('div'); left.appendChild(link);
          row.appendChild(left);
          const btns = document.createElement('div');
          const a = document.createElement('button'); a.className='ghost'; a.textContent='Accept'; a.addEventListener('click',()=>acceptFriendRequest(from));
          const d = document.createElement('button'); d.className='ghost'; d.textContent='Decline'; d.addEventListener('click',()=>declineFriendRequest(from));
          btns.appendChild(a); btns.appendChild(d); row.appendChild(btns); wrap.appendChild(row);
        });
      });
    }

    async function openProfile(username){
      const targetUsername = String(username || '').trim();
      if(!targetUsername) return;
      let modal = document.getElementById('profileModal');
      if(!modal){
        modal = document.createElement('div');
        modal.id = 'profileModal';
        document.body.appendChild(modal);
      }
      modal.style.position = 'fixed';
      modal.style.left = '0';
      modal.style.top = '0';
      modal.style.width = '100vw';
      modal.style.height = '100vh';
      modal.style.background = 'rgba(0,0,0,0.55)';
      modal.style.zIndex = '12000';
      modal.style.display = 'flex';
      modal.style.alignItems = 'center';
      modal.style.justifyContent = 'center';
      modal.style.padding = '16px';
      modal.innerHTML = `<div style="width:min(560px,94vw);max-height:90vh;overflow:auto;background:var(--card);border:1px solid rgba(255,255,255,0.1);border-radius:16px;box-shadow:0 22px 54px rgba(0,0,0,0.6);padding:18px"><div class="smallMuted">Loading profile...</div></div>`;

      let social = {};
      try{
        social = await fetchSocial(targetUsername);
      }catch(_err){
        social = {};
      }

      const avatarSource = getAvatarSourceBundle(targetUsername, social);
      const avatarUrl = avatarSource.src || DEFAULT_AVATAR_URL;
      const viewer = getCurrentUser();
      const profileStats = getUserPostStats(targetUsername, viewer);
      const joinDate = getUserJoinDate(targetUsername);
      const joinDateLabel = joinDate ? new Date(joinDate).toLocaleDateString() : 'Unknown';
      const friends = (social.friends||[]).length || 0;
      const followersCount = Array.isArray(social.followers) ? social.followers.length : 0;
      const safeLinks = sanitizeProfileLinks(social && Array.isArray(social.links) ? social.links : []);
      const bio = social && social.bio ? escapeHtml(social.bio) : '';
      const pronouns = social && social.pronouns ? escapeHtml(social.pronouns) : '';
      const bannerUrl = social && social.banner_url ? escapeHtml(social.banner_url) : '';
      const avatarBlock = `<div class="profileAvatarWrap" style="width:96px;height:96px;overflow:hidden;border-radius:50%;background:rgba(255,255,255,0.05);border:4px solid rgba(10,18,42,0.9);margin-top:-48px"><img id="profileAvatar" src="${escapeHtml(avatarUrl)}" style="width:100%;height:100%;object-fit:cover"/></div>`;
      const bioBlock = bio ? `<div class="smallMuted" style="margin-top:4px">${bio}</div>` : '';
      const linksBlock = safeLinks.length ? `<div style="margin-top:10px"><div class="smallMuted" style="letter-spacing:0.12em;text-transform:uppercase;font-size:11px">Links</div><div style="display:flex;flex-wrap:wrap;gap:6px;margin-top:6px">${safeLinks.map(link=>`<a class="link" href="${escapeHtml(link.url)}" target="_blank" rel="noopener noreferrer" style="font-size:12px;padding:4px 8px;border-radius:999px;border:1px solid rgba(255,255,255,0.15);background:rgba(255,255,255,0.05)">ðŸ”— ${escapeHtml(link.label)}</a>`).join('')}</div></div>` : '';
      const friendLabel = friends === 1 ? 'friend' : 'friends';
      const followerLabel = followersCount === 1 ? 'follower' : 'followers';
      const bannerStyle = bannerUrl ? `background-image:url('${bannerUrl}');background-size:cover;background-position:center;` : 'background:linear-gradient(135deg,rgba(126,249,194,0.35),rgba(123,91,255,0.45));';
      modal.innerHTML = `<div id="profileCardRoot" style="width:min(760px,96vw);max-height:90vh;overflow:auto;background:var(--card);border:1px solid rgba(255,255,255,0.1);border-radius:16px;box-shadow:0 22px 54px rgba(0,0,0,0.6)"><div style="height:140px;${bannerStyle}"></div><div style="padding:0 16px 16px"><div style="display:flex;justify-content:space-between;align-items:flex-start;gap:10px">${avatarBlock}<button id="closeProfile" class="ghost" style="margin-top:10px">Close</button></div><div data-profile-name-wrap style="margin-top:6px"><strong data-profile-username="${escapeHtml(targetUsername)}" style="font-size:20px">${escapeHtml(targetUsername)}</strong></div><div class="smallMuted" style="margin-top:4px">${pronouns || 'Pronouns not set'}</div><div class="smallMuted" style="margin-top:4px">${friends} ${friendLabel} â€¢ ${followersCount} ${followerLabel}</div><div class="smallMuted" style="margin-top:4px">Joined ${escapeHtml(joinDateLabel)} â€¢ Avg rating ${profileStats.avgPostRating.toFixed(2)} (${profileStats.ratingsCount} ratings)</div>${bioBlock}${linksBlock}<div style="margin-top:12px;display:flex;gap:8px;flex-wrap:wrap" id="profileActions"></div><div style="margin-top:14px"><strong>Posts</strong><div id="profileLibs" style="margin-top:8px"></div><div id="profileLibPagination" style="display:flex;gap:6px;align-items:center;margin-top:8px"></div></div></div></div>`;
      modal.addEventListener('click', (event)=>{
        if(event.target === modal) modal.remove();
      }, { once:true });
      document.getElementById('closeProfile').addEventListener('click', ()=>modal.remove());
      const profileNameWrap = modal.querySelector('[data-profile-name-wrap]');
      if(profileNameWrap){
        renderRoleBadgesInline(profileNameWrap, targetUsername, social, { context:'profile', showNames:true });
      }
      const profileAvatarImg = document.getElementById('profileAvatar');
      const profileAvatarWrap = modal.querySelector('.profileAvatarWrap');
      setAvatarImage(profileAvatarImg, {
        src: avatarUrl,
        wrapper: profileAvatarWrap,
        stage: avatarSource.stage,
        fallbackSources: avatarSource.fallbackSources
      });
      const me = getCurrentUser(); const actions = document.getElementById('profileActions'); actions.innerHTML='';
      if(me && me.username !== targetUsername){
        const mySocial = await fetchSocial(me.username);
        const theirSocial = social || {};
        const isFriend = (mySocial.friends||[]).includes(targetUsername);
        const outgoing = (mySocial.outgoingRequests||[]).includes(targetUsername);
        const incoming = (mySocial.incomingRequests||[]).includes(targetUsername);
        const blocked = (mySocial.blocked||[]).includes(targetUsername);
        const theyBlockedMe = Array.isArray(theirSocial.blocked) ? theirSocial.blocked.includes(me.username) : false;
        const isFollowing = userIsInList(mySocial && mySocial.following, targetUsername);
        if(theyBlockedMe){
          const note = document.createElement('div');
          note.className = 'smallMuted';
          note.textContent = 'This user has blocked you.';
          actions.appendChild(note);
        }else{
          const followBtn = document.createElement('button');
          followBtn.className = 'ghost';
          followBtn.textContent = isFollowing ? 'Following' : 'Follow';
          if(blocked){
            followBtn.disabled = true;
            followBtn.textContent = 'Unblock to follow';
          }else{
            followBtn.addEventListener('click', ()=> toggleFollowUser(targetUsername));
          }
          actions.appendChild(followBtn);
        }
        if(isFriend){ const b = document.createElement('button'); b.className='ghost'; b.textContent='Friends'; actions.appendChild(b); }
        else if(outgoing){ const b = document.createElement('button'); b.className='ghost'; b.textContent='Request sent'; actions.appendChild(b); }
        else if(incoming){ const a = document.createElement('button'); a.className='ghost'; a.textContent='Accept'; a.addEventListener('click', ()=>{ acceptFriendRequest(targetUsername); openProfile(targetUsername); }); actions.appendChild(a); }
        else { const a = document.createElement('button'); a.className='ghost'; a.textContent='Add friend'; a.addEventListener('click', ()=>{ sendFriendRequest(targetUsername); openProfile(targetUsername); }); actions.appendChild(a); }
        if(blocked){ const b = document.createElement('button'); b.className='ghost'; b.textContent='Unblock'; b.addEventListener('click', ()=>{ unblockUser(targetUsername); openProfile(targetUsername); }); actions.appendChild(b); }
        else { const b = document.createElement('button'); b.className='ghost'; b.textContent='Block'; b.addEventListener('click', ()=>{ if(confirm('Block user? This will remove friends and stop messages.')){ blockUser(targetUsername); openProfile(targetUsername); } }); actions.appendChild(b); }
      }
      const libWrap = document.getElementById('profileLibs');
      const pager = document.getElementById('profileLibPagination');
      const profilePageSize = 5;
      let profilePage = 1;
      const renderProfilePosts = ()=>{
        libWrap.innerHTML = '';
        const posts = profileStats.visiblePosts;
        if(!posts.length){
          libWrap.innerHTML = '<div class="smallMuted">No visible posts</div>';
          if(pager) pager.innerHTML = '';
          return;
        }
        const totalPages = Math.max(1, Math.ceil(posts.length / profilePageSize));
        profilePage = Math.min(Math.max(profilePage, 1), totalPages);
        const start = (profilePage - 1) * profilePageSize;
        posts.slice(start, start + profilePageSize).forEach(l=>{
          const d = document.createElement('div');
          d.className = 'libItem';
          const stats = getRatingStats(l);
          d.innerHTML = `<div>${escapeHtml(censorBadWords(l.title || 'Untitled'))}</div><div class="smallMuted">${stats.count ? `${stats.avg.toFixed(2)}â˜…` : 'No ratings'} â€¢ ${Number(l.views)||0} views</div>`;
          libWrap.appendChild(d);
        });
        if(!pager) return;
        pager.innerHTML = '';
        const prev = document.createElement('button');
        prev.className = 'ghost';
        prev.textContent = 'Prev';
        prev.disabled = profilePage <= 1;
        prev.addEventListener('click', ()=>{ profilePage--; renderProfilePosts(); });
        const next = document.createElement('button');
        next.className = 'ghost';
        next.textContent = 'Next';
        next.disabled = profilePage >= totalPages;
        next.addEventListener('click', ()=>{ profilePage++; renderProfilePosts(); });
        const label = document.createElement('span');
        label.className = 'smallMuted';
        label.textContent = `Page ${profilePage}/${totalPages}`;
        pager.appendChild(prev);
        pager.appendChild(label);
        pager.appendChild(next);
      };
      renderProfilePosts();
    }

    const NOTIFICATIONS_KEY = 'jjs_notifications';
    const GLOBAL_NOTIFICATION_BUCKET = '__global__';

    function readNotificationStore(){
      try{
        const raw = localStorage.getItem(NOTIFICATIONS_KEY);
        if(!raw) return {};
        const parsed = JSON.parse(raw);
        if(Array.isArray(parsed)) return { [GLOBAL_NOTIFICATION_BUCKET]: parsed };
        return parsed && typeof parsed === 'object' ? parsed : {};
      }catch(_e){
        return {};
      }
    }

    function writeNotificationStore(store){
      try{ localStorage.setItem(NOTIFICATIONS_KEY, JSON.stringify(store)); }
      catch(_e){}
    }

    function addNotification(text, opts = {}){
      if(!text) return;
      const store = readNotificationStore();
      const current = getCurrentUser();
      const targetUser = (opts.targetUser || (current && current.username) || GLOBAL_NOTIFICATION_BUCKET).toLowerCase();
      const list = Array.isArray(store[targetUser]) ? store[targetUser] : [];
      list.unshift({ t: Date.now(), text });
      store[targetUser] = list.slice(0, 50);
      writeNotificationStore(store);
      if(!opts.silent && current && current.username.toLowerCase() === targetUser){
        renderNotifications();
      }
    }

    function renderNotifications(){
      const el = document.getElementById('notifications'); if(!el) return;
      const current = getCurrentUser();
      if(!current){
        el.innerHTML = '<div class="smallMuted">Sign in to view notifications</div>';
        return;
      }
      const store = readNotificationStore();
      let bucket = Array.isArray(store[current.username.toLowerCase()]) ? store[current.username.toLowerCase()] : [];
      if(!bucket.length && Array.isArray(store[GLOBAL_NOTIFICATION_BUCKET])){
        bucket = store[GLOBAL_NOTIFICATION_BUCKET];
      }
      if(!bucket.length){
        el.innerHTML = '<div class="smallMuted">No notifications yet</div>';
        return;
      }
      el.innerHTML = '';
      bucket.forEach(n=>{
        const div = document.createElement('div');
        const stamp = new Date(n.t || Date.now()).toLocaleString();
        div.textContent = stamp + ' â€” ' + n.text;
        el.appendChild(div);
      });
    }

    const DM_MESSAGE_MAX_LENGTH = 500;

    function sanitizeDmUser(username){
      return (username || '').toString().trim().replace(/[^a-z0-9_-]/gi,'_') || 'anonymous';
    }

    function getDmConvId(userA, userB){
      return [sanitizeDmUser(userA), sanitizeDmUser(userB)].sort((a,b)=>a.localeCompare(b)).join('__');
    }

    async function fetchDmConversation(withUser){
      const me = getCurrentUser();
      if(!me) throw new Error('Sign in to load DMs');
      if(!SERVERLESS_URL) throw new Error('DM server unavailable');
      const convId = getDmConvId(me.username, withUser);
      const resp = await fetch(SERVERLESS_URL + '?action=getDMConversation', {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ convId, participants:[me.username, withUser] })
      });
      const data = await resp.json().catch(()=>null);
      if(!resp.ok || !data || data.error) throw new Error((data && data.error) || 'Failed to load conversation');
      const messages = Array.isArray(data.messages) ? data.messages : [];
      return { convId, messages };
    }

    async function listServerDMs(username){
      if(!SERVERLESS_URL) throw new Error('DM server unavailable');
      const resp = await fetch(SERVERLESS_URL + '?action=listDMs', {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ username })
      });
      const data = await resp.json().catch(()=>null);
      if(!resp.ok || !data || data.error) throw new Error((data && data.error) || 'Failed to load DMs');
      return Array.isArray(data.conversations) ? data.conversations : [];
    }

    async function sendDmMessage(withUser, text){
      const me = getCurrentUser();
      if(!me) throw new Error('Sign in to DM');
      if(!SERVERLESS_URL) throw new Error('DM server unavailable');
      const trimmed = text.trim();
      if(!trimmed) throw new Error('Message required');
      const cleanMessage = censorBadWords(trimmed).slice(0, DM_MESSAGE_MAX_LENGTH);
      const entry = { from: me.username, to: withUser, message: cleanMessage, t: Date.now() };
      const convId = getDmConvId(me.username, withUser);
      const resp = await fetch(SERVERLESS_URL + '?action=saveDM', {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ convId, entry, participants:[me.username, withUser] })
      });
      const data = await resp.json().catch(()=>null);
      if(!resp.ok || !data || data.error) throw new Error((data && data.error) || 'Failed to send message');
      return entry;
    }

    function renderDMList(){
      const wrap = document.getElementById('dmConvos');
      if(!wrap) return;
      const me = getCurrentUser();
      if(!me){
        wrap.innerHTML = '<div class="smallMuted">Sign in to view DMs</div>';
        return;
      }
      if(!SERVERLESS_URL){
        wrap.innerHTML = '<div class="smallMuted">DM server unavailable</div>';
        return;
      }
      wrap.innerHTML = '<div class="smallMuted">Loading...</div>';
      const meKey = sanitizeDmUser(me.username);
      listServerDMs(me.username).then(convos=>{
        if(!convos.length){
          wrap.innerHTML = '<div class="smallMuted">No conversations yet</div>';
          return;
        }
        convos.sort((a,b)=> (b.lastMessage && b.lastMessage.t ? b.lastMessage.t : 0) - (a.lastMessage && a.lastMessage.t ? a.lastMessage.t : 0));
        wrap.innerHTML = '';
        convos.forEach(convo=>{
          const row = document.createElement('div');
          row.className = 'libItem';
          row.style.cursor = 'pointer';
          const previewMsg = (convo.lastMessage && typeof convo.lastMessage.message === 'string') ? censorBadWords(convo.lastMessage.message) : '';
          const previewUser = convo.lastMessage && convo.lastMessage.from ? censorBadWords(convo.lastMessage.from) : '';
          const preview = convo.lastMessage ? `${previewUser}: ${previewMsg.slice(0,60)}`.trim() : 'No messages yet';
          const fallbackUser = (Array.isArray(convo.participants) ? convo.participants : []).find(part=>sanitizeDmUser(part) !== meKey);
          const targetUser = convo.withUser || fallbackUser || '';
          const displayName = targetUser || 'unknown';
          row.innerHTML = `<strong>${escapeHtml(censorBadWords(displayName))}</strong><div class="smallMuted">${escapeHtml(censorBadWords(preview))}</div>`;
          row.addEventListener('click', ()=>{
            if(!targetUser) return alert('Unable to open this conversation');
            openDMWindow(targetUser);
          });
          wrap.appendChild(row);
        });
      }).catch(err=>{
        console.warn('renderDMList error', err);
        wrap.innerHTML = '<div class="smallMuted">Failed to load DMs</div>';
      });
    }

    async function openDMWindow(username){
      const me = getCurrentUser();
      if(!me) return alert('Sign in to DM');
      let mySocial = {};
      let theirSocial = {};
      try{
        [mySocial, theirSocial] = await Promise.all([fetchSocial(me.username), fetchSocial(username)]);
      }catch(err){
        console.warn('openDMWindow social fetch failed', err);
      }
      if((mySocial && mySocial.blocked || []).includes(username)) return alert('You have blocked this user â€” unblock to message.');
      if((theirSocial && theirSocial.blocked || []).includes(me.username)) return alert('User has blocked you â€” cannot message.');
      let modal = document.getElementById('dmModal');
      if(!modal){
        modal = document.createElement('div');
        modal.id='dmModal';
        modal.style.position='fixed';
        modal.style.right='20px';
        modal.style.bottom='20px';
        modal.style.width='320px';
        modal.style.maxHeight='60vh';
        modal.style.background='var(--card)';
        modal.style.padding='10px';
        modal.style.borderRadius='10px';
        modal.style.boxShadow='0 6px 20px rgba(0,0,0,0.6)';
        document.body.appendChild(modal);
      }
      modal.innerHTML = `<div style="display:flex;justify-content:space-between;align-items:center"><strong>DM: ${escapeHtml(censorBadWords(username))}</strong><button id="closeDm" class="ghost">Close</button></div><div id="dmStatus" class="smallMuted" style="margin-top:4px"></div><div id="dmMessages" style="max-height:300px;overflow:auto;margin-top:4px"></div><div style="display:flex;gap:8px;margin-top:8px"><input id="dmMsgInput" style="flex:1;padding:8px;border-radius:6px;border:1px solid rgba(255,255,255,0.04)" placeholder="Message (max ${DM_MESSAGE_MAX_LENGTH} chars)"><button id="sendDmBtn" class="ghost">Send</button></div>`;
      document.getElementById('closeDm').addEventListener('click', ()=>modal.remove());
      const statusEl = document.getElementById('dmStatus');
      const messagesEl = document.getElementById('dmMessages');
      const inputEl = document.getElementById('dmMsgInput');
      const sendBtn = document.getElementById('sendDmBtn');

      function renderMessages(msgs){
        messagesEl.innerHTML = '';
        if(!msgs.length){
          messagesEl.innerHTML = '<div class="smallMuted">No messages yet</div>';
          return;
        }
        msgs.forEach(m=>{
          const div = document.createElement('div');
          div.className='libItem';
          div.style.marginBottom='4px';
          const meta = document.createElement('div');
          meta.innerHTML = `<strong>${escapeHtml(censorBadWords(m.from || 'Unknown'))}</strong> <span class="smallMuted">${new Date(m.t || Date.now()).toLocaleString()}</span>`;
          const body = document.createElement('div');
          body.textContent = censorBadWords(m.message || '');
          div.appendChild(meta);
          div.appendChild(body);
          messagesEl.appendChild(div);
        });
        messagesEl.scrollTop = messagesEl.scrollHeight;
      }

      async function refreshConversation(){
        statusEl.textContent = 'Loading conversation...';
        try{
          const { messages } = await fetchDmConversation(username);
          statusEl.textContent = '';
          renderMessages(messages);
        }catch(err){
          statusEl.textContent = 'Failed to load conversation: ' + (err && err.message ? err.message : 'Unknown error');
        }
      }

      sendBtn.addEventListener('click', async ()=>{
        const txt = (inputEl.value || '').trim();
        if(!txt) return;
        if(txt.length > DM_MESSAGE_MAX_LENGTH) return alert('Max ' + DM_MESSAGE_MAX_LENGTH + ' chars');
        sendBtn.disabled = true;
        try{
          await sendDmMessage(username, txt);
          inputEl.value = '';
          await refreshConversation();
          renderDMList();
        }catch(err){
          alert(err && err.message ? err.message : 'Failed to send message');
        }finally{
          sendBtn.disabled = false;
        }
      });

      inputEl.addEventListener('keydown', (ev)=>{
        if(ev.key === 'Enter' && !ev.shiftKey){
          ev.preventDefault();
          sendBtn.click();
        }
      });

      refreshConversation();
    }

    document.getElementById('openDm').addEventListener('click', ()=>{
      if(!hasFullAccountAccess()) return alert(isGuestModeActive() ? 'Guest mode cannot use DMs. Sign in for full access.' : 'Sign in to use DMs');
      const to = document.getElementById('dmTo').value.trim();
      if(!to) return alert('Enter username');
      openDMWindow(to).catch(err=>{
        alert(err && err.message ? err.message : 'Failed to open DM');
      });
      document.getElementById('dmTo').value='';
    });

    // ensure sidebar updates when user/ libs change
    const origRender = render;
    render = function(filtered){ origRender(filtered); renderSidebar(); };

    // Helper: download an object as JSON file (local fallback)
    function downloadJSON(obj, filename){
      const blob = new Blob([JSON.stringify(obj, null, 2)], {type: 'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = filename || 'data.json';
      document.body.appendChild(a); a.click(); a.remove();
      URL.revokeObjectURL(url);
    }

    function sanitizeFilename(name){
      return name.replace(/[^a-z0-9-_. ]/gi,'_').slice(0,60);
    }

    async function persistLibraryFile(lib, opts = {}){
      if(!lib) throw new Error('Missing library data');
      const { downloadOnMissingConfig = false, downloadOnFailure = false } = opts;
      const filename = lib.__filename || `${lib.id || Date.now()}-${sanitizeFilename(lib.title || 'library')}.json`;
      const localBasePath = (GITHUB.path || '').replace(/^\/+/g,'').replace(/\/+$/g,'');
      const toDownloadResult = (reason)=>{
        lib.__filename = filename;
        lib.__path = lib.__path || filename;
        downloadJSON(lib, filename);
        return { filename: lib.__filename, downloaded: true, method: 'download', reason };
      };
      if(SERVERLESS_URL){
        try{
          const resp = await fetch(SERVERLESS_URL, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ lib, filename }) });
          const data = await resp.json().catch(()=>null);
          if(!resp.ok || (data && data.error)) throw new Error((data && data.error) || 'Save failed');
          if(data && data.result && data.result.content && data.result.content.path){
            lib.__path = data.result.content.path;
            lib.__filename = data.result.content.path.split('/').pop() || filename;
          }else{
            lib.__filename = filename;
            lib.__path = lib.__path || (localBasePath ? `${localBasePath}/${filename}` : filename);
          }
          return { filename: lib.__filename, method: 'serverless' };
        }catch(err){
          if(downloadOnFailure) return toDownloadResult(err);
          throw err;
        }
      }
      if(GITHUB.token && GITHUB.owner && GITHUB.repo){
        await saveToGitHub(lib, filename);
        lib.__filename = filename;
        lib.__path = lib.__path || (localBasePath ? `${localBasePath}/${filename}` : filename);
        return { filename: lib.__filename, method: 'github' };
      }
      if(downloadOnMissingConfig) return toDownloadResult();
      return null;
    }

    async function updateLibraryVisibility(lib, nextVisibility){
      if(!lib) throw new Error('Missing library');
      const previousState = normalizeVisibility(lib.visibility);
      const desiredState = normalizeVisibility(nextVisibility);
      if(previousState === desiredState) return;
      lib.visibility = desiredState;
      sanitizeLibraryContent(lib);
      try{
        await persistLibraryFile(lib, { downloadOnMissingConfig: true, downloadOnFailure: true });
      }catch(err){
        lib.visibility = previousState;
        sanitizeLibraryContent(lib);
        throw err;
      }
    }

    // Save a library file into the configured GitHub repo (creates or updates file)
    async function saveToGitHub(obj, filename){
      const basePath = GITHUB.path ? GITHUB.path.replace(/^\/+|\/+$/g,'') + '/' : '';
      const path = `${basePath}${filename}`;
      const apiBase = `https://api.github.com/repos/${GITHUB.owner}/${GITHUB.repo}/contents/${encodeURIComponent(path)}`;
      const headers = { 'Accept': 'application/vnd.github.v3+json', 'Authorization': `token ${GITHUB.token}` };

      // check if file exists to obtain sha
      let sha = null;
      const getResp = await fetch(apiBase + `?ref=${encodeURIComponent(GITHUB.branch)}`, { headers });
      if(getResp.status === 200){
        const data = await getResp.json(); sha = data.sha;
      }

      const content = toBase64(JSON.stringify(obj, null, 2));
      const body = { message: `Add/Update library ${obj.title}`, content, branch: GITHUB.branch };
      if(sha) body.sha = sha;

      const putResp = await fetch(apiBase, { method: 'PUT', headers: Object.assign({'Content-Type':'application/json'}, headers), body: JSON.stringify(body) });
      if(!putResp.ok) throw new Error('GitHub API error: ' + putResp.status + ' ' + await putResp.text());
      return await putResp.json();
    }

    // Basic unicode-safe base64
    function toBase64(str){
      try{ return btoa(unescape(encodeURIComponent(str))); }catch(e){
        // fallback using TextEncoder
        const bytes = new TextEncoder().encode(str);
        let binary = '';
        bytes.forEach(b=>binary += String.fromCharCode(b));
        return btoa(binary);
      }
    }

    // Load remote libraries (if any) then render
    async function loadRemoteLibs(){
      const diagnostics = document.getElementById('diagnostics');
      if(diagnostics) diagnostics.textContent = 'Loading remote libraries...';
      const owner = (typeof GITHUB !== 'undefined' && GITHUB.owner) ? GITHUB.owner : 'ItzKuroYT';
      const repo = (typeof GITHUB !== 'undefined' && GITHUB.repo) ? GITHUB.repo : 'JJS-Libraries';
      const path = (typeof GITHUB !== 'undefined' && GITHUB.path) ? GITHUB.path : 'libs';
      const api = `https://api.github.com/repos/${owner}/${repo}/contents/${path}`;
      try{
        const listResp = await fetch(api);
        if(!listResp.ok){
          if(diagnostics) diagnostics.textContent = `Failed to list remote libs: ${listResp.status} ${await listResp.text()}`;
          refreshListView({ refilter:true });
          return;
        }
        const list = await listResp.json();
        if(!Array.isArray(list)){ if(diagnostics) diagnostics.textContent = 'No remote files found.'; refreshListView({ refilter:true }); return; }
        let added = 0;
        for(const item of list){
          if(item.type==='file' && item.name.endsWith('.json')){
            try{
              const j = await fetch(item.download_url).then(r=>r.json());
              if(j){
                sanitizeLibraryContent(j);
                // attach filename/path so client can edit/delete
                j.__filename = item.name;
                j.__path = item.path || (path + '/' + item.name);
                let inserted = false;
                if(j.id && !libs.some(l=>l.id===j.id)) { libs.push(j); added++; inserted = true; }
                else if(!j.id){ j.id = Date.now().toString() + Math.random().toString(36).slice(2,6); libs.push(j); added++; inserted = true; }
                if(inserted && remoteLibsInitialized){ notifyFollowersOfNewPost(j); }
              }
            }catch(e){ /* ignore load error */ }
          }
        }
        if(diagnostics) diagnostics.textContent = `Loaded ${added} remote libraries from ${owner}/${repo}/${path}.`;
        refreshListView({ refilter:true });
        remoteLibsInitialized = true;
      }catch(err){
        if(diagnostics) diagnostics.textContent = 'Error loading remote libs: ' + String(err);
        refreshListView({ refilter:true });
      }
    }

    refreshListView({ refilter:true, resetPage:true });
    loadRemoteLibs();
    refreshUserCount();
    refreshStaffDisplay();
    refreshOwnerControlFromServer(true).then(()=> refreshGlobalRoleBadgeUI()).catch(()=>{});
    setInterval(()=>{ refreshOwnerControlFromServer(false).then(()=> refreshListView({ refilter:true })).catch(()=>{}); }, 45000);
    updateStaffConsoleVisibility();
    window.addEventListener('hashchange', handleOwnerHashRoute);
    handleOwnerHashRoute();
  </script>
</body>
</html>

</html>

