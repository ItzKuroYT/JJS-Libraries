<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>JJS Libraries</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: #0f121a;
      --surface: #171c27;
      --surfaceSoft: #1f2634;
      --text: #e8edff;
      --muted: #9da8c1;
      --border: #2b3547;
      --accent: #6f86ff;
      --accent2: #9a63ff;
      --online: #2ccf84;
      --danger: #ea6666;
    }

    :root[data-theme="light"] {
      color-scheme: light;
      --bg: #f4f7fc;
      --surface: #ffffff;
      --surfaceSoft: #edf2fb;
      --text: #1d2634;
      --muted: #67758f;
      --border: #d8e0ee;
      --accent: #4e64ff;
      --accent2: #7e45ff;
      --online: #1dae69;
      --danger: #d85151;
    }

    * { box-sizing: border-box; }
    html, body { margin: 0; min-height: 100%; font-family: Inter, system-ui, -apple-system, Segoe UI, sans-serif; background: var(--bg); color: var(--text); }
    a { color: inherit; text-decoration: none; }
    button, input, textarea, select { font: inherit; }

    .app { width: min(1220px, 95vw); margin: 16px auto 28px; }
    .topbar {
      position: sticky;
      top: 10px;
      z-index: 15;
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      gap: 10px;
      align-items: center;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 12px;
    }
    .leftActions, .rightActions { display: flex; align-items: center; gap: 8px; }
    .rightActions { justify-content: flex-end; }
    .brand { text-align: center; }
    .brand h1 { margin: 0; font-size: 1.2rem; }
    .nav { display: inline-flex; gap: 8px; margin-top: 6px; }
    .navBtn {
      padding: 6px 12px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: var(--surfaceSoft);
      color: var(--muted);
      cursor: pointer;
    }
    .navBtn.active { color: #fff; border-color: transparent; background: linear-gradient(90deg, var(--accent), var(--accent2)); }
    .navBtn[disabled] { opacity: .55; cursor: not-allowed; }

    .btn {
      border: 1px solid var(--border);
      background: var(--surfaceSoft);
      color: var(--text);
      border-radius: 10px;
      padding: 8px 12px;
      cursor: pointer;
    }
    .btn.primary { color: #fff; border-color: transparent; background: linear-gradient(90deg, var(--accent), var(--accent2)); }
    .btn.danger { color: #fff; border-color: transparent; background: var(--danger); }

    .layout {
      margin-top: 14px;
      display: grid;
      grid-template-columns: 260px minmax(0,1fr) 290px;
      gap: 14px;
    }
    .panel {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 14px;
    }
    .communityStrip {
      margin-top: 10px;
      padding: 10px;
      border-radius: 14px;
      background: linear-gradient(120deg, rgba(123,91,255,0.14), rgba(8,19,42,0.8));
      border: 1px solid var(--border);
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 12px;
      align-items: stretch;
    }
    .statBlock {
      border: 1px solid var(--border);
      background: var(--surfaceSoft);
      border-radius: 12px;
      padding: 10px;
      display: grid;
      gap: 4px;
      align-content: start;
      min-height: 90px;
    }
    .statLabel { font-size: .72rem; letter-spacing: .12em; text-transform: uppercase; color: var(--muted); font-weight: 700; }
    .statValue { font-size: 2rem; font-weight: 800; line-height: 1.05; }
    .staffPanel { border: 1px solid var(--border); background: var(--surfaceSoft); border-radius: 12px; padding: 10px; display: flex; flex-direction: column; gap: 10px; }
    .staffBlock { display: flex; flex-direction: column; gap: 5px; }
    .staffPills { display: flex; flex-wrap: wrap; gap: 8px; min-height: 30px; }
    .staffPill { padding: 6px 14px; border-radius: 999px; background: rgba(255,255,255,0.08); font-size: 13px; font-weight: 600; border: 1px solid rgba(255,255,255,0.06); }
    .staffPill--owner { background: color-mix(in srgb, var(--accent) 18%, transparent); color: var(--text); border-color: color-mix(in srgb, var(--accent) 48%, transparent); }
    .staffError { border-color: var(--danger); color: var(--danger); }
    .muted { color: var(--muted); font-size: .93rem; }

    .authWrap { max-width: 360px; display: grid; gap: 8px; }
    .input, .textarea, .select {
      width: 100%;
      border: 1px solid var(--border);
      background: var(--surfaceSoft);
      color: var(--text);
      border-radius: 10px;
      padding: 10px;
    }

    .profileRow { display: flex; align-items: center; gap: 10px; }
    .avatar { width: 52px; height: 52px; border-radius: 50%; object-fit: cover; border: 2px solid var(--border); background: var(--surfaceSoft); }

    .onlineList { max-height: 360px; overflow: auto; display: grid; gap: 8px; }
    .onlineItem {
      position: relative;
      display: flex;
      align-items: center;
      gap: 8px;
      border: 1px solid var(--border);
      background: var(--surfaceSoft);
      border-radius: 10px;
      padding: 8px;
    }
    .onlineDot { margin-left: auto; width: 8px; height: 8px; border-radius: 50%; background: var(--online); }
    .tooltip {
      display: none;
      position: absolute;
      left: 8px;
      top: calc(100% + 6px);
      width: 220px;
      z-index: 30;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: var(--surface);
      padding: 8px;
    }
    .onlineItem:hover .tooltip { display: block; }

    .modalBg {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,.55);
      z-index: 40;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 16px;
    }
    .modalCard {
      width: min(780px, 96vw);
      max-height: 90vh;
      overflow: auto;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 14px;
    }

    .fullCard { overflow: hidden; padding: 0; }
    .banner { height: 136px; background: linear-gradient(135deg, var(--accent), var(--accent2)); }
    .fullBody { padding: 0 14px 14px; }
    .avatarLg { width: 96px; height: 96px; border-radius: 50%; margin-top: -48px; border: 4px solid var(--surface); object-fit: cover; background: var(--surfaceSoft); }
    .socialRow { margin-top: 10px; display: flex; flex-wrap: wrap; gap: 7px; }
    .chip { border: 1px solid var(--border); border-radius: 999px; background: var(--surfaceSoft); color: var(--muted); padding: 4px 10px; font-size: .86rem; }

    .dmLayout { display:grid; grid-template-columns: 230px minmax(0,1fr); gap: 10px; min-height: 360px; }
    .dmSidebar { border:1px solid var(--border); border-radius:12px; background:var(--surfaceSoft); padding:8px; display:grid; gap:8px; align-content:start; }
    .dmList { max-height: 300px; overflow:auto; display:grid; gap:6px; }
    .dmRow { border:1px solid var(--border); border-radius:10px; background:var(--surface); padding:8px; cursor:pointer; }
    .dmRow.active { border-color: var(--accent); }
    .dmChat { border:1px solid var(--border); border-radius:12px; background:var(--surfaceSoft); padding:10px; display:grid; grid-template-rows:auto 1fr auto; gap:8px; }
    .dmMsgs { max-height: 300px; overflow:auto; display:grid; gap:7px; align-content:start; }
    .dmBubble { border:1px solid var(--border); border-radius:10px; padding:7px 9px; background:var(--surface); }
    .dmBubble.me { border-color: transparent; background: linear-gradient(90deg, var(--accent), var(--accent2)); color:#fff; }

    .ownerOverlay { position: fixed; inset: 0; background: rgba(0,0,0,.58); z-index: 60; display:flex; align-items:center; justify-content:center; padding:16px; }
    .ownerCard { width:min(1040px,96vw); max-height:90vh; overflow:hidden; border:1px solid var(--border); border-radius:14px; background:var(--surface); display:grid; grid-template-columns:220px minmax(0,1fr); }
    .ownerSide { background:var(--surfaceSoft); border-right:1px solid var(--border); padding:10px; display:grid; gap:8px; align-content:start; }
    .ownerTab { width:100%; text-align:left; border:1px solid var(--border); border-radius:10px; background:var(--surface); color:var(--text); padding:9px 10px; cursor:pointer; }
    .ownerTab.active { border-color: var(--accent); color: #fff; background: linear-gradient(90deg,var(--accent),var(--accent2)); }
    .ownerBody { padding:12px; overflow:auto; display:grid; gap:10px; }
    .ownerList { display:grid; gap:8px; }
    .ownerItem { border:1px solid var(--border); border-radius:10px; background:var(--surfaceSoft); padding:8px; display:flex; justify-content:space-between; gap:8px; align-items:center; }

    @media (max-width: 980px) {
      .ownerCard { grid-template-columns: 1fr; }
      .ownerSide { border-right:none; border-bottom:1px solid var(--border); }
    }

    .fade { transition: opacity .2s ease; }
    .fade.out { opacity: 0; }

    @media (max-width: 980px) {
      .layout { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <div class="app">
    <header id="topbarRoot"></header>
    <main id="mainRoot"></main>
  </div>
  <div id="modalRoot"></div>

  <script>
    const AUTH_KEY = 'jjs_token';
    const THEME_KEY = 'jjs_theme';
    const PROFILE_KEY = 'jjs_profile_v2';
    const CACHE_KEY = 'jjs_cached_user_info';
    const TAB_ID = `${Date.now()}_${Math.random().toString(36).slice(2, 9)}`;
    const USERS_URL = '/api/users';
    const OWNER_CONTROL_URL = '/api/users';
    const SAVE_URL = '/api/save-lib';
    const SAVE_URL_FALLBACK = 'https://jjs-libraries.vercel.app/api/save-lib';
    const USERS_URL_FALLBACK = 'https://jjs-libraries.vercel.app/api/users';
    const OWNER_USERNAME = 'Kuro';
    const OWNER_USERNAME_LOWER = OWNER_USERNAME.toLowerCase();
    const FALLBACK_AVATAR = 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="96" height="96" viewBox="0 0 96 96"><rect width="96" height="96" fill="%23202838"/><circle cx="48" cy="34" r="16" fill="%238696ab"/><rect x="22" y="58" width="52" height="24" rx="12" fill="%238696ab"/></svg>';

    let presencePingTimer = null;
    let onlineRefreshTimer = null;
    let onlineUsers = [];
    let userDirectory = [];
    let ownerState = { roles: [], badges: [], userRoles: {}, userBadges: {}, loaded: false };
    let profileSyncUser = '';
    let profileSyncDone = false;

    const topbarRoot = document.getElementById('topbarRoot');
    const mainRoot = document.getElementById('mainRoot');
    const modalRoot = document.getElementById('modalRoot');

    function getToken(){ try { return localStorage.getItem(AUTH_KEY) || ''; } catch(_e){ return ''; } }
    function setToken(token){
      try {
        if(token) localStorage.setItem(AUTH_KEY, token);
        else localStorage.removeItem(AUTH_KEY);
      } catch(_e){}
      if(!token){
        profileSyncUser = '';
        profileSyncDone = false;
      }
      render();
    }

    function decodeToken(token){
      if(!token) return null;
      try {
        const parts = token.split('.');
        if(parts.length < 2) return null;
        const payload = JSON.parse(atob(parts[1].replace(/-/g,'+').replace(/_/g,'/')));
        if(payload.exp && Date.now()/1000 > payload.exp) return null;
        return payload;
      } catch(_e){ return null; }
    }

    function getUser(){
      const payload = decodeToken(getToken());
      if(!payload || !payload.username) return null;
      return { id: payload.id, username: payload.username, role: payload.role || 'member' };
    }

    function isOwnerUser(user){
      if(!user || !user.username) return false;
      const uname = String(user.username).trim().toLowerCase();
      return user.role === 'owner' || uname === 'kuro';
    }

    function getTheme(){ try { return localStorage.getItem(THEME_KEY) || 'dark'; } catch(_e){ return 'dark'; } }
    function applyTheme(theme){
      const value = theme === 'light' ? 'light' : 'dark';
      document.documentElement.setAttribute('data-theme', value);
      try { localStorage.setItem(THEME_KEY, value); } catch(_e){}
    }
    function toggleTheme(){ applyTheme(getTheme() === 'dark' ? 'light' : 'dark'); render(); }

    function escapeHtml(value){
      return String(value ?? '')
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }

    function sanitizeUrl(value, options = {}){
      const allowDataImage = !!options.allowDataImage;
      const raw = String(value || '').trim();
      if(!raw) return '';
      if(allowDataImage && /^data:image\//i.test(raw)) return raw;
      try {
        const parsed = new URL(raw, window.location.origin);
        if(parsed.protocol === 'http:' || parsed.protocol === 'https:') return parsed.href;
      } catch(_e){}
      return '';
    }

    function normalizeSocialLinks(links){
      if(!Array.isArray(links)) return [];
      const cleaned = links
        .map(link => ({
          label: String((link && link.label) || '').trim().slice(0, 40),
          url: sanitizeUrl((link && link.url) || '')
        }))
        .filter(link => link.label && link.url);
      return cleaned.slice(0, 5);
    }

    function usersEndpointCandidates(){
      const list = [USERS_URL, USERS_URL_FALLBACK].filter(Boolean);
      return Array.from(new Set(list));
    }

    function saveEndpointCandidates(){
      const list = [SAVE_URL, SAVE_URL_FALLBACK].filter(Boolean);
      return Array.from(new Set(list));
    }

    function normalizeUserRecord(raw, idx){
      if(!raw) return null;
      if(typeof raw === 'string'){
        const trimmed = raw.trim();
        if(!trimmed) return null;
        return { id: String(idx ?? trimmed), username: trimmed, role: 'member' };
      }
      const username = String(raw.username || raw.user || raw.name || raw.id || '').trim();
      if(!username) return null;
      return {
        id: raw.id || String(idx ?? username),
        username,
        role: String(raw.role || raw.type || 'member').toLowerCase()
      };
    }

    function parseUsersPayload(payload){
      if(!payload) return [];
      if(Array.isArray(payload)) return payload.map((item, idx)=> normalizeUserRecord(item, idx)).filter(Boolean);
      if(Array.isArray(payload.users)) return payload.users.map((item, idx)=> normalizeUserRecord(item, idx)).filter(Boolean);
      return [];
    }

    async function fetchUsersFallback(){
      const candidates = [
        'https://raw.githubusercontent.com/ItzKuroYT/JJS-Libraries/main/users/users.json',
        'https://raw.githubusercontent.com/ItzKuroYT/JJS-Libraries/main/users/users.txt',
        'https://raw.githubusercontent.com/ItzKuroYT/JJS-Libraries/main/users.json'
      ];
      for(const url of candidates){
        try{
          const resp = await fetch(url, { cache: 'no-store' });
          if(!resp.ok) continue;
          const text = await resp.text();
          if(!text) continue;
          let list = [];
          try {
            list = parseUsersPayload(JSON.parse(text));
          } catch(_e) {
            list = text.split(/\r?\n/).map((line, idx)=> normalizeUserRecord(line, idx)).filter(Boolean);
          }
          if(list.length) return list;
        }catch(_e){}
      }
      return null;
    }

    function getOwnerFromFallback(usersList){
      if(!Array.isArray(usersList)) return OWNER_USERNAME ? { id: OWNER_USERNAME, username: OWNER_USERNAME } : null;
      const ownerMatch = usersList.find(u=> u && ((u.role || '').toLowerCase() === 'owner' || (u.username || '').toLowerCase() === OWNER_USERNAME_LOWER));
      if(ownerMatch) return { id: ownerMatch.id || ownerMatch.username, username: ownerMatch.username };
      return OWNER_USERNAME ? { id: OWNER_USERNAME, username: OWNER_USERNAME } : null;
    }

    function getModeratorsFromFallback(usersList){
      if(!Array.isArray(usersList)) return [];
      return usersList
        .filter(u=> (u.role || '').toLowerCase() === 'moderator')
        .map(u=>({ id: u.id || u.username, username: u.username }));
    }

    function defaultProfile(){
      const user = getUser();
      return {
        username: user ? user.username : 'Guest',
        pronouns: '',
        bio: '',
        avatarUrl: '',
        bannerUrl: '',
        socialLinks: []
      };
    }

    function getProfile(){
      const base = defaultProfile();
      try {
        const saved = JSON.parse(localStorage.getItem(PROFILE_KEY) || '{}') || {};
        const merged = Object.assign(base, saved);
        merged.socialLinks = normalizeSocialLinks(merged.socialLinks);
        return merged;
      } catch(_e){ return base; }
    }

    function getCache(){ try { return JSON.parse(localStorage.getItem(CACHE_KEY) || '{}') || {}; } catch(_e){ return {}; } }
    function getCachedUser(username){ if(!username) return null; return getCache()[String(username).toLowerCase()] || null; }
    function setCachedUser(username, patch){
      if(!username) return;
      const key = String(username).toLowerCase();
      const map = getCache();
      map[key] = Object.assign({}, map[key] || {}, patch || {}, { updatedAt: Date.now() });
      try { localStorage.setItem(CACHE_KEY, JSON.stringify(map)); } catch(_e){}
    }

    function setProfile(patch){
      const user = getUser();
      const profile = Object.assign(getProfile(), patch || {});
      profile.avatarUrl = sanitizeUrl(profile.avatarUrl, { allowDataImage: true });
      profile.bannerUrl = sanitizeUrl(profile.bannerUrl, { allowDataImage: true });
      profile.socialLinks = normalizeSocialLinks(profile.socialLinks);
      try { localStorage.setItem(PROFILE_KEY, JSON.stringify(profile)); } catch(_e){}
      if(user){
        setCachedUser(user.username, {
          username: user.username,
          avatarUrl: profile.avatarUrl,
          pronouns: profile.pronouns,
          bio: profile.bio,
          bannerUrl: profile.bannerUrl
        });
        try {
          const socialKey = 'jjs_social_' + user.username.toLowerCase();
          const existing = JSON.parse(localStorage.getItem(socialKey) || '{}') || {};
          const nextSocial = Object.assign({}, existing, {
            bio: profile.bio || existing.bio || '',
            pronouns: profile.pronouns || existing.pronouns || '',
            avatar_url: profile.avatarUrl || existing.avatar_url || '',
            banner_url: profile.bannerUrl || existing.banner_url || '',
            links: Array.isArray(profile.socialLinks) ? profile.socialLinks : (existing.links || [])
          });
          localStorage.setItem(socialKey, JSON.stringify(nextSocial));
          localStorage.setItem('jjs_social_' + user.username, JSON.stringify(nextSocial));
        } catch(_e){}
      }
      return profile;
    }

    function profileToSocial(profile){
      const safe = Object.assign(defaultProfile(), profile || {});
      return {
        bio: String(safe.bio || '').trim(),
        pronouns: String(safe.pronouns || '').trim(),
        avatar_url: sanitizeUrl(safe.avatarUrl, { allowDataImage: true }) || '',
        banner_url: sanitizeUrl(safe.bannerUrl, { allowDataImage: true }) || '',
        links: normalizeSocialLinks(safe.socialLinks)
      };
    }

    function socialToProfile(social, username){
      const src = social && typeof social === 'object' ? social : {};
      return {
        username: username || (getUser() && getUser().username) || 'Guest',
        pronouns: String(src.pronouns || '').trim(),
        bio: String(src.bio || '').trim(),
        avatarUrl: sanitizeUrl(src.avatar_url || src.avatarUrl || '', { allowDataImage: true }),
        bannerUrl: sanitizeUrl(src.banner_url || src.bannerUrl || '', { allowDataImage: true }),
        socialLinks: normalizeSocialLinks(src.links || src.socialLinks || [])
      };
    }

    async function fetchProfileFromServer(username){
      if(!username) return null;
      for(const endpoint of saveEndpointCandidates()){
        try{
          const resp = await fetch(`${endpoint}?action=getSocial&username=${encodeURIComponent(username)}`, { cache: 'no-store' });
          const data = await resp.json().catch(()=>null);
          if(!resp.ok || !data || !data.ok) continue;
          return socialToProfile(data.social || {}, username);
        }catch(_e){}
      }
      return null;
    }

    async function saveProfileToServer(profile){
      const user = getUser();
      if(!user || !user.username) throw new Error('Sign in required');
      const social = profileToSocial(profile);
      let lastError = null;
      for(const endpoint of saveEndpointCandidates()){
        try{
          const resp = await fetch(`${endpoint}?action=updateSocial`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ username: user.username, social })
          });
          const data = await resp.json().catch(()=>null);
          if(!resp.ok || !data || !data.ok){
            throw new Error((data && data.error) || 'Failed to save profile');
          }
          return true;
        }catch(err){
          lastError = err;
        }
      }
      throw (lastError || new Error('Failed to save profile'));
    }

    async function syncProfileFromServer(force = false){
      const user = getUser();
      if(!user || !user.username) return;
      const userKey = String(user.username).toLowerCase();
      if(!force && profileSyncDone && profileSyncUser === userKey) return;
      const remote = await fetchProfileFromServer(user.username);
      if(remote) setProfile(remote);
      else setProfile({ username: user.username });
      profileSyncUser = userKey;
      profileSyncDone = true;
    }

    function transitionTo(path){
      const parts = [document.getElementById('topbarWrap'), document.getElementById('mainWrap')].filter(Boolean);
      parts.forEach(node => node.classList.add('out'));
      setTimeout(()=>{ location.href = path; }, 170);
    }

    async function parseResponse(resp){
      const data = await resp.json().catch(()=>null);
      if(!resp.ok) throw new Error((data && data.error) || 'Request failed');
      return data || {};
    }

    async function auth(mode, username, password){
      const resp = await fetch(`${USERS_URL}?action=${mode}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ username, password })
      });
      return await parseResponse(resp);
    }

    function authHeaders(){
      const token = getToken();
      if(!token) return null;
      return { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` };
    }

    async function presencePing(){
      const headers = authHeaders();
      const user = getUser();
      if(!headers || !user) return;
      const profile = getProfile();
      await fetch(`${USERS_URL}?action=presencePing`, {
        method: 'POST', headers,
        body: JSON.stringify({
          tabId: TAB_ID,
          profile: {
            avatarUrl: profile.avatarUrl,
            pronouns: profile.pronouns,
            bio: profile.bio
          }
        })
      }).catch(()=>{});
    }

    async function presenceLeave(){
      const headers = authHeaders();
      if(!headers) return;
      await fetch(`${USERS_URL}?action=presenceLeave`, {
        method: 'POST', keepalive: true, headers,
        body: JSON.stringify({ tabId: TAB_ID })
      }).catch(()=>{});
    }

    async function fetchOnlineUsers(){
      const headers = authHeaders();
      if(!headers) return [];
      const resp = await fetch(`${USERS_URL}?action=presenceList`, { headers });
      const data = await parseResponse(resp);
      const users = Array.isArray(data.users) ? data.users : [];
      users.forEach(item => {
        if(item && item.username){
          setCachedUser(item.username, {
            username: item.username,
            avatarUrl: item.avatarUrl || '',
            pronouns: item.pronouns || '',
            bio: item.bio || ''
          });
        }
      });
      return users;
    }

    function isUsernameOnline(username){
      const target = String(username || '').trim().toLowerCase();
      if(!target) return false;
      return onlineUsers.some(item => String(item && item.username || '').trim().toLowerCase() === target);
    }

    async function fetchAllUsersList(){
      const endpoints = usersEndpointCandidates();
      for(const endpoint of endpoints){
        try{
          const resp = await fetch(`${endpoint}?action=listUsers`, { cache: 'no-store' });
          const data = await resp.json().catch(()=>null);
          if(!resp.ok || !data || !data.ok || !Array.isArray(data.users)) continue;
          return data.users;
        }catch(_e){}
      }
      const fallback = await fetchUsersFallback().catch(()=>null);
      return Array.isArray(fallback) ? fallback : [];
    }

    async function refreshUserDirectory(){
      const me = getUser();
      if(!me){
        userDirectory = [];
        patchOnlineUsers();
        return;
      }

      const rawUsers = await fetchAllUsersList();
      const names = Array.from(new Set(
        (Array.isArray(rawUsers) ? rawUsers : [])
          .map(item => String((item && item.username) || '').trim())
          .filter(Boolean)
      ));
      if(!names.some(name => name.toLowerCase() === me.username.toLowerCase())) names.push(me.username);

      const resolved = await Promise.all(names.map(async (username)=>{
        const remote = await fetchProfileFromServer(username).catch(()=>null);
        const cached = getCachedUser(username) || {};
        const avatarUrl = sanitizeUrl((remote && remote.avatarUrl) || cached.avatarUrl || '', { allowDataImage: true }) || FALLBACK_AVATAR;
        const pronouns = String((remote && remote.pronouns) || cached.pronouns || '').trim();
        const bio = String((remote && remote.bio) || cached.bio || '').trim();
        setCachedUser(username, { username, avatarUrl, pronouns, bio });
        return {
          username,
          avatarUrl,
          pronouns,
          bio,
          online: isUsernameOnline(username)
        };
      }));

      userDirectory = resolved
        .sort((a,b)=>{
          if(Boolean(b.online) !== Boolean(a.online)) return b.online ? 1 : -1;
          return String(a.username || '').localeCompare(String(b.username || ''));
        });

      patchOnlineUsers();
    }

    function stopPresence(){
      if(presencePingTimer) clearInterval(presencePingTimer);
      if(onlineRefreshTimer) clearInterval(onlineRefreshTimer);
      presencePingTimer = null;
      onlineRefreshTimer = null;
    }

    function startPresence(){
      if(!getUser()) return;
      stopPresence();
      presencePing();
      refreshOnlineUsers();
      refreshUserDirectory();
      presencePingTimer = setInterval(presencePing, 25000);
      onlineRefreshTimer = setInterval(refreshOnlineUsers, 8000);
    }

    async function refreshOnlineUsers(){
      if(!getUser()){
        onlineUsers = [];
        userDirectory = [];
        patchOnlineUsers();
        return;
      }
      try { onlineUsers = await fetchOnlineUsers(); }
      catch(_e){ onlineUsers = []; }

      if(userDirectory.length){
        const onlineSet = new Set(onlineUsers.map(item => String(item && item.username || '').trim().toLowerCase()).filter(Boolean));
        userDirectory = userDirectory.map(item => Object.assign({}, item, { online: onlineSet.has(String(item.username || '').toLowerCase()) }));
      }
      patchOnlineUsers();
    }

    function iconFor(label){
      const key = String(label || '').toLowerCase();
      if(key.includes('discord')) return 'üéÆ';
      if(key.includes('reddit')) return 'üëΩ';
      if(key.includes('youtube')) return '‚ñ∂Ô∏è';
      if(key.includes('twitter') || key.includes('x')) return 'üê¶';
      return 'üîó';
    }

    function renderTopbar(){
      const user = getUser();
      const authed = !!user;
      const isOwner = !!(authed && isOwnerUser(user));
      const safeUsername = escapeHtml((user && user.username) || '');
      return `
        <div id="topbarWrap" class="topbar fade">
          <div class="leftActions" id="leftActions">
            ${authed ? `<span class="muted">Signed in as <strong>${safeUsername}</strong></span><button class="btn" id="logoutBtn">Logout</button>` : `<span class="muted">Not signed in</span>`}
          </div>
          <div class="brand">
            <h1>JJS Libraries</h1>
            <div class="nav">
              <button class="navBtn active" id="movesetsBtn" ${authed ? '' : 'disabled'}>Movesets</button>
              <button class="navBtn" id="forumsBtn">Skillbuilder Forums</button>
            </div>
          </div>
          <div class="rightActions">
            <button class="btn" id="dmsBtn" ${authed ? '' : 'disabled'}>DMs</button>
            ${isOwner ? '<button class="btn" id="ownerPanelBtn">Owner Panel</button>' : ''}
            <button class="btn" id="settingsBtn" ${authed ? '' : 'disabled'}>Settings</button>
            <button class="btn" id="themeBtn">Theme</button>
          </div>
        </div>
      `;
    }

    function renderCompactProfile(profile, user){
      const cached = getCachedUser(user.username) || {};
      const avatar = sanitizeUrl(profile.avatarUrl || cached.avatarUrl, { allowDataImage: true }) || FALLBACK_AVATAR;
      const username = escapeHtml(user.username || '');
      const pronouns = escapeHtml(profile.pronouns || 'No pronouns set');
      const bio = escapeHtml(profile.bio || 'No bio yet.');
      return `
        <section class="panel">
          <h3 style="margin-top:0">Profile</h3>
          <div class="profileRow" id="compactProfileOpen" style="cursor:pointer">
            <img class="avatar" src="${escapeHtml(avatar)}" alt="avatar" />
            <div>
              <div><strong>${username}</strong></div>
              <div class="muted">${pronouns}</div>
            </div>
          </div>
          <div class="muted" style="margin-top:6px">Click profile to edit</div>
          <p class="muted" style="margin-bottom:0">${bio}</p>
        </section>
      `;
    }

    function renderFullProfileCard(profile, user){
      const cached = getCachedUser(user.username) || {};
      const avatar = sanitizeUrl(profile.avatarUrl || cached.avatarUrl, { allowDataImage: true }) || FALLBACK_AVATAR;
      const socials = normalizeSocialLinks(profile.socialLinks);
      const safeBanner = sanitizeUrl(profile.bannerUrl, { allowDataImage: true });
      const bannerStyle = safeBanner
        ? `background-image:url('${escapeHtml(safeBanner)}');background-size:cover;background-position:center;`
        : 'background:linear-gradient(135deg,var(--accent),var(--accent2));';

      return `
        <section class="panel fullCard">
          <div class="banner" style="${bannerStyle}"></div>
          <div class="fullBody">
            <img class="avatarLg" src="${escapeHtml(avatar)}" alt="profile" />
            <h3 style="margin:8px 0 2px">${escapeHtml(user.username || '')}</h3>
            <div class="muted">${escapeHtml(profile.pronouns || 'Pronouns not set')}</div>
            <p style="margin:10px 0 0">${escapeHtml(profile.bio || 'Add your bio in settings.')}</p>
            <div class="socialRow">
              ${socials.length ? socials.map(link => `<a class="chip" target="_blank" rel="noopener noreferrer" href="${escapeHtml(link.url)}">${iconFor(link.label)} ${escapeHtml(link.label || 'Link')}</a>`).join('') : '<span class="muted">No social links set</span>'}
            </div>
          </div>
        </section>
      `;
    }

    function renderOnlineUsers(users){
      if(!users.length){
        return `<section class="panel"><h3 style="margin-top:0">Users</h3><p class="muted">No users found.</p></section>`;
      }
      return `
        <section class="panel">
          <h3 style="margin-top:0">Users (${users.length})</h3>
          <div class="onlineList">
            ${users.map(item => {
              const avatar = sanitizeUrl(item.avatarUrl || '', { allowDataImage: true }) || FALLBACK_AVATAR;
              const username = escapeHtml(item.username || '');
              const pronouns = escapeHtml(item.pronouns || 'Pronouns not set');
              const bio = escapeHtml(item.bio || 'No bio provided');
              const onlineColor = item.online ? 'var(--online)' : 'var(--border)';
              return `
                <article class="onlineItem" data-open-profile="${username}" style="cursor:pointer">
                  <img class="avatar" style="width:34px;height:34px" src="${escapeHtml(avatar)}" alt="${username}" />
                  <div>${username}</div>
                  <button class="btn" data-open-dm="${username}" style="padding:4px 8px">DM</button>
                  <span class="onlineDot" style="background:${onlineColor}"></span>
                  <div class="tooltip">
                    <strong>${username}</strong>
                    <div class="muted">${pronouns}</div>
                    <div class="muted">${bio}</div>
                  </div>
                </article>
              `;
            }).join('')}
          </div>
        </section>
      `;
    }

    function renderAuthHero(){
      return `
        <section id="mainWrap" class="panel fade" style="margin-top:14px">
          <h2 style="margin-top:0">Welcome to JJS Libraries</h2>
          <p class="muted">Sign in or create an account to access Movesets, live online users, and profile settings.</p>
          <div class="authWrap">
            <input id="authUser" class="input" minlength="4" maxlength="15" placeholder="Username" />
            <input id="authPass" class="input" type="password" minlength="4" placeholder="Password" />
            <div style="display:flex;gap:8px;flex-wrap:wrap">
              <button class="btn" id="signinBtn">Sign in</button>
              <button class="btn primary" id="signupBtn">Sign up</button>
            </div>
            <div class="muted" id="authStatus"></div>
          </div>
        </section>
      `;
    }

    function renderAuthedMain(user, profile){
      return `
        <section id="mainWrap" class="layout fade">
          <aside>${renderCompactProfile(profile, user)}</aside>
          <section>
            <div class="panel">
              <h2 style="margin-top:0">Main Hub</h2>
              <p class="muted">Movesets is live. Skillbuilder Forums is a placeholder for now.</p>
              <div class="communityStrip">
                <div class="statBlock">
                  <div class="statLabel">Current Users</div>
                  <div class="statValue" id="currentUsersValue">‚Äî</div>
                </div>
                <div class="staffPanel">
                  <div class="staffBlock">
                    <div class="statLabel">Owner</div>
                    <div class="staffPills">
                      <span class="staffPill staffPill--owner" id="staffOwnerValue">Loading...</span>
                    </div>
                  </div>
                  <div class="staffBlock">
                    <div class="statLabel">Moderators</div>
                    <div class="staffPills" id="staffModerators">
                      <span class="staffPill">Loading...</span>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </section>
          <aside id="onlineSidebar">${renderOnlineUsers(userDirectory)}</aside>
        </section>
      `;
    }

    function patchOnlineUsers(){
      const slot = document.getElementById('onlineSidebar');
      if(!slot || !getUser()) return;
      slot.innerHTML = renderOnlineUsers(userDirectory);
      wireOnlineUserActions();
    }

    function closeModal(){ modalRoot.innerHTML = ''; }

    function openFullProfile(){
      const user = getUser();
      if(!user) return;
      const profile = getProfile();
      modalRoot.innerHTML = `
        <div class="modalBg" id="fullProfileModalBg">
          <div class="modalCard">
            <div style="display:flex;justify-content:space-between;align-items:center;gap:10px;margin-bottom:8px">
              <h3 style="margin:0">Full Profile</h3>
              <button class="btn" id="closeFullProfileBtn">Close</button>
            </div>
            ${renderFullProfileCard(profile, user)}
          </div>
        </div>
      `;
      document.getElementById('closeFullProfileBtn').addEventListener('click', closeModal);
      document.getElementById('fullProfileModalBg').addEventListener('click', (e)=>{ if(e.target.id==='fullProfileModalBg') closeModal(); });
    }

    async function openUserProfile(username){
      const me = getUser();
      const target = String(username || '').trim();
      if(!me || !target) return;
      const profile = (await fetchProfileFromServer(target).catch(()=>null)) || socialToProfile({}, target);
      const modalUser = { username: target };

      modalRoot.innerHTML = `
        <div class="modalBg" id="publicProfileModalBg">
          <div class="modalCard">
            <div style="display:flex;justify-content:space-between;align-items:center;gap:10px;margin-bottom:8px">
              <h3 style="margin:0">Profile</h3>
              <button class="btn" id="closePublicProfileBtn">Close</button>
            </div>
            ${renderFullProfileCard(profile, modalUser)}
            <div style="display:flex;gap:8px;margin-top:10px">
              <button class="btn" id="publicProfileDmBtn">DM ${escapeHtml(target)}</button>
            </div>
          </div>
        </div>
      `;

      document.getElementById('closePublicProfileBtn').addEventListener('click', closeModal);
      document.getElementById('publicProfileModalBg').addEventListener('click', (e)=>{ if(e.target.id==='publicProfileModalBg') closeModal(); });
      document.getElementById('publicProfileDmBtn').addEventListener('click', ()=>{
        closeModal();
        openDmsMenu(target);
      });
    }

    function fileToDataUrl(file){
      return new Promise((resolve, reject)=>{
        const reader = new FileReader();
        reader.onload = ()=> resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    }

    async function uploadAvatar(file){
      const user = getUser();
      if(!user || !file) return '';
      const dataUrl = await fileToDataUrl(file);
      for(const endpoint of saveEndpointCandidates()){
        try{
          const resp = await fetch(`${endpoint}?action=uploadAvatar`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ username: user.username, dataUrl })
          });
          const data = await resp.json().catch(()=>null);
          if(resp.ok && data && data.url) return data.url;
        }catch(_e){}
      }
      return dataUrl;
    }

    function openSettings(){
      const current = getTheme();
      modalRoot.innerHTML = `
        <div class="modalBg" id="settingsBg">
          <div class="modalCard" style="max-width:420px">
            <div style="display:flex;justify-content:space-between;align-items:center;gap:10px">
              <h3 style="margin:0">Theme Settings</h3>
              <button class="btn" id="closeSettingsBtn">Close</button>
            </div>
            <p class="muted">Theme only for now.</p>
            <label class="muted">Theme
              <select id="setTheme" class="select" style="margin-top:6px">
                <option value="dark">Dark</option>
                <option value="light">Light</option>
              </select>
            </label>
            <div style="margin-top:12px;display:flex;gap:8px">
              <button class="btn primary" id="saveSettingsBtn">Save Theme</button>
            </div>
          </div>
        </div>
      `;

      const closeBtn = document.getElementById('closeSettingsBtn');
      const bg = document.getElementById('settingsBg');
      const saveBtn = document.getElementById('saveSettingsBtn');
      const themeSelect = document.getElementById('setTheme');
      if(themeSelect) themeSelect.value = current;

      closeBtn.addEventListener('click', closeModal);
      bg.addEventListener('click', (e)=>{ if(e.target === bg) closeModal(); });
      saveBtn.addEventListener('click', ()=>{
        applyTheme(document.getElementById('setTheme').value || getTheme());
        closeModal();
        render();
      });
    }

    function openProfileEditor(){
      const profile = getProfile();
      const initialLinks = normalizeSocialLinks(profile.socialLinks);
      modalRoot.innerHTML = `
        <div class="modalBg" id="profileEditorBg">
          <div class="modalCard">
            <div style="display:flex;justify-content:space-between;align-items:center;gap:10px">
              <h3 style="margin:0">Edit Profile</h3>
              <button class="btn" id="closeProfileEditorBtn">Close</button>
            </div>
            <p class="muted">Update profile details here.</p>

            <label class="muted">Pronouns<input id="setPronouns" class="input" value="${escapeHtml(profile.pronouns || '')}" /></label>

            <label class="muted" style="display:block;margin-top:10px">Bio
              <textarea id="setBio" class="textarea" rows="3">${escapeHtml(profile.bio || '')}</textarea>
            </label>

            <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:10px">
              <label class="muted">Profile picture upload<input id="setAvatar" type="file" accept="image/*" class="input" /></label>
              <label class="muted">Profile banner upload<input id="setBanner" type="file" accept="image/*" class="input" /></label>
            </div>

            <h4 style="margin-bottom:8px">Custom links (max 5)</h4>
            <div class="muted" id="linksCountLabel">0 / 5</div>
            <div id="customLinksList" style="display:grid;gap:8px;margin-top:8px"></div>

            <div style="display:grid;grid-template-columns:1fr 1fr auto;gap:8px;margin-top:10px;align-items:end">
              <label class="muted">Link name
                <input id="newLinkName" class="input" maxlength="40" placeholder="Portfolio" />
              </label>
              <label class="muted">Link URL
                <input id="newLinkUrl" class="input" placeholder="https://example.com" />
              </label>
              <button class="btn" id="addCustomLinkBtn">Add link</button>
            </div>

            <div class="muted" id="linksStatus" style="margin-top:8px"></div>

            <div style="margin-top:12px;display:flex;gap:8px">
              <button class="btn primary" id="saveProfileBtn">Save Profile</button>
            </div>
          </div>
        </div>
      `;

      const closeBtn = document.getElementById('closeProfileEditorBtn');
      const bg = document.getElementById('profileEditorBg');
      const saveBtn = document.getElementById('saveProfileBtn');
      const linksList = document.getElementById('customLinksList');
      const linksCountLabel = document.getElementById('linksCountLabel');
      const linksStatus = document.getElementById('linksStatus');
      const addLinkBtn = document.getElementById('addCustomLinkBtn');
      const newLinkNameInput = document.getElementById('newLinkName');
      const newLinkUrlInput = document.getElementById('newLinkUrl');
      let draftLinks = initialLinks.slice(0, 5);

      function setLinksStatus(message, isError){
        if(!linksStatus) return;
        linksStatus.textContent = message || '';
        linksStatus.style.color = isError ? 'var(--danger)' : 'var(--muted)';
      }

      function renderDraftLinks(){
        if(!linksList || !linksCountLabel) return;
        linksCountLabel.textContent = `${draftLinks.length} / 5`;
        if(!draftLinks.length){
          linksList.innerHTML = '<div class="muted">No links added yet.</div>';
          return;
        }
        linksList.innerHTML = draftLinks.map((link, idx)=>`
          <div data-link-row="${idx}" style="display:grid;grid-template-columns:1fr 1fr auto;gap:8px;align-items:end">
            <label class="muted">Name
              <input class="input" data-link-name-index="${idx}" maxlength="40" value="${escapeHtml(link.label)}" />
            </label>
            <label class="muted">Link
              <input class="input" data-link-url-index="${idx}" value="${escapeHtml(link.url)}" placeholder="https://example.com" />
            </label>
            <button class="btn danger" data-remove-link-index="${idx}">Remove</button>
          </div>
        `).join('');

        linksList.querySelectorAll('[data-remove-link-index]').forEach(btn => {
          btn.addEventListener('click', ()=>{
            const idx = Number(btn.getAttribute('data-remove-link-index'));
            if(Number.isNaN(idx)) return;
            draftLinks.splice(idx, 1);
            renderDraftLinks();
          });
        });
      }

      addLinkBtn.addEventListener('click', ()=>{
        const label = (newLinkNameInput.value || '').trim();
        const url = sanitizeUrl((newLinkUrlInput.value || '').trim());
        if(draftLinks.length >= 5){
          setLinksStatus('You can add up to 5 links.', true);
          return;
        }
        if(!label){
          setLinksStatus('Link name is required.', true);
          return;
        }
        if(!url){
          setLinksStatus('Enter a valid http(s) link.', true);
          return;
        }
        draftLinks.push({ label, url });
        newLinkNameInput.value = '';
        newLinkUrlInput.value = '';
        setLinksStatus('', false);
        renderDraftLinks();
      });

      closeBtn.addEventListener('click', closeModal);
      bg.addEventListener('click', (e)=>{ if(e.target === bg) closeModal(); });
      renderDraftLinks();

      saveBtn.addEventListener('click', async ()=>{
        const nextSocial = Array.from(document.querySelectorAll('[data-link-row]')).map(row => {
          const idx = Number(row.getAttribute('data-link-row'));
          const nameInput = document.querySelector(`[data-link-name-index="${idx}"]`);
          const urlInput = document.querySelector(`[data-link-url-index="${idx}"]`);
          return {
            label: (nameInput && nameInput.value ? nameInput.value : '').trim(),
            url: sanitizeUrl(urlInput && urlInput.value ? urlInput.value : '')
          };
        });
        const safeSocial = normalizeSocialLinks(nextSocial);

        const patch = {
          pronouns: document.getElementById('setPronouns').value.trim(),
          bio: document.getElementById('setBio').value.trim(),
          socialLinks: safeSocial
        };

        const bannerFile = document.getElementById('setBanner').files && document.getElementById('setBanner').files[0];
        const avatarFile = document.getElementById('setAvatar').files && document.getElementById('setAvatar').files[0];

        if(bannerFile){
          try { patch.bannerUrl = await fileToDataUrl(bannerFile); } catch(_e){}
        }

        if(avatarFile){
          try { patch.avatarUrl = await uploadAvatar(avatarFile); }
          catch(_e){
            try { patch.avatarUrl = await fileToDataUrl(avatarFile); } catch(_err){}
          }
        }

        try{
          saveBtn.disabled = true;
          saveBtn.textContent = 'Saving...';
          const nextProfile = setProfile(patch);
          await saveProfileToServer(nextProfile);
          closeModal();
          render();
        }catch(err){
          setLinksStatus((err && err.message) ? err.message : 'Failed to save profile', true);
        }finally{
          saveBtn.disabled = false;
          saveBtn.textContent = 'Save Profile';
        }
      });
    }

    function sanitizeDmUser(username){
      return String(username || '').trim().toLowerCase().replace(/[^a-z0-9_-]/g, '');
    }

    function getDmConvId(userA, userB){
      const clean = [sanitizeDmUser(userA), sanitizeDmUser(userB)].filter(Boolean).sort((a,b)=>a.localeCompare(b));
      if(clean.length < 2) return '';
      return `${clean[0]}__${clean[1]}`;
    }

    async function listDmConversations(username){
      const resp = await fetch(`${SAVE_URL}?action=listDMs`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ username })
      });
      const data = await resp.json().catch(()=>null);
      if(!resp.ok || !data || data.error) throw new Error((data && data.error) || 'Failed to load DMs');
      return Array.isArray(data.conversations) ? data.conversations : [];
    }

    async function fetchDmConversation(withUser){
      const me = getUser();
      if(!me) throw new Error('Sign in to use DMs');
      const convId = getDmConvId(me.username, withUser);
      if(!convId) return [];
      const resp = await fetch(`${SAVE_URL}?action=getDMConversation`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ convId })
      });
      const data = await resp.json().catch(()=>null);
      if(!resp.ok || !data || data.error) throw new Error((data && data.error) || 'Failed to load conversation');
      return Array.isArray(data.messages) ? data.messages : [];
    }

    async function sendDm(withUser, text){
      const me = getUser();
      if(!me) throw new Error('Sign in to DM');
      const convId = getDmConvId(me.username, withUser);
      if(!convId) throw new Error('Invalid user');
      const clean = String(text || '').trim();
      if(!clean) return;
      const entry = { from: me.username, to: withUser, message: clean.slice(0, 500), t: Date.now() };
      const resp = await fetch(`${SAVE_URL}?action=saveDM`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ convId, entry })
      });
      const data = await resp.json().catch(()=>null);
      if(!resp.ok || !data || data.error) throw new Error((data && data.error) || 'Failed to send message');
    }

    async function openDmsMenu(prefillUser = ''){
      const me = getUser();
      if(!me) return;
      modalRoot.innerHTML = `
        <div class="modalBg" id="dmBg">
          <div class="modalCard" style="width:min(920px,96vw)">
            <div style="display:flex;justify-content:space-between;align-items:center;gap:10px;margin-bottom:8px">
              <h3 style="margin:0">Direct Messages</h3>
              <button class="btn" id="closeDmBtn">Close</button>
            </div>
            <div class="dmLayout">
              <aside class="dmSidebar">
                <div style="display:flex;gap:6px">
                  <input id="dmNewUser" class="input" placeholder="username" />
                  <button class="btn" id="dmStartBtn">Open</button>
                </div>
                <button class="btn" id="dmRefreshBtn">Refresh</button>
                <div id="dmList" class="dmList"><div class="muted">Loading‚Ä¶</div></div>
              </aside>
              <section class="dmChat">
                <div><strong id="dmChatTitle">Select a conversation</strong></div>
                <div id="dmMsgs" class="dmMsgs"><div class="muted">No conversation selected.</div></div>
                <div style="display:flex;gap:8px">
                  <input id="dmInput" class="input" placeholder="Type a message" />
                  <button class="btn primary" id="dmSendBtn">Send</button>
                </div>
              </section>
            </div>
          </div>
        </div>
      `;

      const bg = document.getElementById('dmBg');
      const closeBtn = document.getElementById('closeDmBtn');
      const refreshBtn = document.getElementById('dmRefreshBtn');
      const startBtn = document.getElementById('dmStartBtn');
      const sendBtn = document.getElementById('dmSendBtn');
      const newUserInput = document.getElementById('dmNewUser');
      const listEl = document.getElementById('dmList');
      const msgsEl = document.getElementById('dmMsgs');
      const chatTitle = document.getElementById('dmChatTitle');
      const dmInput = document.getElementById('dmInput');

      let activeUser = '';

      function setActive(user){
        activeUser = sanitizeDmUser(user);
      }

      async function loadConversation(){
        if(!activeUser){
          chatTitle.textContent = 'Select a conversation';
          msgsEl.innerHTML = '<div class="muted">No conversation selected.</div>';
          return;
        }
        chatTitle.textContent = activeUser;
        msgsEl.innerHTML = '<div class="muted">Loading‚Ä¶</div>';
        try {
          const msgs = await fetchDmConversation(activeUser);
          if(!msgs.length){
            msgsEl.innerHTML = '<div class="muted">No messages yet.</div>';
            return;
          }
          msgsEl.innerHTML = msgs.map(msg=>{
            const mine = sanitizeDmUser(msg.from) === sanitizeDmUser(me.username);
            const label = mine ? 'You' : (msg.from || activeUser);
            return `<div class="dmBubble ${mine ? 'me' : ''}"><strong>${label}</strong><div>${String(msg.message || '')}</div></div>`;
          }).join('');
          msgsEl.scrollTop = msgsEl.scrollHeight;
        } catch(err){
          msgsEl.innerHTML = `<div class="muted">${err.message || 'Failed to load conversation'}</div>`;
        }
      }

      async function loadList(){
        listEl.innerHTML = '<div class="muted">Loading‚Ä¶</div>';
        try {
          const convos = await listDmConversations(me.username);
          if(!convos.length){
            listEl.innerHTML = '<div class="muted">No conversations yet.</div>';
            return;
          }
          listEl.innerHTML = convos.map(convo=>{
            const parts = Array.isArray(convo.participants) ? convo.participants : [];
            const other = parts.find(name => sanitizeDmUser(name) !== sanitizeDmUser(me.username)) || convo.otherUser || '';
            const normalized = sanitizeDmUser(other);
            const activeClass = normalized && normalized === activeUser ? 'active' : '';
            return `<div class="dmRow ${activeClass}" data-dm-user="${normalized}"><strong>${other || 'Unknown'}</strong><div class="muted">${convo.lastMessage || 'Open chat'}</div></div>`;
          }).join('');
          Array.from(listEl.querySelectorAll('[data-dm-user]')).forEach(node=>{
            node.addEventListener('click', async ()=>{
              setActive(node.getAttribute('data-dm-user'));
              await loadList();
              await loadConversation();
            });
          });
        } catch(err){
          listEl.innerHTML = `<div class="muted">${err.message || 'Failed to load DMs'}</div>`;
        }
      }

      closeBtn.addEventListener('click', closeModal);
      bg.addEventListener('click', (e)=>{ if(e.target === bg) closeModal(); });
      refreshBtn.addEventListener('click', async ()=>{ await loadList(); await loadConversation(); });

      startBtn.addEventListener('click', async ()=>{
        const target = sanitizeDmUser(newUserInput.value);
        if(!target || target === sanitizeDmUser(me.username)) return;
        setActive(target);
        await loadList();
        await loadConversation();
        dmInput.focus();
      });

      sendBtn.addEventListener('click', async ()=>{
        if(!activeUser) return;
        const text = dmInput.value || '';
        if(!text.trim()) return;
        try {
          await sendDm(activeUser, text);
          dmInput.value = '';
          await loadList();
          await loadConversation();
        } catch(err){
          alert(err.message || 'Failed to send message');
        }
      });

      dmInput.addEventListener('keydown', async (event)=>{
        if(event.key !== 'Enter') return;
        event.preventDefault();
        sendBtn.click();
      });

      if(prefillUser){
        newUserInput.value = prefillUser;
        setActive(prefillUser);
      }

      await loadList();
      await loadConversation();
    }

    function wireOnlineUserActions(){
      Array.from(document.querySelectorAll('[data-open-dm]')).forEach(node=>{
        node.addEventListener('click', (event)=>{
          event.preventDefault();
          event.stopPropagation();
          const user = node.getAttribute('data-open-dm') || '';
          if(!user || !getUser()) return;
          openDmsMenu(user);
        });
      });

      Array.from(document.querySelectorAll('[data-open-profile]')).forEach(node=>{
        node.addEventListener('click', (event)=>{
          event.preventDefault();
          const username = node.getAttribute('data-open-profile') || '';
          if(!username || !getUser()) return;
          openUserProfile(username);
        });
      });
    }

    function normalizeRoleId(value){
      return String(value || '').trim().toLowerCase().replace(/[^a-z0-9_-]/g, '-');
    }

    function normalizeBadgeId(value){
      return String(value || '').trim().toLowerCase().replace(/[^a-z0-9_-]/g, '-');
    }

    function defaultOwnerRoles(){
      return [
        { id:'owner', name:'Owner', color:'#f5c77d', icon:'üëë', priority:1000, permissions:['owner.panel','moderation.access','moderation.tools','roles.manage','badges.manage','commands.run'] },
        { id:'moderator', name:'Moderator', color:'#85c6ff', icon:'üõ°', priority:700, permissions:['moderation.access','moderation.tools'] },
        { id:'member', name:'Member', color:'#a9b9d3', icon:'', priority:10, permissions:[] }
      ];
    }

    function normalizeRoleRecord(role){
      if(!role) return null;
      const id = normalizeRoleId(role.id || role.name);
      if(!id) return null;
      return {
        id,
        name: String(role.name || id).trim() || id,
        color: String(role.color || '#a9b9d3').trim() || '#a9b9d3',
        icon: String(role.icon || '').trim(),
        priority: Number.isFinite(Number(role.priority)) ? Number(role.priority) : 10,
        permissions: Array.isArray(role.permissions) ? role.permissions.map(v=>String(v).trim()).filter(Boolean) : []
      };
    }

    function normalizeBadgeRecord(badge){
      if(!badge) return null;
      const id = normalizeBadgeId(badge.id || badge.name);
      if(!id) return null;
      return {
        id,
        name: String(badge.name || id).trim() || id,
        icon: String(badge.icon || 'üèÖ').trim() || 'üèÖ',
        color: String(badge.color || '#a9b9d3').trim() || '#a9b9d3',
        tooltip: String(badge.tooltip || '').trim(),
        showInComments: badge.showInComments !== false
      };
    }

    function dedupeItems(list, normalizer){
      const out = [];
      const seen = new Set();
      (Array.isArray(list) ? list : []).forEach(item=>{
        const key = normalizer(item);
        if(!key || seen.has(key)) return;
        seen.add(key);
        out.push(key);
      });
      return out;
    }

    function applyOwnerState(payload){
      const incoming = payload && typeof payload === 'object' ? payload : {};
      const roles = (Array.isArray(incoming.roles) ? incoming.roles : []).map(normalizeRoleRecord).filter(Boolean);
      const badges = (Array.isArray(incoming.badges) ? incoming.badges : []).map(normalizeBadgeRecord).filter(Boolean);
      const userRoles = incoming.userRoles && typeof incoming.userRoles === 'object' ? incoming.userRoles : {};
      const userBadges = incoming.userBadges && typeof incoming.userBadges === 'object' ? incoming.userBadges : {};
      const defaults = defaultOwnerRoles();
      if(!roles.some(r=>r.id==='owner')) roles.push(defaults[0]);
      if(!roles.some(r=>r.id==='moderator')) roles.push(defaults[1]);
      if(!roles.some(r=>r.id==='member')) roles.push(defaults[2]);
      roles.sort((a,b)=> Number(b.priority || 0) - Number(a.priority || 0));
      ownerState = { roles, badges, userRoles, userBadges, loaded: true };
    }

    async function refreshOwnerState(force = false){
      if(ownerState.loaded && !force) return ownerState;
      try{
        const resp = await fetch(`${OWNER_CONTROL_URL}?action=ownerControlGet`, { cache: 'no-store' });
        const data = await resp.json().catch(()=>null);
        if(resp.ok && data && data.ok && data.state){
          applyOwnerState(data.state);
          return ownerState;
        }
      }catch(_e){}
      applyOwnerState({ roles: defaultOwnerRoles(), badges: [], userRoles: {}, userBadges: {} });
      return ownerState;
    }

    async function saveOwnerState(){
      const token = getToken();
      if(!token) throw new Error('Sign in as owner');
      const payload = {
        roles: ownerState.roles,
        badges: ownerState.badges,
        userRoles: ownerState.userRoles,
        userBadges: ownerState.userBadges
      };
      const resp = await fetch(`${OWNER_CONTROL_URL}?action=ownerControlSave`, {
        method: 'POST',
        headers: { 'Content-Type':'application/json', 'Authorization': `Bearer ${token}` },
        body: JSON.stringify({ state: payload })
      });
      const data = await resp.json().catch(()=>null);
      if(!resp.ok || !data || !data.ok) throw new Error((data && data.error) || 'Failed to save owner panel data');
      if(data.state) applyOwnerState(data.state);
    }

    function knownUsernames(){
      const map = getCache();
      const list = Object.keys(map || {}).filter(Boolean);
      const me = getUser();
      if(me && me.username) list.push(me.username);
      return Array.from(new Set(list.map(name=>String(name || '').trim()).filter(Boolean))).sort((a,b)=>a.localeCompare(b));
    }

    async function promoteModerator(username){
      const token = getToken();
      if(!token) throw new Error('Sign in as owner');
      const resp = await fetch(`${USERS_URL}?action=addModerator`, {
        method: 'POST',
        headers: { 'Content-Type':'application/json', 'Authorization': `Bearer ${token}` },
        body: JSON.stringify({ username })
      });
      const data = await resp.json().catch(()=>null);
      if(!resp.ok || !data || !data.ok) throw new Error((data && data.error) || 'Failed to promote moderator');
      return data.user || { username };
    }

    async function demoteModerator(username){
      const token = getToken();
      if(!token) throw new Error('Sign in as owner');
      const resp = await fetch(`${USERS_URL}?action=removeModerator`, {
        method: 'POST',
        headers: { 'Content-Type':'application/json', 'Authorization': `Bearer ${token}` },
        body: JSON.stringify({ username })
      });
      const data = await resp.json().catch(()=>null);
      if(!resp.ok || !data || !data.ok) throw new Error((data && data.error) || 'Failed to remove moderator');
      return data.user || { username };
    }

    async function runOwnerCommand(raw){
      const text = String(raw || '').trim();
      if(!text) throw new Error('Enter a command');
      const cmd = text.startsWith('?') ? text.slice(1) : text;
      const parts = cmd.split(/\s+/).filter(Boolean);
      const name = (parts.shift() || '').toLowerCase();
      if(name === 'cmds') return 'Available: cmds, mod, unmod, giverole, removerole, givebadge, removebadge';
      if(name === 'mod'){
        const username = parts[0];
        if(!username) throw new Error('Usage: mod <user>');
        await promoteModerator(username);
        ownerState.userRoles[String(username).toLowerCase()] = dedupeItems([...(ownerState.userRoles[String(username).toLowerCase()] || []), 'moderator'], normalizeRoleId);
        await saveOwnerState();
        return `${username} promoted to moderator`;
      }
      if(name === 'unmod'){
        const username = parts[0];
        if(!username) throw new Error('Usage: unmod <user>');
        await demoteModerator(username);
        ownerState.userRoles[String(username).toLowerCase()] = dedupeItems((ownerState.userRoles[String(username).toLowerCase()] || []).filter(item=>normalizeRoleId(item)!=='moderator'), normalizeRoleId);
        await saveOwnerState();
        return `${username} removed from moderators`;
      }
      if(name === 'giverole' || name === 'removerole'){
        const [username, roleId] = parts;
        if(!username || !roleId) throw new Error(`Usage: ${name} <user> <role>`);
        const key = String(username).toLowerCase();
        const roleKey = normalizeRoleId(roleId);
        const current = dedupeItems(ownerState.userRoles[key] || [], normalizeRoleId);
        ownerState.userRoles[key] = name === 'giverole'
          ? dedupeItems([...current, roleKey], normalizeRoleId)
          : dedupeItems(current.filter(item=>normalizeRoleId(item)!==roleKey), normalizeRoleId);
        await saveOwnerState();
        return `${name === 'giverole' ? 'Assigned' : 'Removed'} role ${roleKey} ${name === 'giverole' ? 'to' : 'from'} ${username}`;
      }
      if(name === 'givebadge' || name === 'removebadge'){
        const [username, badgeId] = parts;
        if(!username || !badgeId) throw new Error(`Usage: ${name} <user> <badge>`);
        const key = String(username).toLowerCase();
        const badgeKey = normalizeBadgeId(badgeId);
        const current = dedupeItems(ownerState.userBadges[key] || [], normalizeBadgeId);
        ownerState.userBadges[key] = name === 'givebadge'
          ? dedupeItems([...current, badgeKey], normalizeBadgeId)
          : dedupeItems(current.filter(item=>normalizeBadgeId(item)!==badgeKey), normalizeBadgeId);
        await saveOwnerState();
        return `${name === 'givebadge' ? 'Assigned' : 'Removed'} badge ${badgeKey} ${name === 'givebadge' ? 'to' : 'from'} ${username}`;
      }
      throw new Error('Unknown command. Use ?cmds');
    }

    async function openOwnerPanel(){
      const me = getUser();
      if(!isOwnerUser(me)) return;
      await refreshOwnerState(true);
      modalRoot.innerHTML = `
        <div class="ownerOverlay" id="ownerPanelOverlay">
          <div class="ownerCard">
            <aside class="ownerSide">
              <button class="ownerTab active" data-owner-tab="roles">Role Management</button>
              <button class="ownerTab" data-owner-tab="badges">Badge Management</button>
              <button class="ownerTab" data-owner-tab="assign">User Assignment</button>
              <button class="ownerTab" data-owner-tab="mods">Moderator Management</button>
              <button class="ownerTab" data-owner-tab="commands">Command Console</button>
              <button class="btn" id="closeOwnerPanelBtn" style="margin-top:8px">Close</button>
            </aside>
            <section class="ownerBody" id="ownerPanelBody"></section>
          </div>
        </div>
      `;
      const overlay = document.getElementById('ownerPanelOverlay');
      const closeBtn = document.getElementById('closeOwnerPanelBtn');
      const tabs = Array.from(document.querySelectorAll('[data-owner-tab]'));
      const body = document.getElementById('ownerPanelBody');

      function renderRolesTab(){
        const roles = ownerState.roles.slice().sort((a,b)=>Number(b.priority||0)-Number(a.priority||0));
        body.innerHTML = `<h3 style="margin:0">Role Management</h3>
          <div class="ownerItem"><div style="display:grid;gap:6px;width:100%"><input id="newRoleName" class="input" placeholder="Role name" /><div style="display:flex;gap:6px;flex-wrap:wrap"><input id="newRoleColor" class="input" style="max-width:110px" value="#a9b9d3" /><input id="newRoleIcon" class="input" style="max-width:120px" placeholder="Icon" /><input id="newRolePriority" class="input" style="max-width:120px" type="number" value="100" placeholder="Priority" /><button class="btn" id="createRoleBtn">Create Role</button></div></div></div>
          <div class="ownerList" id="ownerRolesList"></div>`;
        const listEl = body.querySelector('#ownerRolesList');
        roles.forEach(role=>{
          const row = document.createElement('div');
          row.className = 'ownerItem';
          row.innerHTML = `<div><strong>${role.icon ? role.icon + ' ' : ''}${role.name}</strong><div class="muted">id: ${role.id} ‚Ä¢ priority ${role.priority}</div></div><div style="display:flex;gap:6px"><button class="btn" data-role-edit="${role.id}">Edit</button><button class="btn" data-role-del="${role.id}" ${role.id==='owner'?'disabled':''}>Delete</button></div>`;
          listEl.appendChild(row);
        });
        body.querySelector('#createRoleBtn').addEventListener('click', async ()=>{
          const name = body.querySelector('#newRoleName').value.trim();
          const color = body.querySelector('#newRoleColor').value.trim() || '#a9b9d3';
          const icon = body.querySelector('#newRoleIcon').value.trim();
          const priority = Number(body.querySelector('#newRolePriority').value || 100);
          const record = normalizeRoleRecord({ name, color, icon, priority, permissions: [] });
          if(!record) return alert('Invalid role');
          if(ownerState.roles.some(item=>item.id===record.id)) return alert('Role already exists');
          ownerState.roles.push(record);
          await saveOwnerState();
          renderRolesTab();
        });
        Array.from(body.querySelectorAll('[data-role-edit]')).forEach(btn=>{
          btn.addEventListener('click', async ()=>{
            const roleId = btn.getAttribute('data-role-edit');
            const role = ownerState.roles.find(item=>item.id===roleId);
            if(!role) return;
            const name = prompt('Role name', role.name); if(name===null) return;
            const color = prompt('Role color', role.color); if(color===null) return;
            const icon = prompt('Role icon', role.icon || ''); if(icon===null) return;
            const priority = prompt('Priority', String(role.priority || 0)); if(priority===null) return;
            const updated = normalizeRoleRecord({ ...role, name, color, icon, priority: Number(priority) || 0 });
            if(!updated) return alert('Invalid role');
            const idx = ownerState.roles.findIndex(item=>item.id===roleId);
            ownerState.roles[idx] = updated;
            await saveOwnerState();
            renderRolesTab();
          });
        });
        Array.from(body.querySelectorAll('[data-role-del]')).forEach(btn=>{
          btn.addEventListener('click', async ()=>{
            const roleId = btn.getAttribute('data-role-del');
            if(roleId === 'owner') return;
            if(!confirm(`Delete role ${roleId}?`)) return;
            ownerState.roles = ownerState.roles.filter(item=>item.id!==roleId);
            Object.keys(ownerState.userRoles).forEach(key=>{
              ownerState.userRoles[key] = dedupeItems((ownerState.userRoles[key] || []).filter(item=>normalizeRoleId(item)!==roleId), normalizeRoleId);
            });
            await saveOwnerState();
            renderRolesTab();
          });
        });
      }

      function renderBadgesTab(){
        const badges = ownerState.badges.slice();
        body.innerHTML = `<h3 style="margin:0">Badge Management</h3>
          <div class="ownerItem"><div style="display:grid;gap:6px;width:100%"><input id="newBadgeName" class="input" placeholder="Badge name" /><div style="display:flex;gap:6px;flex-wrap:wrap"><input id="newBadgeIcon" class="input" style="max-width:120px" value="üèÖ" /><input id="newBadgeColor" class="input" style="max-width:110px" value="#a9b9d3" /><input id="newBadgeTip" class="input" placeholder="Tooltip" /><button class="btn" id="createBadgeBtn">Create Badge</button></div></div></div>
          <div class="ownerList" id="ownerBadgesList"></div>`;
        const listEl = body.querySelector('#ownerBadgesList');
        badges.forEach(badge=>{
          const row = document.createElement('div');
          row.className = 'ownerItem';
          row.innerHTML = `<div><strong>${badge.icon} ${badge.name}</strong><div class="muted">id: ${badge.id} ${badge.tooltip ? '‚Ä¢ ' + badge.tooltip : ''}</div></div><div style="display:flex;gap:6px"><button class="btn" data-badge-edit="${badge.id}">Edit</button><button class="btn" data-badge-del="${badge.id}">Delete</button></div>`;
          listEl.appendChild(row);
        });
        body.querySelector('#createBadgeBtn').addEventListener('click', async ()=>{
          const record = normalizeBadgeRecord({
            name: body.querySelector('#newBadgeName').value.trim(),
            icon: body.querySelector('#newBadgeIcon').value.trim() || 'üèÖ',
            color: body.querySelector('#newBadgeColor').value.trim() || '#a9b9d3',
            tooltip: body.querySelector('#newBadgeTip').value.trim()
          });
          if(!record) return alert('Invalid badge');
          if(ownerState.badges.some(item=>item.id===record.id)) return alert('Badge already exists');
          ownerState.badges.push(record);
          await saveOwnerState();
          renderBadgesTab();
        });
        Array.from(body.querySelectorAll('[data-badge-edit]')).forEach(btn=>{
          btn.addEventListener('click', async ()=>{
            const badgeId = btn.getAttribute('data-badge-edit');
            const badge = ownerState.badges.find(item=>item.id===badgeId);
            if(!badge) return;
            const name = prompt('Badge name', badge.name); if(name===null) return;
            const icon = prompt('Badge icon', badge.icon); if(icon===null) return;
            const color = prompt('Badge color', badge.color); if(color===null) return;
            const tooltip = prompt('Tooltip', badge.tooltip || ''); if(tooltip===null) return;
            const updated = normalizeBadgeRecord({ ...badge, name, icon, color, tooltip });
            if(!updated) return alert('Invalid badge');
            const idx = ownerState.badges.findIndex(item=>item.id===badgeId);
            ownerState.badges[idx] = updated;
            await saveOwnerState();
            renderBadgesTab();
          });
        });
        Array.from(body.querySelectorAll('[data-badge-del]')).forEach(btn=>{
          btn.addEventListener('click', async ()=>{
            const badgeId = btn.getAttribute('data-badge-del');
            if(!confirm(`Delete badge ${badgeId}?`)) return;
            ownerState.badges = ownerState.badges.filter(item=>item.id!==badgeId);
            Object.keys(ownerState.userBadges).forEach(key=>{
              ownerState.userBadges[key] = dedupeItems((ownerState.userBadges[key] || []).filter(item=>normalizeBadgeId(item)!==badgeId), normalizeBadgeId);
            });
            await saveOwnerState();
            renderBadgesTab();
          });
        });
      }

      function renderAssignTab(){
        const users = knownUsernames();
        body.innerHTML = `<h3 style="margin:0">User Assignment</h3>
          <div class="ownerItem"><div style="display:grid;gap:6px;width:100%"><select id="assignUser" class="select">${users.map(name=>`<option value="${name}">${name}</option>`).join('')}</select><div style="display:flex;gap:6px;flex-wrap:wrap"><select id="assignRole" class="select">${ownerState.roles.map(role=>`<option value="${role.id}">${role.id}</option>`).join('')}</select><button class="btn" id="assignRoleBtn">Assign Role</button><button class="btn" id="removeRoleBtn">Remove Role</button></div><div style="display:flex;gap:6px;flex-wrap:wrap"><select id="assignBadge" class="select">${ownerState.badges.map(badge=>`<option value="${badge.id}">${badge.id}</option>`).join('')}</select><button class="btn" id="assignBadgeBtn">Assign Badge</button><button class="btn" id="removeBadgeBtn">Remove Badge</button></div></div></div>
          <div class="muted" id="assignStatus">Select a user and update role/badge assignments.</div>`;
        const status = body.querySelector('#assignStatus');
        const getValues = ()=>({
          username: (body.querySelector('#assignUser').value || '').trim(),
          roleId: normalizeRoleId(body.querySelector('#assignRole').value || ''),
          badgeId: normalizeBadgeId(body.querySelector('#assignBadge') ? body.querySelector('#assignBadge').value || '' : '')
        });
        body.querySelector('#assignRoleBtn').addEventListener('click', async ()=>{
          const { username, roleId } = getValues();
          if(!username || !roleId) return;
          const key = username.toLowerCase();
          ownerState.userRoles[key] = dedupeItems([...(ownerState.userRoles[key] || []), roleId], normalizeRoleId);
          await saveOwnerState();
          status.textContent = `Assigned role ${roleId} to ${username}`;
        });
        body.querySelector('#removeRoleBtn').addEventListener('click', async ()=>{
          const { username, roleId } = getValues();
          if(!username || !roleId) return;
          const key = username.toLowerCase();
          ownerState.userRoles[key] = dedupeItems((ownerState.userRoles[key] || []).filter(item=>normalizeRoleId(item)!==roleId), normalizeRoleId);
          await saveOwnerState();
          status.textContent = `Removed role ${roleId} from ${username}`;
        });
        const assignBadgeBtn = body.querySelector('#assignBadgeBtn');
        const removeBadgeBtn = body.querySelector('#removeBadgeBtn');
        if(assignBadgeBtn){
          assignBadgeBtn.addEventListener('click', async ()=>{
            const { username, badgeId } = getValues();
            if(!username || !badgeId) return;
            const key = username.toLowerCase();
            ownerState.userBadges[key] = dedupeItems([...(ownerState.userBadges[key] || []), badgeId], normalizeBadgeId);
            await saveOwnerState();
            status.textContent = `Assigned badge ${badgeId} to ${username}`;
          });
        }
        if(removeBadgeBtn){
          removeBadgeBtn.addEventListener('click', async ()=>{
            const { username, badgeId } = getValues();
            if(!username || !badgeId) return;
            const key = username.toLowerCase();
            ownerState.userBadges[key] = dedupeItems((ownerState.userBadges[key] || []).filter(item=>normalizeBadgeId(item)!==badgeId), normalizeBadgeId);
            await saveOwnerState();
            status.textContent = `Removed badge ${badgeId} from ${username}`;
          });
        }
      }

      async function renderModsTab(){
        body.innerHTML = `<h3 style="margin:0">Moderator Management</h3>
          <div class="ownerItem"><div style="display:flex;gap:6px;flex-wrap:wrap;width:100%"><input id="modUserInput" class="input" placeholder="username" /><button class="btn" id="addModBtn">Add Moderator</button><button class="btn" id="removeModBtn">Remove Moderator</button></div></div>
          <div class="muted" id="modsStatus">Use actions above to manage moderators.</div>
          <div class="ownerList" id="modsList"></div>`;
        const status = body.querySelector('#modsStatus');
        const listEl = body.querySelector('#modsList');
        const refreshList = async ()=>{
          const resp = await fetch(`${USERS_URL}?action=staff`);
          const data = await resp.json().catch(()=>null);
          const mods = data && Array.isArray(data.moderators) ? data.moderators : [];
          listEl.innerHTML = mods.length
            ? mods.map(mod=>`<div class="ownerItem"><div><strong>${mod.username}</strong></div></div>`).join('')
            : '<div class="muted">No moderators found.</div>';
        };
        body.querySelector('#addModBtn').addEventListener('click', async ()=>{
          const username = (body.querySelector('#modUserInput').value || '').trim();
          if(!username) return;
          try{
            await promoteModerator(username);
            const key = username.toLowerCase();
            ownerState.userRoles[key] = dedupeItems([...(ownerState.userRoles[key] || []), 'moderator'], normalizeRoleId);
            await saveOwnerState();
            status.textContent = `${username} promoted to moderator`;
            await refreshList();
          }catch(err){ status.textContent = err && err.message ? err.message : 'Failed to add moderator'; }
        });
        body.querySelector('#removeModBtn').addEventListener('click', async ()=>{
          const username = (body.querySelector('#modUserInput').value || '').trim();
          if(!username) return;
          try{
            await demoteModerator(username);
            const key = username.toLowerCase();
            ownerState.userRoles[key] = dedupeItems((ownerState.userRoles[key] || []).filter(item=>normalizeRoleId(item)!=='moderator'), normalizeRoleId);
            await saveOwnerState();
            status.textContent = `${username} removed from moderators`;
            await refreshList();
          }catch(err){ status.textContent = err && err.message ? err.message : 'Failed to remove moderator'; }
        });
        await refreshList();
      }

      function renderCommandsTab(){
        body.innerHTML = `<h3 style="margin:0">Command Console</h3>
          <div class="muted">Commands: <strong>?cmds</strong>, <strong>mod user</strong>, <strong>unmod user</strong>, <strong>giverole user role</strong>, <strong>removerole user role</strong>, <strong>givebadge user badge</strong>, <strong>removebadge user badge</strong></div>
          <form id="ownerCommandForm" style="display:flex;gap:8px"><input id="ownerCommandInput" class="input" placeholder="giverole user moderator" /><button class="btn" type="submit">Run</button></form>
          <div class="muted" id="ownerCommandStatus"></div>`;
        const form = body.querySelector('#ownerCommandForm');
        const input = body.querySelector('#ownerCommandInput');
        const status = body.querySelector('#ownerCommandStatus');
        form.addEventListener('submit', async (event)=>{
          event.preventDefault();
          const cmd = input.value.trim();
          if(!cmd){ status.textContent = 'Enter a command'; return; }
          status.textContent = 'Running...';
          try{
            const result = await runOwnerCommand(cmd);
            status.textContent = result;
            input.value = '';
          }catch(err){ status.textContent = err && err.message ? err.message : 'Command failed'; }
        });
      }

      async function renderTab(tab){
        tabs.forEach(node=> node.classList.toggle('active', node.getAttribute('data-owner-tab') === tab));
        if(tab === 'roles') return renderRolesTab();
        if(tab === 'badges') return renderBadgesTab();
        if(tab === 'assign') return renderAssignTab();
        if(tab === 'mods') return renderModsTab();
        return renderCommandsTab();
      }

      tabs.forEach(node=>{
        node.addEventListener('click', ()=> renderTab(node.getAttribute('data-owner-tab') || 'roles'));
      });
      closeBtn.addEventListener('click', closeModal);
      overlay.addEventListener('click', (event)=>{ if(event.target === overlay) closeModal(); });
      await renderTab('roles');
    }

    async function refreshCommunityStats(){
      const countEl = document.getElementById('currentUsersValue');
      const ownerEl = document.getElementById('staffOwnerValue');
      const modsWrap = document.getElementById('staffModerators');
      if(!countEl || !ownerEl || !modsWrap) return;

      countEl.textContent = '...';
      ownerEl.textContent = 'Loading...';
      modsWrap.innerHTML = '<span class="staffPill">Loading...</span>';

      let userCount = null;
      let ownerRecord = null;
      let moderators = [];
      let apiError = false;

      const endpoints = usersEndpointCandidates();

      for(const endpoint of endpoints){
        try{
          const resp = await fetch(`${endpoint}?action=list`, { cache: 'no-store' });
          const data = await resp.json().catch(()=>null);
          if(!resp.ok || !data || !data.ok) throw new Error('Failed list fetch');
          if(Number.isFinite(Number(data.count))) userCount = Number(data.count);
          break;
        }catch(_e){ apiError = true; }
      }

      for(const endpoint of endpoints){
        try{
          const resp = await fetch(`${endpoint}?action=staff`, { cache: 'no-store' });
          const data = await resp.json().catch(()=>null);
          if(!resp.ok || !data || !data.ok) throw new Error('Failed staff fetch');
          ownerRecord = data.owner || null;
          moderators = Array.isArray(data.moderators) ? data.moderators : [];
          apiError = false;
          break;
        }catch(_e){ apiError = true; }
      }

      let fallbackUsers = null;
      if(userCount === null || !ownerRecord || !moderators.length || apiError){
        fallbackUsers = await fetchUsersFallback().catch(()=>null);
      }

      if(userCount === null && fallbackUsers && fallbackUsers.length){
        userCount = fallbackUsers.length;
        countEl.title = 'Loaded from users fallback';
      }else{
        countEl.removeAttribute('title');
      }

      if(!ownerRecord){
        ownerRecord = getOwnerFromFallback(fallbackUsers) || { username: OWNER_USERNAME };
      }
      if(!moderators.length && fallbackUsers){
        moderators = getModeratorsFromFallback(fallbackUsers);
      }

      countEl.textContent = Number.isFinite(Number(userCount)) ? String(userCount) : '‚Äî';
      ownerEl.textContent = ownerRecord && ownerRecord.username ? ownerRecord.username : OWNER_USERNAME;

      modsWrap.innerHTML = '';
      if(!moderators.length){
        const span = document.createElement('span');
        span.className = 'staffPill' + (apiError ? ' staffError' : '');
        span.textContent = apiError ? 'Staff unavailable' : 'None';
        modsWrap.appendChild(span);
      }else{
        moderators.forEach(mod=>{
          const span = document.createElement('span');
          span.className = 'staffPill';
          span.textContent = (mod && mod.username) ? mod.username : 'Unknown';
          modsWrap.appendChild(span);
        });
      }
    }

    function wireTopbar(){
      const user = getUser();
      const authed = !!user;

      const logoutBtn = document.getElementById('logoutBtn');
      const movesetsBtn = document.getElementById('movesetsBtn');
      const forumsBtn = document.getElementById('forumsBtn');
      const dmsBtn = document.getElementById('dmsBtn');
      const ownerPanelBtn = document.getElementById('ownerPanelBtn');
      const settingsBtn = document.getElementById('settingsBtn');
      const themeBtn = document.getElementById('themeBtn');

      if(logoutBtn) logoutBtn.addEventListener('click', ()=>{ stopPresence(); setToken(''); });
      if(themeBtn) themeBtn.addEventListener('click', toggleTheme);

      movesetsBtn.addEventListener('click', ()=>{
        if(!authed) return;
        transitionTo('Moveset.html');
      });

      forumsBtn.addEventListener('click', ()=>{
        alert('Skillbuilder Forums is a placeholder right now.');
      });

      dmsBtn.addEventListener('click', ()=>{
        if(!authed) return;
        openDmsMenu();
      });

      if(ownerPanelBtn){
        ownerPanelBtn.addEventListener('click', ()=>{
          if(!authed || !isOwnerUser(user)) return;
          openOwnerPanel();
        });
      }

      settingsBtn.addEventListener('click', ()=>{
        if(!authed) return;
        openSettings();
      });
    }

    function wireAuthHero(){
      const status = document.getElementById('authStatus');
      const signinBtn = document.getElementById('signinBtn');
      const signupBtn = document.getElementById('signupBtn');

      async function run(mode){
        const username = (document.getElementById('authUser').value || '').trim();
        const password = document.getElementById('authPass').value || '';
        if(!username || !password){ status.textContent = 'Username and password are required.'; return; }
        try {
          const data = await auth(mode, username, password);
          if(data && data.token) setToken(data.token);
        } catch(err){
          status.textContent = err && err.message ? err.message : 'Authentication failed.';
        }
      }

      signinBtn.addEventListener('click', ()=> run('login'));
      signupBtn.addEventListener('click', ()=> run('signup'));
    }

    function wireAuthedMain(){
      const compactOpen = document.getElementById('compactProfileOpen');

      compactOpen.addEventListener('click', openProfileEditor);
      wireOnlineUserActions();
      refreshUserDirectory();
      refreshCommunityStats();
    }

    async function render(){
      applyTheme(getTheme());
      const user = getUser();

      topbarRoot.innerHTML = renderTopbar();
      wireTopbar();

      if(!user){
        stopPresence();
        onlineUsers = [];
        mainRoot.innerHTML = renderAuthHero();
        wireAuthHero();
        return;
      }

      await syncProfileFromServer();

      mainRoot.innerHTML = renderAuthedMain(user, getProfile());
      wireAuthedMain();
      startPresence();
    }

    window.addEventListener('beforeunload', ()=>{
      presenceLeave();
    });

    render();
  </script>
</body>
</html>