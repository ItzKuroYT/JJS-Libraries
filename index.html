<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>JJS Library — Search & Share</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&family=General+Sans:wght@400;500;600&display=swap');
    :root{
      --bg-top:#030616;
      --bg-bottom:#160636;
      --aurora-left:#73efff;
      --aurora-right:#8a64ff;
      --surface:rgba(8,12,30,0.95);
      --surface-alt:rgba(12,18,42,0.92);
      --panel:rgba(7,12,28,0.92);
      --panel-soft:rgba(255,255,255,0.05);
      --border:rgba(255,255,255,0.08);
      --muted:#9caecb;
      --text:#f5f7ff;
      --accent:#7ef9c2;
      --accent-strong:#7b5bff;
      --accent-fade:rgba(126,249,194,0.18);
      --glow:0 32px 90px rgba(18, 15, 101, 0.65);
      --ratingPositive:#46f0a2;
      --ratingNeutral:#ffd166;
      --ratingNegative:#ff7b7b;
      --glass:rgba(255,255,255,0.08);
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;font-family:'Space Grotesk','General Sans',sans-serif;background:var(--bg-bottom);color:var(--text)}
    body{
      min-height:100vh;
      background-image:
        radial-gradient(circle at 18% 22%,rgba(84,224,199,0.22),transparent 50%),
        radial-gradient(circle at 80% 10%,rgba(138,100,255,0.28),transparent 48%),
        linear-gradient(180deg,var(--bg-top) 0%,var(--bg-bottom) 100%);
    }
    body::before{
      content:'';
      position:fixed;
      inset:0;
      pointer-events:none;
      background:radial-gradient(circle at 60% 12%,rgba(255,255,255,0.08),transparent 55%);
      mix-blend-mode:screen;
      opacity:0.6;
    }
    .container{
      width:min(95vw,1400px);
      margin:34px auto 64px;
      padding:48px 52px;
      background:var(--surface);
      border:1px solid var(--border);
      border-radius:36px;
      box-shadow:var(--glow);
      position:relative;
      overflow:hidden;
    }
    .container::after{
      content:'';
      position:absolute;
      inset:18px;
      border-radius:24px;
      border:1px solid rgba(255,255,255,0.03);
      pointer-events:none;
    }
    header{display:flex;gap:20px;align-items:flex-start;justify-content:space-between}
    h1{font-size:34px;font-weight:600;margin:0;letter-spacing:-0.02em}
    .credits{font-size:15px;color:var(--muted);margin-top:4px;max-width:440px}
    .small{font-size:13px;color:var(--muted)}
    .controls{display:flex;flex-direction:column;gap:18px;margin-top:26px;padding:22px;background:var(--panel);border-radius:26px;border:1px solid rgba(255,255,255,0.06);box-shadow:0 20px 45px rgba(5,8,25,0.55)}
    .controlRow{display:flex;gap:14px;flex-wrap:wrap;align-items:center;width:100%}
    .controlRow--primary{align-items:flex-start}
    .controlRow--actions{justify-content:flex-end}
    input,textarea,select{font-family:inherit;font-size:15px;color:var(--text);background:rgba(8,17,40,0.85);border:1px solid rgba(255,255,255,0.08);border-radius:14px;padding:12px 14px;outline:none;transition:border-color 0.2s ease,box-shadow 0.2s ease}
    input:focus,textarea:focus{border-color:var(--accent);box-shadow:0 0 0 2px rgba(126,249,194,0.2)}
    input::placeholder,textarea::placeholder{color:rgba(230,238,246,0.55)}
    input.search{flex:1 1 260px;min-width:240px;background:rgba(10,20,46,0.92)}
    #authBox{display:flex;gap:10px;flex-wrap:wrap;align-items:center;background:rgba(255,255,255,0.02);padding:10px 12px;border-radius:18px;border:1px solid rgba(255,255,255,0.05)}
    #authBox input{flex:1 1 140px;min-width:140px}
    #userLabel{min-width:130px;text-align:right;color:var(--muted)}
    button{background:linear-gradient(115deg,var(--accent-strong),#1cc9ff);border:none;color:#050914;padding:10px 18px;border-radius:14px;cursor:pointer;font-weight:600;letter-spacing:0.01em;box-shadow:0 10px 24px rgba(12,8,35,0.5);transition:transform 0.2s ease,box-shadow 0.2s ease}
    button:hover{transform:translateY(-2px);box-shadow:0 16px 28px rgba(12,8,35,0.65)}
    button:active{transform:translateY(1px)}
    button.ghost{background:transparent;color:var(--text);border:1px solid rgba(255,255,255,0.12);box-shadow:none}
    button.ghost:hover{color:var(--accent);border-color:var(--accent)}
    .tagBar{margin-top:16px;padding:18px;background:var(--panel);border-radius:22px;border:1px solid rgba(255,255,255,0.05);display:flex;flex-direction:column;gap:12px}
    .tagPicker{display:flex;gap:10px;flex-wrap:wrap}
    .tagInput{display:flex;gap:10px;flex-wrap:wrap}
    .communityStrip{margin:10px 0;padding:10px;border-radius:20px;background:linear-gradient(120deg,rgba(123,91,255,0.14),rgba(8,19,42,0.8));border:1px solid rgba(255,255,255,0.07);display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:14px;align-items:stretch}
    .statBlock{display:flex;flex-direction:column;gap:4px;padding:10px 12px;border-radius:14px;background:rgba(7,12,30,0.48);border:1px solid rgba(255,255,255,0.04);position:relative;overflow:hidden}
    .statBlock::after{content:'';position:absolute;inset:0;border-radius:10px;border:1px solid rgba(255,255,255,0.025);pointer-events:none}
    .statLabel{font-size:9px;letter-spacing:0.16em;text-transform:uppercase;color:var(--muted)}
    .statValue{font-size:21px;font-weight:600}
    .staffPanel{display:flex;flex-direction:column;gap:12px}
    .staffBlock{display:flex;flex-direction:column;gap:6px}
    .staffPills{display:flex;flex-wrap:wrap;gap:8px;min-height:30px}
    .staffPill{padding:6px 14px;border-radius:999px;background:rgba(255,255,255,0.08);font-size:13px;font-weight:500;border:1px solid rgba(255,255,255,0.06)}
    .staffPill--owner{background:var(--accent-fade);color:var(--accent)}
    .list{margin-top:26px;display:grid;grid-template-columns:repeat(auto-fit,minmax(320px,1fr));gap:20px;transition:opacity 0.28s ease,transform 0.28s ease;will-change:opacity,transform}
    .list.list--fading{opacity:0;transform:translateY(12px)}
    .paginationBar{margin-top:28px;display:flex;justify-content:center;align-items:center;gap:8px;flex-wrap:wrap}
    .paginationBar--hidden{display:none}
    .pageBtn{min-width:44px;padding:8px 14px;border-radius:12px;border:1px solid rgba(255,255,255,0.12);background:rgba(255,255,255,0.04);color:var(--text);font-weight:500;cursor:pointer;transition:background 0.2s ease,color 0.2s ease,transform 0.2s ease}
    .pageBtn--nav{font-size:13px}
    .pageBtn--active{background:linear-gradient(115deg,var(--accent-strong),#1cc9ff);color:#050914;border-color:transparent}
    .pageBtn:disabled{opacity:0.35;cursor:not-allowed}
    .pageBtn:not(:disabled):hover{background:rgba(255,255,255,0.12);transform:translateY(-1px)}
    .pageEllipsis{padding:6px 4px;color:var(--muted);font-size:13px}
    .card{position:relative;background:var(--surface-alt);padding:22px;border-radius:22px;border:1px solid rgba(255,255,255,0.05);box-shadow:0 18px 44px rgba(6,8,27,0.55);backdrop-filter:blur(14px);transition:transform 0.25s ease,border-color 0.25s ease}
    .card::before{content:'';position:absolute;inset:0;border-radius:22px;border:1px solid rgba(126,249,194,0.08);opacity:0;pointer-events:none;transition:opacity 0.2s ease}
    .card:hover{transform:translateY(-4px);border-color:rgba(126,249,194,0.35)}
    .card:hover::before{opacity:1}
    .card h3{margin:0;font-size:18px}
    .cardAvatarWrap{width:58px;height:58px;min-width:58px;border-radius:50%;overflow:hidden;background:rgba(255,255,255,0.08);display:inline-flex;align-items:center;justify-content:center;flex-shrink:0;border:1px solid rgba(255,255,255,0.04)}
    .cardAvatar{width:100%;height:100%;object-fit:cover;display:block}
    .meta{font-size:13px;color:var(--muted);margin-top:6px;display:flex;gap:8px;align-items:center}
    .actions{margin-top:14px;display:flex;gap:10px;flex-wrap:wrap}
    .cardVideoWrap{margin-top:14px;border-radius:18px;overflow:hidden;background:rgba(0,0,0,0.65);border:1px solid rgba(255,255,255,0.05);box-shadow:0 14px 30px rgba(4,6,18,0.6)}
    .cardVideoWrap video{width:100%;display:block;max-height:320px;background:#000}
    .cardVideoMeta{padding:8px 12px;font-size:11px;letter-spacing:0.08em;text-transform:uppercase;color:var(--muted);background:rgba(0,0,0,0.35);border-top:1px solid rgba(255,255,255,0.04)}
    pre.code{background:linear-gradient(160deg,rgba(5,10,25,0.94),rgba(3,6,18,0.85));color:#dff0ff;padding:14px;border-radius:16px;overflow:auto;max-height:280px;margin:12px 0;border:1px solid rgba(255,255,255,0.04)}
    .link{color:var(--accent);text-decoration:none}
    .ratingRow{display:flex;align-items:center;gap:10px;margin-top:10px;font-size:13px;position:relative}
    .ratingRow.ratingRowFlash{animation:ratingRowPulse 0.6s ease}
    .ratingStars{display:flex;gap:6px}
    .ratingStars button{background:transparent;border:none;padding:0;font-size:20px;line-height:1;color:rgba(255,255,255,0.3);cursor:pointer;transition:color 0.18s ease,transform 0.18s ease;will-change:color,transform}
    .ratingStars button.filled{color:#ffe066;text-shadow:0 0 12px rgba(255,224,102,0.35);transform:scale(1)}
    .ratingStars button:not(:disabled):hover{color:#fff3b0;transform:translateY(-1px)}
    .ratingStars button:not(:disabled):active{transform:scale(0.9)}
    .ratingStars button:disabled{opacity:0.35;cursor:not-allowed}
    .ratingStars button:focus-visible{outline:1px dashed var(--accent);outline-offset:2px}
    .ratingPercent{font-size:12px;color:var(--muted);transition:color 0.2s ease,transform 0.2s ease}
    .ratingPercent--positive{color:var(--ratingPositive)}
    .ratingPercent--neutral{color:var(--ratingNeutral)}
    .ratingPercent--negative{color:var(--ratingNegative)}
    .ratingRow.ratingRowFlash .ratingPercent{transform:scale(1.06)}
    @keyframes ratingRowPulse{0%{transform:scale(0.96);opacity:0.6;}60%{transform:scale(1.04);opacity:1;}100%{transform:scale(1);opacity:1;}}
    @media (prefers-reduced-motion:reduce){.ratingRow.ratingRowFlash{animation:none}.ratingPercent{transition:none}.ratingStars button{transition:none}}
    @media(max-width:960px){
      .container{padding:32px 26px}
      header{flex-direction:column;align-items:flex-start}
      .controls{padding:18px}
    }
    @media(max-width:640px){
      .container{padding:22px 16px;border-radius:24px}
      .communityStrip{grid-template-columns:1fr}
      .controlRow--actions{justify-content:flex-start}
      #authBox{flex-direction:column;width:100%}
      #userLabel{text-align:left}
    }
  </style>
</head>
<body>
  <div class="container">

    <style>
      .layout{display:grid;grid-template-columns:clamp(300px,26vw,360px) minmax(0,1fr);gap:36px;margin-top:30px;align-items:flex-start}
      .sidebar{position:sticky;top:34px;height:fit-content;background:linear-gradient(160deg,rgba(9,16,40,0.96),rgba(5,10,26,0.9));padding:30px;border-radius:30px;border:1px solid rgba(255,255,255,0.08);box-shadow:0 26px 60px rgba(5,8,25,0.65);backdrop-filter:blur(20px);display:flex;flex-direction:column;gap:22px}
      .sidebar .profile{display:flex;gap:16px;align-items:center;padding-bottom:12px;border-bottom:1px solid rgba(255,255,255,0.05)}
      .avatar{width:100px;height:100px;border-radius:100%;background:linear-gradient(135deg,rgba(126,249,194,0.3),rgba(123,91,255,0.35));display:inline-block;overflow:hidden;border:1px solid rgba(255,255,255,0.08)}
      .avatar img{width:100%;height:100%;object-fit:cover;display:block}
      .smallMuted{font-size:12px;color:var(--muted)}
      .sideSection{padding:18px;border-radius:20px;background:rgba(6,12,29,0.78);border:1px solid rgba(255,255,255,0.05);box-shadow:inset 0 0 0 1px rgba(255,255,255,0.02)}
      .sideSection + .sideSection{margin-top:6px}
      .sideSection > .smallMuted{font-size:11px;letter-spacing:0.12em;text-transform:uppercase;color:rgba(156,174,203,0.9)}
      .profileLinksList{display:flex;flex-direction:column;gap:6px;margin-top:6px}
      .profileLinkRow{display:flex;justify-content:space-between;align-items:center;padding:6px 10px;border-radius:10px;background:rgba(255,255,255,0.04);border:1px solid rgba(255,255,255,0.05);font-size:12px}
      .profileLinkRow button{margin-left:8px}
      .libItem{padding:8px 10px;border-radius:12px;border:1px solid rgba(255,255,255,0.05);margin-bottom:8px;background:rgba(255,255,255,0.02)}
      .notifications,.dmList{max-height:190px;overflow:auto;margin-top:12px;padding-right:6px}
      .postsCard{width:100%;padding:48px;background:var(--panel);border-radius:34px;border:1px solid rgba(255,255,255,0.06);box-shadow:0 30px 64px rgba(7,10,30,0.72);color:inherit;backdrop-filter:blur(20px)}
      @media(max-width:900px){
        .layout{grid-template-columns:1fr;gap:22px}
        .sidebar{position:static}
      }
    </style>

    <div class="layout">
      <aside class="sidebar" id="sidebar">
        <div class="profile">
          <div class="avatar" id="avatarWrap"><img id="avatarImg" src="" alt="avatar"/></div>
          <div>
            <div id="sideUsername" class="small"></div>
            <div class="smallMuted">My account</div>
            <div class="smallMuted" id="sideFollowSummary"></div>
          </div>
        </div>
        <div style="margin-top:8px">
          <input id="avatarFile" type="file" accept="image/*" style="width:100%" />
        </div>

        <div class="sideSection">
          <div class="smallMuted">My libraries (<span id="myLibCount">0</span>)</div>
          <div id="myLibs"></div>
        </div>

        <div class="sideSection">
          <div class="smallMuted">Notifications</div>
          <div id="notifications" class="notifications small"></div>
        </div>

        <div class="sideSection">
          <div class="smallMuted">Friend Requests</div>
          <div id="friendRequests"></div>
        </div>

        <div class="sideSection">
          <div class="smallMuted">Direct Messages</div>
          <div id="dmConvos" class="dmList small"></div>
          <div style="margin-top:8px;display:flex;gap:6px">
            <input id="dmTo" placeholder="To (username)" style="flex:1;padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.04)" />
            <button id="openDm" class="ghost">Open</button>
          </div>
        </div>
      </aside>

      <div class="postsCard">
        <header>
          <div>
            <h1>JJS Library — Search & Share</h1>
            <div class="credits">Search for a moveset, or share your own with the community! You may also self-promote your content using credits or profile links.</div>
          </div>
          <div class="small">Made for Jujutsu Shenanigans</div>
        </header>

        <main style="flex:1">
          <div class="controls">
            <div class="controlRow controlRow--primary">
              <input id="search" class="search" placeholder="Search libraries (title, tags)..." />
              <div id="authBox">
                <input id="authUser" placeholder="username" />
                <input id="authPass" type="password" placeholder="password" />
                <button id="signupBtn" class="ghost">Sign up</button>
                <button id="loginBtn" class="ghost">Log in</button>
                <div id="userLabel" class="small"></div>
              </div>
            </div>
            <div class="controlRow controlRow--actions">
              <button id="createEntry" class="ghost">Create</button>
              <button id="newEntry" class="ghost">Discord</button>
            </div>
          </div>

          <div class="tagBar">
            <div id="tagPicker" class="tagPicker"></div>
            <div class="tagInput">
              <input id="customTag" placeholder="Add tag" />
              <button id="addTagBtn" class="ghost">Add Tag</button>
            </div>
          </div>

    <div class="communityStrip">
      <div class="statBlock">
        <div class="statLabel">Current Users</div>
        <div class="statValue" id="currentUsersValue">—</div>
      </div>
      <div class="statBlock">
        <div class="statLabel">Total Libraries</div>
        <div class="statValue" id="totalLibrariesValue">—</div>
      </div>
      <div class="staffPanel">
        <div class="staffBlock">
          <div class="statLabel">Owner</div>
          <div class="staffPills">
            <span class="staffPill staffPill--owner" id="staffOwnerValue">Loading...</span>
          </div>
        </div>
        <div class="staffBlock">
          <div class="statLabel">Moderators</div>
          <div class="staffPills" id="staffModerators">
            <span class="staffPill">Loading...</span>
          </div>
        </div>
      </div>
    </div>

    <div id="list" class="list"></div>
    <div id="pagination" class="paginationBar paginationBar--hidden"></div>
        </main>
      </div>
    </div>

  <template id="cardTpl">
    <div class="card">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div>
          <div style="display:flex;align-items:center;gap:10px">
            <div class="cardAvatarWrap"><img class="cardAvatar" src="" alt="avatar"/></div>
            <div>
              <h3 class="title" style="margin:0"></h3>
              <div class="meta"><span class="author"></span><span class="sep">•</span><a class="orig link" target="_blank">Original credit</a></div>
            </div>
          </div>
        </div>
        <div class="small">tag: <span class="tags"></span></div>
      </div>
      <div class="actions">
        <button class="toggle">Show code</button>
        <button class="copy">Copy</button>
        <button class="edit ghost" style="display:none">Edit</button>
        <button class="del ghost" style="display:none">Delete</button>
        <button class="ghost viewOrig">Open credit</button>
      </div>
      <div class="codeWrap" style="display:none">
        <pre class="code" data-full=""></pre>
      </div>
      <div class="cardVisibilityRow" style="display:flex;justify-content:flex-end;margin-top:8px">
        <button type="button" class="ghost visibilityToggle">Public</button>
      </div>
    </div>
  </template>

  <script>
    // Sample libraries array — you can extend this or load from a JSON endpoint
    const libs = [
      {
        id: 'hollow-purple',
        title: 'Create a post to share your library with the community!',
        author: 'ADMIN - Kuro',
        description: 'Include details like title, description, tags, and code. You can also link to an original credit if your library is inspired by or based on someone else\'s work.',
        credit: 'https://www.youtube.com/@FFS-Productions',
        tags: ['help','guide','how-to'],
        visibility: 'public',
        // Put the long import code here (string). Keep it escaped as needed.
        code: `
Get a code from the character builder in jjs, then paste it here. When you click "Copy", the full code will be copied to your clipboard for easy sharing or use in your own builds.
`
      }
    ];
    const VISIBILITY = Object.freeze({ PUBLIC: 'public', PRIVATE: 'private' });
    function normalizeVisibility(value){
      return value === VISIBILITY.PRIVATE ? VISIBILITY.PRIVATE : VISIBILITY.PUBLIC;
    }
    function isLibVisibleToUser(lib, user){
      const state = normalizeVisibility(lib && lib.visibility);
      if(state !== VISIBILITY.PRIVATE) return true;
      if(!user || !user.username || !lib || !lib.author) return false;
      return user.username.toLowerCase() === String(lib.author || '').toLowerCase();
    }
    const PAGE_SIZE = 12;
    let currentPage = 1;
    let filteredResults = libs.slice();
    let remoteLibsInitialized = false;
    const AVATAR_FOLDER = (window.AVATAR_FOLDER || 'avatars').toString().replace(/\\/g,'/').replace(/^\/+/,'').replace(/\/+$/,'');
    const DEFAULT_AVATAR_URL = AVATAR_FOLDER ? `${AVATAR_FOLDER}/default.png` : 'default.png';
    const FALLBACK_AVATAR_DATA_URI = 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="80" height="80" viewBox="0 0 80 80"><rect width="80" height="80" rx="26" fill="%231f2436"/><circle cx="40" cy="30" r="18" fill="%23495773"/><rect x="18" y="52" width="44" height="18" rx="9" fill="%23495773"/></svg>';

    const listEl = document.getElementById('list');
    const paginationEl = document.getElementById('pagination');
    const tpl = document.getElementById('cardTpl');
    const search = document.getElementById('search');
    const BAD_WORDS = ['fuck','nigger','nigga','bitch','shit','pussy'];
    const BAD_WORD_REPLACEMENT = '@#%!';
    const BAD_WORD_REGEX = new RegExp('\\b(' + BAD_WORDS.map(w=>w.replace(/[-/\\^$*+?.()|[\]{}]/g,'\\$&')).join('|') + ')\\b','gi');
    const VIDEO_DURATION_LIMIT_SECONDS = 60;
    const REMOTE_SAVE_MAX_BYTES = 4 * 1024 * 1024; // Vercel body limit ~4MB
    const VIDEO_MAX_SIZE_BYTES = Math.min(25 * 1024 * 1024, Math.floor(REMOTE_SAVE_MAX_BYTES * 0.75));
    const ALLOWED_VIDEO_TYPES = ['video/mp4','video/webm','video/ogg'];

    function censorBadWords(text){
      if(typeof text !== 'string' || !text.trim()) return text;
      return text.replace(BAD_WORD_REGEX, BAD_WORD_REPLACEMENT);
    }

    function sanitizeLibraryContent(lib){
      if(!lib) return lib;
      if(typeof lib.title === 'string') lib.title = censorBadWords(lib.title);
      if(typeof lib.description === 'string') lib.description = censorBadWords(lib.description);
      if(typeof lib.author === 'string') lib.author = censorBadWords(lib.author);
      if(Array.isArray(lib.tags)) lib.tags = lib.tags.map(tag=>censorBadWords(tag || ''));
      lib.visibility = normalizeVisibility(lib.visibility);
      return lib;
    }

    libs.forEach(sanitizeLibraryContent);

    function normalizeProfileLinkEntry(entry){
      if(!entry) return null;
      let label = typeof entry.label === 'string' ? entry.label.trim() : '';
      let url = typeof entry.url === 'string' ? entry.url.trim() : '';
      if(!url) return null;
      if(!/^https?:\/\//i.test(url)) url = 'https://' + url;
      try{
        const parsed = new URL(url);
        url = parsed.href;
      }catch(_e){
        return null;
      }
      label = censorBadWords(label).slice(0, 40);
      if(!label) label = url.replace(/^https?:\/\//i,'').slice(0,40);
      return { label, url };
    }

    function sanitizeProfileLinks(list){
      if(!Array.isArray(list)) return [];
      const seen = new Set();
      const cleaned = [];
      list.forEach(item=>{
        const normalized = normalizeProfileLinkEntry(item);
        if(!normalized) return;
        const key = normalized.url.toLowerCase();
        if(seen.has(key)) return;
        seen.add(key);
        cleaned.push(normalized);
      });
      return cleaned.slice(0, 6);
    }

    function formatVideoDuration(seconds){
      if(!Number.isFinite(seconds) || seconds <= 0) return '0:00';
      const totalSeconds = Math.round(seconds);
      const mins = Math.floor(totalSeconds / 60);
      const secs = (totalSeconds % 60).toString().padStart(2,'0');
      return `${mins}:${secs}`;
    }

    function formatBytes(bytes){
      if(!Number.isFinite(bytes) || bytes <= 0) return '0 B';
      const units = ['B','KB','MB','GB'];
      let value = bytes;
      let unitIndex = 0;
      while(value >= 1024 && unitIndex < units.length - 1){
        value /= 1024;
        unitIndex++;
      }
      const precision = value >= 10 || unitIndex === 0 ? 0 : 1;
      return `${value.toFixed(precision)} ${units[unitIndex]}`;
    }

    function readVideoDuration(file){
      return new Promise((resolve,reject)=>{
        const video = document.createElement('video');
        let objectUrl = '';
        const cleanup = ()=>{
          if(objectUrl){
            URL.revokeObjectURL(objectUrl);
            objectUrl = '';
          }
          video.removeAttribute('src');
          video.load();
        };
        video.preload = 'metadata';
        video.onloadedmetadata = ()=>{
          const duration = video.duration || 0;
          cleanup();
          resolve(duration);
        };
        video.onerror = ()=>{
          cleanup();
          reject(new Error('Could not read video metadata.'));
        };
        objectUrl = URL.createObjectURL(file);
        video.src = objectUrl;
      });
    }

    async function processVideoFile(file, opts = {}){
      if(!file) throw new Error('Select a video file first.');
      if(!file.type || !file.type.startsWith('video/')) throw new Error('File must be a video.');
      if(ALLOWED_VIDEO_TYPES.length && !ALLOWED_VIDEO_TYPES.includes(file.type)){
        throw new Error('Video must be MP4, WebM, or Ogg.');
      }
      if(file.size > VIDEO_MAX_SIZE_BYTES){
        throw new Error(`Video must be under ${formatBytes(VIDEO_MAX_SIZE_BYTES)} to stay within upload limits.`);
      }
      const duration = await readVideoDuration(file);
      if(duration > VIDEO_DURATION_LIMIT_SECONDS){
        throw new Error('Video must be 60 seconds or shorter.');
      }
      const base = {
        name: file.name,
        type: file.type,
        size: file.size,
        duration: Math.round(duration * 10) / 10
      };
      if(opts.skipEncoding) return base;
      const dataUrl = await fileToDataUrl(file);
      base.dataUrl = dataUrl;
      return base;
    }

    function buildVideoAttachment(videoPayload){
      if(!videoPayload) return null;
      const attachment = {
        dataUrl: videoPayload.dataUrl,
        name: censorBadWords(videoPayload.name || 'video'),
        type: videoPayload.type,
        duration: videoPayload.duration,
        size: videoPayload.size
      };
      if(!attachment.dataUrl) return null;
      return attachment;
    }

    function normalizeKey(value){
      return (value || 'unknown').toString().replace(/[^a-z0-9_-]/gi,'_');
    }

    function getLibStorageId(lib){
      if(!lib) return 'unknown';
      return normalizeKey(lib.id || lib.__filename || lib.title || Date.now());
    }

    function getLocalComments(lib){
      const key = 'jjs_comments_' + getLibStorageId(lib);
      try{ return JSON.parse(localStorage.getItem(key) || '[]'); }
      catch(_e){ return []; }
    }

    function saveLocalComments(lib, comments){
      const key = 'jjs_comments_' + getLibStorageId(lib);
      try{ localStorage.setItem(key, JSON.stringify(comments || [])); }
      catch(_e){}
    }

    function ensureLibComments(lib){
      if(!lib) return [];
      if(Array.isArray(lib.comments) && lib.comments.length){
        saveLocalComments(lib, lib.comments);
        return lib.comments;
      }
      lib.comments = getLocalComments(lib);
      return lib.comments;
    }

    function appendComment(lib, comment){
      const comments = ensureLibComments(lib);
      comments.push(comment);
      saveLocalComments(lib, comments);
      return comments;
    }

    function addReply(comments, parentId, reply){
      for(const comment of comments){
        if(comment.id === parentId){
          comment.replies = comment.replies || [];
          comment.replies.push(reply);
          return true;
        }
        if(comment.replies && comment.replies.length && addReply(comment.replies, parentId, reply)){
          return true;
        }
      }
      return false;
    }

    const COMMENT_MAX_LENGTH = 200;

    function getLibIdForApi(lib){
      if(lib && lib.id) return lib.id;
      const storageId = getLibStorageId(lib);
      return storageId !== 'unknown' ? storageId : null;
    }

    async function postCommentToServer(lib, author, text, parentId){
      if(!SERVERLESS_URL) throw new Error('Serverless endpoint not configured');
      const libId = getLibIdForApi(lib);
      if(!libId) throw new Error('Missing library identifier');
      const payload = { libId, comment: { author, text, parentId } };
      const resp = await fetch(SERVERLESS_URL + '?action=addComment', {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: JSON.stringify(payload)
      });
      const data = await resp.json().catch(()=>null);
      if(!resp.ok || !data || !data.ok) throw new Error(data && data.error ? data.error : 'Failed to post comment');
      return data.comment;
    }

    function ensureLibRatings(lib){
      if(!lib) return [];
      if(Array.isArray(lib.ratings)) return lib.ratings;
      lib.ratings = [];
      return lib.ratings;
    }

    function clampRatingValue(value){
      const num = Number(value);
      if(!Number.isFinite(num)) return null;
      return Math.min(5, Math.max(1, num));
    }

    function getRatingStats(lib){
      const ratings = ensureLibRatings(lib);
      const values = ratings
        .map(entry => clampRatingValue(entry && entry.value))
        .filter(val => typeof val === 'number');
      if(!values.length) return { avg: 0, percent: 0, count: 0 };
      const sum = values.reduce((acc, val)=> acc + val, 0);
      const avg = sum / values.length;
      const percent = Math.round(((avg - 1) / 4) * 100);
      const clampedPercent = Math.max(0, Math.min(100, percent));
      return { avg, percent: clampedPercent, count: values.length };
    }

    function getRatingTone(percent){
      if(percent >= 70) return 'positive';
      if(percent >= 40) return 'neutral';
      return 'negative';s
    }

    function formatRatingSummary(stats){
      if(!stats || !stats.count) return 'Be the first to rate';
      const countLabel = `${stats.count} rating${stats.count === 1 ? '' : 's'}`;
      return `${stats.percent}% quality • ${countLabel}`;
    }

    function getUserRatingValue(lib){
      const me = getCurrentUser();
      if(!me) return null;
      const ratings = ensureLibRatings(lib);
      const match = ratings.find(r=> (r.user || '').toLowerCase() === me.username.toLowerCase());
      return match ? Number(match.value) || null : null;
    }

    async function submitRating(lib, value){
      if(!SERVERLESS_URL) throw new Error('Serverless endpoint not configured');
      const me = getCurrentUser();
      if(!me) throw new Error('Sign in to rate');
      const normalizedAuthor = (lib && typeof lib.author === 'string') ? lib.author.toLowerCase() : '';
      const normalizedUser = (me.username || '').toLowerCase();
      if(normalizedAuthor && normalizedAuthor === normalizedUser){
        throw new Error('You cannot rate your own post');
      }
      const libId = getLibIdForApi(lib);
      if(!libId) throw new Error('Missing library identifier');
      const resp = await fetch(SERVERLESS_URL + '?action=rate', {
        method: 'POST',
        headers: { 'Content-Type':'application/json' },
        body: JSON.stringify({ libId, rating: value, username: me.username })
      });
      const data = await resp.json().catch(()=>null);
      if(!resp.ok || !data || !data.ok) throw new Error((data && data.error) || 'Failed to submit rating');
      lib.ratings = Array.isArray(data.ratings) ? data.ratings : ensureLibRatings(lib);
      return data.stats || getRatingStats(lib);
    }

    function renderRatingRow(lib, container){
      const stats = getRatingStats(lib);
      const avgRounded = Math.round(stats.avg);
      const me = getCurrentUser();
      const normalizedAuthor = (lib && typeof lib.author === 'string') ? lib.author.toLowerCase() : '';
      const normalizedUser = me && me.username ? me.username.toLowerCase() : '';
      const isOwnLibrary = !!(normalizedAuthor && normalizedUser && normalizedAuthor === normalizedUser);
      const canRate = !!(me && !isOwnLibrary);
      const toneClasses = ['ratingPercent--positive','ratingPercent--neutral','ratingPercent--negative'];
      const shouldFlash = container.dataset.justRated === 'true';
      container.innerHTML = '';
      const starsWrap = document.createElement('div');
      starsWrap.className = 'ratingStars';
      starsWrap.setAttribute('aria-label', stats.count ? `Average rating ${stats.avg.toFixed(1)} out of 5 stars` : 'No ratings yet');
      const percentEl = document.createElement('div');
      percentEl.className = 'ratingPercent';
      percentEl.setAttribute('aria-live','polite');
      percentEl.textContent = formatRatingSummary(stats);
      if(stats.count){
        percentEl.classList.add(`ratingPercent--${getRatingTone(stats.percent)}`);
        percentEl.title = `${stats.avg.toFixed(2)} average stars`;
      }else{
        percentEl.title = 'No ratings yet';
      }
      const starButtons = [];
      const applyFill = (fillValue)=>{
        starButtons.forEach(b=>{
          const isFilled = Number(b.dataset.value) <= fillValue;
          b.classList.toggle('filled', isFilled);
        });
      };
      for(let i=1;i<=5;i++){
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.textContent = '★';
        btn.dataset.value = i;
        btn.setAttribute('aria-label', `Rate ${i} star${i===1?'':'s'}`);
        if(!canRate){
          btn.disabled = true;
          btn.title = me ? 'You cannot rate your own post' : 'Sign in to rate';
        }
        btn.addEventListener('mouseenter', ()=>{
          if(btn.disabled) return;
          applyFill(i);
        });
        btn.addEventListener('mouseleave', ()=>{
          applyFill(Math.round(getRatingStats(lib).avg));
        });
        btn.addEventListener('click', async ()=>{
          if(btn.disabled) return;
          const starValue = Number(btn.dataset.value);
          starButtons.forEach(b=> b.disabled = true);
          percentEl.textContent = 'Saving...';
          toneClasses.forEach(cls => percentEl.classList.remove(cls));
          try{
            await submitRating(lib, starValue);
            container.dataset.justRated = 'true';
            renderRatingRow(lib, container);
            addNotification(`Rated ${lib.title} ${starValue} star${starValue===1?'':'s'}`);
          }catch(err){
            alert(err && err.message ? err.message : 'Failed to submit rating');
            starButtons.forEach(b=> b.disabled = !canRate);
            const fallbackStats = getRatingStats(lib);
            percentEl.textContent = formatRatingSummary(fallbackStats);
            if(fallbackStats.count){
              percentEl.classList.add(`ratingPercent--${getRatingTone(fallbackStats.percent)}`);
            }
            applyFill(Math.round(fallbackStats.avg));
          }
        });
        starButtons.push(btn);
        starsWrap.appendChild(btn);
      }
      applyFill(avgRounded);
      container.appendChild(starsWrap);
      container.appendChild(percentEl);
      if(shouldFlash){
        container.classList.add('ratingRowFlash');
        delete container.dataset.justRated;
        setTimeout(()=> container.classList.remove('ratingRowFlash'), 600);
      }else{
        container.classList.remove('ratingRowFlash');
      }
    }

    async function syncCommentsFromServer(lib, opts = {}){
      if(!SERVERLESS_URL) return;
      const list = document.getElementById('commentsList');
      const libId = getLibIdForApi(lib);
      const rerender = typeof opts.renderFn === 'function' ? opts.renderFn : null;
      if(!libId){ if(rerender) rerender(); return; }
      if(opts.showSpinner && list){
        list.innerHTML = '<div class="smallMuted">Loading comments...</div>';
      }
      try{
        const resp = await fetch(
          SERVERLESS_URL + '?action=getComments&libId=' + encodeURIComponent(libId),
          {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ libId })
          }
        );
        if(resp.status === 404){
          lib.comments = [];
          saveLocalComments(lib, []);
          if(rerender) rerender();
          return;
        }
        const data = await resp.json().catch(()=>null);
        if(!resp.ok || !data || !data.ok) throw new Error((data && data.error) || 'Failed');
        lib.comments = data.comments || [];
        saveLocalComments(lib, lib.comments);
        if(rerender) rerender();
      }catch(e){
        console.error('syncCommentsFromServer failed', e);
        if(opts.showError && list){
          const msg = e && e.message ? e.message : 'Unknown error';
          list.innerHTML = `<div class="smallMuted">Failed to load comments. ${escapeHtml(msg)} <button class="ghost" id="retryCommentsSync">Retry</button></div>`;
          const retryBtn = list.querySelector('#retryCommentsSync');
          if(retryBtn){
            retryBtn.addEventListener('click', ()=> syncCommentsFromServer(lib, Object.assign({}, opts, { showSpinner: true, showError: true })));
          }
        }
      }
    }

    function render(filtered){
      updateTotalLibrariesDisplay();
      listEl.innerHTML = '';
      if(filtered.length===0){
        listEl.innerHTML = '<div class="small">No libraries match your search.</div>';
        return;
      }
      filtered.forEach(lib=>{
        const node = tpl.content.cloneNode(true);
        const titleEl = node.querySelector('.title');
        const avatarImg = node.querySelector('.cardAvatar');
        const avatarWrap = node.querySelector('.cardAvatarWrap');
        setAvatarImage(avatarImg, { src: DEFAULT_AVATAR_URL, wrapper: avatarWrap, stage: 'default' });
        titleEl.textContent = censorBadWords(lib.title || '');
        // Show description if present
        if(lib.description){
          const desc = document.createElement('div');
          desc.className = 'smallMuted';
          desc.style.margin = '6px 0 0 0';
          const safeDesc = censorBadWords(lib.description);
          desc.textContent = safeDesc.length>250? safeDesc.slice(0,250)+'…': safeDesc;
          titleEl.parentElement.appendChild(desc);
        }
        node.querySelector('.author').textContent = censorBadWords(lib.author || '');
        // make author clickable to open profile
        try{ const authorEl = node.querySelector('.author'); authorEl.style.cursor='pointer'; authorEl.addEventListener('click', ()=> openProfile(lib.author)); }catch(e){}
        node.querySelector('.orig').href = lib.credit;
        node.querySelector('.orig').textContent = 'Credit';
        const safeTags = (lib.tags || []).map(tag=>censorBadWords(tag || ''));
        node.querySelector('.tags').textContent = safeTags.join(', ');
        const pre = node.querySelector('.code');
        pre.textContent = lib.code;
        pre.setAttribute('data-full', lib.code);

        // populate author avatar from social if available
        (async ()=>{
          if(!avatarImg) return;
          try{
            const social = await fetchSocial(lib.author);
            const avatarSource = getAvatarSourceBundle(lib.author, social);
            setAvatarImage(avatarImg, {
              src: avatarSource.src || DEFAULT_AVATAR_URL,
              wrapper: avatarWrap,
              stage: avatarSource.stage,
              fallbackSources: avatarSource.fallbackSources
            });
            if(social && social.bio){
              const meta = node.querySelector('.meta');
              const bioEl = document.createElement('div');
              bioEl.className='smallMuted';
              bioEl.style.marginTop='6px';
              bioEl.textContent = social.bio.length>80? social.bio.slice(0,80)+'…': social.bio;
              meta.appendChild(bioEl);
            }
          }catch(e){
            setAvatarImage(avatarImg, { src: DEFAULT_AVATAR_URL, wrapper: avatarWrap, stage: 'default' });
          }
        })();

        const card = node.querySelector('.card');
        const actionsEl = node.querySelector('.actions');

        if(lib.video && lib.video.dataUrl && card){
          const videoWrap = document.createElement('div');
          videoWrap.className = 'cardVideoWrap';
          const videoEl = document.createElement('video');
          videoEl.controls = true;
          videoEl.playsInline = true;
          videoEl.preload = 'metadata';
          videoEl.muted = true;
          videoEl.src = lib.video.dataUrl;
          videoWrap.appendChild(videoEl);
          if(lib.video.duration || lib.video.name || lib.video.size){
            const meta = document.createElement('div');
            meta.className = 'cardVideoMeta';
            const parts = [];
            if(Number.isFinite(lib.video.duration)) parts.push(`Duration ${formatVideoDuration(lib.video.duration)}`);
            if(typeof lib.video.size === 'number') parts.push(formatBytes(lib.video.size));
            if(lib.video.name) parts.push(censorBadWords(lib.video.name));
            meta.textContent = parts.join(' • ');
            videoWrap.appendChild(meta);
          }
          if(actionsEl) card.insertBefore(videoWrap, actionsEl); else card.appendChild(videoWrap);
        }

        // Ratings UI
        const ratingRow = document.createElement('div');
        ratingRow.className = 'ratingRow';
        ensureLibRatings(lib);
        renderRatingRow(lib, ratingRow);
        if(actionsEl) card.insertBefore(ratingRow, actionsEl); else card.appendChild(ratingRow);
        const toggle = node.querySelector('.toggle');
        const copyBtn = node.querySelector('.copy');
        const viewOrig = node.querySelector('.viewOrig');
        const wrap = node.querySelector('.codeWrap');

        toggle.addEventListener('click', ()=>{
          if(wrap.style.display==='none'){
            wrap.style.display='block'; toggle.textContent='Hide code';
          } else { wrap.style.display='none'; toggle.textContent='Show code'; }
        });

        copyBtn.addEventListener('click', async ()=>{
          try{
            await navigator.clipboard.writeText(pre.getAttribute('data-full'));
            copyBtn.textContent='Copied!';
            setTimeout(()=>copyBtn.textContent='Copy',1400);
          }catch(e){
            alert('Copy failed — select and copy manually.');
          }
        });

        viewOrig.addEventListener('click', ()=>window.open(lib.credit,'_blank'));
        // show edit/delete if current user is author
        const editBtn = node.querySelector('.edit');
        const delBtn = node.querySelector('.del');
        const currentUser = getCurrentUser();
        const isAuthor = !!(currentUser && currentUser.username === lib.author);
        const canDelete = canDeleteLibrary(currentUser, lib);
        const visibilityBtn = node.querySelector('.visibilityToggle');
        const visibilityRow = node.querySelector('.cardVisibilityRow');
        if(visibilityBtn){
          const applyVisibilityState = ()=>{
            const state = normalizeVisibility(lib.visibility);
            visibilityBtn.dataset.state = state;
            const isPrivate = state === VISIBILITY.PRIVATE;
            visibilityBtn.textContent = isPrivate ? 'Private' : 'Public';
            const hint = isPrivate ? 'Private — only you can view this post' : 'Public — everyone can view this post';
            visibilityBtn.title = hint;
            if(visibilityRow) visibilityRow.title = hint;
          };
          applyVisibilityState();
          visibilityBtn.style.display = 'inline-flex';
          if(isAuthor){
            visibilityBtn.disabled = false;
            visibilityBtn.addEventListener('click', async ()=>{
              const currentState = visibilityBtn.dataset.state || VISIBILITY.PUBLIC;
              const nextState = currentState === VISIBILITY.PRIVATE ? VISIBILITY.PUBLIC : VISIBILITY.PRIVATE;
              const previousLabel = visibilityBtn.textContent;
              visibilityBtn.textContent = 'Saving...';
              visibilityBtn.disabled = true;
              try{
                await updateLibraryVisibility(lib, nextState);
                applyVisibilityState();
                addNotification(`Visibility set to ${nextState}`);
                refreshListView({ refilter:true });
              }catch(err){
                alert(err && err.message ? err.message : 'Failed to update visibility');
                visibilityBtn.textContent = previousLabel;
              }finally{
                visibilityBtn.disabled = false;
              }
            });
          }else{
            visibilityBtn.disabled = true;
            visibilityBtn.title = 'Only the owner can change visibility';
          }
        }
        if(isAuthor && editBtn) editBtn.style.display = 'inline-block';
        if(canDelete && delBtn) delBtn.style.display = 'inline-block';

        if(editBtn){
          editBtn.addEventListener('click', ()=>{
            openLibraryModal({
              mode: 'edit',
              lib,
              onSubmit: async (payload)=>{
                const { title, description, credit, code, tags, visibility, video, videoRemoved } = payload;
                if(!title) throw new Error('Title required');
                if(!description) throw new Error('Description required');
                if(description.length > 250) throw new Error('Description too long');
                if(!code) throw new Error('Code required');
                lib.title = censorBadWords(title);
                lib.description = censorBadWords(description);
                lib.credit = credit;
                lib.code = code;
                lib.tags = (tags || []).map(tag=>censorBadWords(tag));
                lib.visibility = visibility;
                if(videoRemoved){
                  delete lib.video;
                }else if(video){
                  if(video !== lib.video){
                    const attachment = buildVideoAttachment(video);
                    if(attachment) lib.video = attachment;
                  }
                }else{
                  delete lib.video;
                }
                sanitizeLibraryContent(lib);
                await persistLibraryFile(lib);
                addNotification('Library updated');
                refreshListView({ refilter:true });
              }
            });
          });
        }

        if(delBtn){
          delBtn.addEventListener('click', async ()=>{
            const actingUser = getCurrentUser();
            if(!canDeleteLibrary(actingUser, lib)){
              alert('Only the author or owner can delete this entry.');
              return;
            }
            const isOwnerAction = actingUser && actingUser.role === 'owner';
            const promptMsg = isOwnerAction ? 'Remove this library as the owner?' : 'Delete this library?';
            if(!confirm(promptMsg)) return;
            const localBasePath = (GITHUB.path || '').replace(/^\/+|\/+$/g,'');
            const fallbackFilename = lib.__filename || `${lib.id || Date.now()}-${sanitizeFilename(lib.title || 'library')}.json`;
            const resolvedPath = (lib.__path && lib.__path.trim()) || (localBasePath ? `${localBasePath}/${fallbackFilename}` : fallbackFilename);
            if(!resolvedPath){
              alert('Unable to determine a file path for this library.');
              return;
            }
            let deleted = false;
            try{
              if(SERVERLESS_URL){
                const resp = await fetch(SERVERLESS_URL + '?action=delete', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ path: resolvedPath, filename: fallbackFilename, lib }) });
                const data = await resp.json().catch(()=>null);
                if(!resp.ok || (data && data.error)) throw new Error((data && data.error) || 'Delete failed');
                deleted = true;
              }
              else if(GITHUB.token && GITHUB.owner && GITHUB.repo){
                // delete via contents API
                const apiBase = `https://api.github.com/repos/${GITHUB.owner}/${GITHUB.repo}/contents/${encodeURIComponent(resolvedPath)}`;
                const getResp = await fetch(apiBase + `?ref=${encodeURIComponent(GITHUB.branch)}`, { headers: { 'Accept':'application/vnd.github.v3+json', 'Authorization': `token ${GITHUB.token}` } });
                if(getResp.status===200){
                  const data = await getResp.json();
                  const delResp = await fetch(apiBase, { method:'DELETE', headers: { 'Accept':'application/vnd.github.v3+json', 'Authorization': `token ${GITHUB.token}`, 'Content-Type':'application/json' }, body: JSON.stringify({ message: 'Delete library', sha: data.sha, branch: GITHUB.branch }) });
                  if(!delResp.ok) throw new Error('GitHub delete failed');
                  deleted = true;
                }else{
                  throw new Error('File not found in repository');
                }
              }
            }catch(e){
              alert(e && e.message ? e.message : 'Failed to delete library');
              return;
            }
            if(!deleted) return;
            const idx = libs.findIndex(x=>x.id===lib.id);
            if(idx>=0) libs.splice(idx,1);
            refreshListView({ refilter:true });
            addNotification((isStaffAction ? 'Staff removed ' : 'Deleted ') + lib.title);
          });
        }

        // --- COMMENTS UI (modal) ---
        const commentsBtn = document.createElement('button');
        commentsBtn.className = 'ghost';
        commentsBtn.textContent = 'Comments';
        commentsBtn.style.marginTop = '12px';
        card.appendChild(commentsBtn);

        commentsBtn.addEventListener('click', () => openCommentsModal(lib));
        // --- Comments Modal ---
        function openCommentsModal(lib) {
          let modal = document.getElementById('commentsModal');
          if(modal) modal.remove();
          modal = document.createElement('div');
          modal.id = 'commentsModal';
          modal.style.position = 'fixed';
          modal.style.left = '0';
          modal.style.top = '0';
          modal.style.width = '100vw';
          modal.style.height = '100vh';
          modal.style.background = 'rgba(0,0,0,0.55)';
          modal.style.zIndex = '9999';
          modal.style.display = 'flex';
          modal.style.alignItems = 'center';
          modal.style.justifyContent = 'center';
          modal.innerHTML = `<div id="commentsModalInner" style="background:var(--card);padding:24px 18px 18px 18px;min-width:340px;max-width:98vw;max-height:90vh;overflow:auto;border-radius:12px;box-shadow:0 8px 32px #000a;position:relative;">
            <button id="closeCommentsModal" style="position:absolute;top:10px;right:10px;" class="ghost">Close</button>
            <h3 style="margin-top:0">Comments for <span style="color:#6cf">${escapeHtml(lib.title)}</span></h3>
            <div id="addCommentSection"></div>
            <hr style="margin:16px 0 10px 0;opacity:0.2">
            <div id="commentsList"></div>
          </div>`;
          document.body.appendChild(modal);
          document.getElementById('closeCommentsModal').onclick = ()=>modal.remove();
          const rerenderComments = () => renderCommentsList(lib);
          // Add comment UI
          renderAddCommentUI(lib, rerenderComments);
          // Fetch and render comments
          const hasLocalComments = ensureLibComments(lib).length > 0;
          rerenderComments();
          syncCommentsFromServer(lib, { showSpinner: !hasLocalComments, showError: true, renderFn: rerenderComments });
        }

        function renderAddCommentUI(lib, rerenderCb) {
          const u = getCurrentUser();
          const wrap = document.getElementById('addCommentSection');
          wrap.innerHTML = '';
          const form = document.createElement('form');
          form.innerHTML = `<div style="font-weight:bold;margin-bottom:4px">Add a comment</div><textarea class="commentInput" maxlength="200" placeholder="Add a comment (max 200 chars)" style="width:100%;min-height:48px;padding:8px;border-radius:8px;border:1px solid #333"></textarea><div style="display:flex;gap:8px;align-items:center;margin-top:6px"><button type="submit" class="ghost">Post</button><span class="smallMuted commentCount"></span></div>`;
          const input = form.querySelector('.commentInput');
          const count = form.querySelector('.commentCount');
          const submitBtn = form.querySelector('button');
          input.addEventListener('input',()=>{ count.textContent = (input.value.length ? input.value.length + '/' + COMMENT_MAX_LENGTH : ''); });
          form.addEventListener('submit', async (ev)=>{
            ev.preventDefault();
            if(!u) return alert('Sign in to comment');
            const text = input.value.trim();
            if(!text) return;
            if(text.length>COMMENT_MAX_LENGTH) return alert('Max ' + COMMENT_MAX_LENGTH + ' chars');
            submitBtn.disabled = true;
            const cleanText = censorBadWords(text).slice(0,COMMENT_MAX_LENGTH);
            const tempComment = { id: Date.now().toString(36) + Math.random().toString(36).slice(2,8), author: u.username, text: cleanText, t: Date.now(), replies: [] };
            appendComment(lib, tempComment);
            if(rerenderCb) rerenderCb(); else renderCommentsList(lib);
            input.value = '';
            count.textContent = '';
            try{
              if(SERVERLESS_URL){
                await postCommentToServer(lib, u.username, cleanText, null);
                await syncCommentsFromServer(lib, { renderFn: rerenderCb });
              }
            }catch(err){
              console.warn('Comment sync failed', err);
              addNotification('Comment saved locally — server unreachable');
            }
            submitBtn.disabled = false;
          });
          wrap.appendChild(form);
        }

        function renderCommentsList(lib) {
          const list = document.getElementById('commentsList');
          if(!list) return;
          const comments = ensureLibComments(lib);
          if(!comments || comments.length === 0){
            list.innerHTML = '<div class="smallMuted">No comments yet.</div>';
            return;
          }
          list.innerHTML = '';
          renderCommentsThread(comments, list, lib);
        }

        function renderCommentsThread(comments, parentEl, lib, depth=0) {
          const u = getCurrentUser();
          comments.forEach(c=>{
            const div = document.createElement('div');
            div.className = 'commentItem';
            div.style.marginLeft = (depth*18)+'px';
            div.style.marginTop = '10px';
            div.style.padding = '8px';
            div.style.background = 'rgba(255,255,255,0.03)';
            div.style.borderRadius = '8px';
            const safeAuthor = censorBadWords(c.author || '');
            const safeCommentText = escapeHtml(censorBadWords(c.text || ''));
            div.innerHTML = `<span class="small"><b>${safeAuthor}</b>:</span> <span>${safeCommentText}</span> <span class="smallMuted" style="margin-left:8px">${new Date(c.t).toLocaleString()}</span>`;
            // Reply button
            if(depth<4){
              const replyBtn = document.createElement('button'); replyBtn.className='ghost'; replyBtn.textContent='Reply'; replyBtn.style.marginLeft='8px';
              replyBtn.addEventListener('click',()=>{
                if(div.querySelector('.replyForm')) return;
                const rf = document.createElement('form'); rf.className='replyForm'; rf.style.marginTop='8px';
                rf.innerHTML = `<textarea maxlength="200" placeholder="Reply (max 200 chars)" style="width:100%;min-height:28px;padding:4px;border-radius:6px;border:1px solid #333"></textarea><div style="display:flex;gap:8px;align-items:center;margin-top:2px"><button type="submit" class="ghost">Post</button><span class="smallMuted replyCount"></span></div>`;
                const rinput = rf.querySelector('textarea');
                const rcount = rf.querySelector('.replyCount');
                rinput.addEventListener('input',()=>{ rcount.textContent = (rinput.value.length ? rinput.value.length + '/' + COMMENT_MAX_LENGTH : ''); });
                rf.addEventListener('submit', async (ev)=>{
                  ev.preventDefault();
                  if(!u) return alert('Sign in to reply');
                  const text = rinput.value.trim();
                  if(!text) return;
                  if(text.length>COMMENT_MAX_LENGTH) return alert('Max ' + COMMENT_MAX_LENGTH + ' chars');
                  const btn = rf.querySelector('button');
                  btn.disabled = true;
                  const cleanReplyText = censorBadWords(text).slice(0,COMMENT_MAX_LENGTH);
                  const reply = { id: Date.now().toString(36) + Math.random().toString(36).slice(2,8), author: u.username, text: cleanReplyText, t: Date.now(), replies: [] };
                  const comments = ensureLibComments(lib);
                  const added = addReply(comments, c.id, reply);
                  if(added){
                    saveLocalComments(lib, comments);
                    renderCommentsList(lib);
                    rinput.value = '';
                    rcount.textContent = '';
                    try{
                      if(SERVERLESS_URL){
                        await postCommentToServer(lib, u.username, cleanReplyText, c.id);
                        await syncCommentsFromServer(lib, { renderFn: ()=>renderCommentsList(lib) });
                      }
                    }catch(err){
                      console.warn('Reply sync failed', err);
                      addNotification('Reply saved locally — server unreachable');
                    }
                  }else{
                    alert('Failed to reply');
                  }
                  btn.disabled = false;
                });
                div.appendChild(rf);
              });
              div.appendChild(replyBtn);
            }
            parentEl.appendChild(div);
            if(c.replies && c.replies.length) renderCommentsThread(c.replies, parentEl, lib, depth+1);
          });
        }
        listEl.appendChild(node);
        });
        // diagnostics removed
    }

    function escapeHtml(str){
      const map = {"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"};
      return String(str).replace(/[&<>"']/g, (m)=>map[m] || m);
    }

    function filter(q){
      const viewer = getCurrentUser();
      const query = (q || '').trim().toLowerCase();
      return libs.filter(lib=>{
        if(!isLibVisibleToUser(lib, viewer)) return false;
        if(!query) return true;
        const titleMatch = (lib.title || '').toLowerCase().includes(query);
        const tagMatch = (lib.tags || []).some(tag=> (tag || '').toLowerCase().includes(query));
        const authorMatch = (lib.author || '').toLowerCase().includes(query);
        return titleMatch || tagMatch || authorMatch;
      });
    }

    function updateFilteredResults(){
      const query = (search && typeof search.value === 'string') ? search.value : '';
      filteredResults = filter(query);
    }

    function ensureValidPage(){
      const totalPages = Math.max(1, Math.ceil((filteredResults.length || 0) / PAGE_SIZE) || 1);
      if(currentPage > totalPages) currentPage = totalPages;
      if(currentPage < 1) currentPage = 1;
      return totalPages;
    }

    function getCurrentPageItems(){
      const start = (currentPage - 1) * PAGE_SIZE;
      return filteredResults.slice(start, start + PAGE_SIZE);
    }

    function animatePageTransition(callback){
      if(!listEl){ callback(); return; }
      listEl.classList.add('list--fading');
      setTimeout(()=>{
        callback();
        requestAnimationFrame(()=> listEl.classList.remove('list--fading'));
      }, 200);
    }

    function buildPageList(totalPages){
      if(totalPages <= 7){
        return Array.from({ length: totalPages }, (_, idx)=> idx + 1);
      }
      const slots = new Set([1, totalPages, currentPage, currentPage - 1, currentPage + 1]);
      if(currentPage <= 3){ slots.add(2); slots.add(3); slots.add(4); }
      if(currentPage >= totalPages - 2){ slots.add(totalPages - 1); slots.add(totalPages - 2); slots.add(totalPages - 3); }
      const ordered = Array.from(slots).filter(p=>p >= 1 && p <= totalPages).sort((a,b)=>a-b);
      const result = [];
      ordered.forEach((page, idx)=>{
        if(idx>0 && page - ordered[idx-1] > 1){
          result.push('ellipsis');
        }
        result.push(page);
      });
      return result;
    }

    function renderPaginationControls(totalPages){
      if(!paginationEl) return;
      if(filteredResults.length <= PAGE_SIZE){
        paginationEl.innerHTML = '';
        paginationEl.classList.add('paginationBar--hidden');
        return;
      }
      paginationEl.classList.remove('paginationBar--hidden');
      paginationEl.innerHTML = '';
      const createBtn = (label, opts = {})=>{
        const btn = document.createElement('button');
        btn.className = 'pageBtn';
        if(opts.nav) btn.classList.add('pageBtn--nav');
        if(opts.active) btn.classList.add('pageBtn--active');
        btn.textContent = label;
        btn.disabled = !!opts.disabled;
        if(!btn.disabled && typeof opts.onClick === 'function'){
          btn.addEventListener('click', opts.onClick);
        }
        return btn;
      };
      paginationEl.appendChild(createBtn('‹ Previous', { nav:true, disabled: currentPage === 1, onClick: ()=> goToPage(currentPage - 1) }));
      buildPageList(totalPages).forEach(entry=>{
        if(entry === 'ellipsis'){
          const span = document.createElement('span');
          span.className = 'pageEllipsis';
          span.textContent = '...';
          paginationEl.appendChild(span);
        }else{
          const pageNumber = Number(entry);
          paginationEl.appendChild(createBtn(String(pageNumber), {
            active: pageNumber === currentPage,
            onClick: ()=> goToPage(pageNumber)
          }));
        }
      });
      const total = Math.max(1, totalPages);
      paginationEl.appendChild(createBtn('Next ›', { nav:true, disabled: currentPage === total, onClick: ()=> goToPage(currentPage + 1) }));
    }

    function goToPage(page){
      const totalPages = ensureValidPage();
      const target = Math.min(Math.max(page,1), totalPages);
      if(target === currentPage) return;
      currentPage = target;
      refreshListView({ animate:true });
    }

    function refreshListView(opts = {}){
      const { refilter = false, resetPage = false, animate = false } = opts;
      if(refilter){ updateFilteredResults(); }
      if(resetPage) currentPage = 1;
      const totalPages = ensureValidPage();
      const items = getCurrentPageItems();
      const renderNow = ()=> render(items);
      if(animate){
        animatePageTransition(renderNow);
      }else{
        renderNow();
      }
      renderPaginationControls(totalPages);
    }

    search.addEventListener('input', ()=>{
      refreshListView({ refilter:true, resetPage:true, animate:true });
    });

    // Add button opens Discord invite (manual additions are done by editing the file)
    document.getElementById('newEntry').addEventListener('click', ()=>{
      window.open('https://discord.gg/VqwDPu6K', '_blank');
    });

    /*
      GitHub auto-save configuration (client-side fallback)
      WARNING: Do NOT place a PAT here in production. Use the serverless endpoint below instead.
    */
    const GITHUB = {
      owner: '', // e.g. 'your-username'
      repo: '',  // e.g. 'JJS-Library'
      path: 'libs', // path inside repo to save files
      branch: 'main',
      token: '' // insecure: only for quick testing
    };

    // Serverless endpoint (preferred). If deployed on Vercel you can use
    // https://<your-project>.vercel.app/api/save-lib. Defaulting to your known deploy URL.
    const SERVERLESS_URL = 'https://jjs-libraries.vercel.app/api/save-lib';

    // Users endpoint derived from serverless base
    const USERS_URL = SERVERLESS_URL.replace(/\/save-lib$/,'/users');
    const OWNER_USERNAME = 'Kuro';
    const OWNER_USERNAME_LOWER = OWNER_USERNAME.toLowerCase();
    const socialCache = new Map();
    const staffState = { owner: null, moderators: [] };
    const userDataCache = { fallbackUsers: null, lastFetched: 0 };
    const USERS_FILE_CANDIDATES = [
      'users/users.json','users/users.txt','users/users','users.json','users.txt','users'
    ];

    function getRepoDefaults(){
      return {
        owner: GITHUB.owner || 'ItzKuroYT',
        repo: GITHUB.repo || 'JJS-Libraries',
        branch: GITHUB.branch || 'main'
      };
    }

    function encodePathForRaw(input){
      return input.split('/').map(seg=>encodeURIComponent(seg)).join('/');
    }

    function normalizeUserRecord(raw, idx){
      if(!raw) return null;
      if(typeof raw === 'string'){
        const trimmed = raw.trim();
        if(!trimmed) return null;
        return { id: String(idx ?? trimmed), username: trimmed, role: 'member' };
      }
      const username = (raw.username || raw.user || raw.name || raw.id || '').toString().trim();
      if(!username) return null;
      return {
        id: raw.id || String(idx ?? username),
        username,
        role: raw.role || raw.type || 'member'
      };
    }

    function parseUsersPayload(payload){
      if(!payload) return [];
      if(Array.isArray(payload)) return payload.map((item, idx)=> normalizeUserRecord(item, idx)).filter(Boolean);
      if(payload && Array.isArray(payload.users)) return payload.users.map((item, idx)=> normalizeUserRecord(item, idx)).filter(Boolean);
      return [];
    }

    async function fetchUsersFallback(force = false){
      const now = Date.now();
      if(!force && userDataCache.fallbackUsers && (now - userDataCache.lastFetched) < 60000){
        return userDataCache.fallbackUsers;
      }
      const { owner, repo, branch } = getRepoDefaults();
      const customPath = (window.USERS_FILE_PATH || '').trim();
      const candidates = [];
      if(customPath) candidates.push(customPath);
      USERS_FILE_CANDIDATES.forEach(path=>candidates.push(path));
      const tried = new Set();
      for(const candidateRaw of candidates){
        if(!candidateRaw) continue;
        const clean = candidateRaw.replace(/^\/+/,'');
        if(!clean || tried.has(clean)) continue;
        tried.add(clean);
        const url = `https://raw.githubusercontent.com/${owner}/${repo}/${branch}/${encodePathForRaw(clean)}`;
        try{
          const resp = await fetch(url, { cache: 'no-store' });
          if(!resp.ok) continue;
          const text = await resp.text();
          if(!text) continue;
          let normalized = null;
          try{
            const parsedJson = JSON.parse(text);
            normalized = parseUsersPayload(parsedJson);
          }catch(_err){
            const lines = text.split(/\r?\n/).map(line=>line.trim()).filter(Boolean);
            if(lines.length){
              normalized = lines.map((line, idx)=> normalizeUserRecord(line, idx)).filter(Boolean);
            }
          }
          if(normalized && normalized.length){
            userDataCache.fallbackUsers = normalized;
            userDataCache.lastFetched = now;
            return normalized;
          }
        }catch(_err){ /* ignore and try next */ }
      }
      return null;
    }

    function getOwnerFromFallback(usersList){
      if(!Array.isArray(usersList)) return OWNER_USERNAME ? { id: OWNER_USERNAME, username: OWNER_USERNAME } : null;
      const ownerMatch = usersList.find(u=> u && ((u.role || '').toLowerCase() === 'owner' || (u.username || '').toLowerCase() === OWNER_USERNAME_LOWER));
      if(ownerMatch) return { id: ownerMatch.id || ownerMatch.username, username: ownerMatch.username };
      return OWNER_USERNAME ? { id: OWNER_USERNAME, username: OWNER_USERNAME } : null;
    }

    function getModeratorsFromFallback(usersList){
      if(!Array.isArray(usersList)) return [];
      return usersList.filter(u=> (u.role || '').toLowerCase() === 'moderator').map(u=>({ id: u.id || u.username, username: u.username }));
    }

    function inferRoleFromState(username){
      const normalized = (username || '').toLowerCase();
      if(!normalized) return 'member';
      if(staffState.owner && staffState.owner.username && staffState.owner.username.toLowerCase() === normalized) return 'owner';
      if(staffState.moderators.some(mod=> (mod.username || '').toLowerCase() === normalized)) return 'moderator';
      if(OWNER_USERNAME_LOWER && normalized === OWNER_USERNAME_LOWER) return 'owner';
      return 'member';
    }

    function inferRoleFromPayload(payload){
      if(!payload) return 'member';
      if(payload.role) return payload.role;
      return inferRoleFromState(payload.username);
    }

    async function refreshUserCount(){
      const label = document.getElementById('currentUsersValue');
      if(!label) return;
      if(!USERS_URL){ label.textContent = 'n/a'; return; }
      label.textContent = '...';
      try{
        const resp = await fetch(USERS_URL + '?action=list');
        const data = await resp.json().catch(()=>null);
        if(!resp.ok || !data || !data.ok) throw new Error('Failed to load');
        label.textContent = Number(data.count) || 0;
        label.removeAttribute('title');
      }catch(err){
        try{
          const fallbackUsers = await fetchUsersFallback();
          if(fallbackUsers && fallbackUsers.length){
            label.textContent = fallbackUsers.length;
            label.title = 'Loaded from GitHub users file';
          }else{
            label.textContent = '??';
            label.title = 'Unable to load user count';
          }
        }catch(_fallbackErr){
          label.textContent = '??';
          label.title = 'Unable to load user count';
        }
      }
    }

    function updateTotalLibrariesDisplay(){
      const label = document.getElementById('totalLibrariesValue');
      if(!label) return;
      const viewer = getCurrentUser();
      const total = Array.isArray(libs) ? libs.filter(lib=>isLibVisibleToUser(lib, viewer)).length : 0;
      label.textContent = total;
    }

    async function refreshStaffDisplay(){
      const ownerEl = document.getElementById('staffOwnerValue');
      const modsWrap = document.getElementById('staffModerators');
      if(!ownerEl || !modsWrap) return;
      ownerEl.textContent = 'Loading...';
      modsWrap.innerHTML = '<span class="staffPill">Loading...</span>';
      let ownerRecord = null;
      let moderators = [];
      let usedFallback = false;
      let apiError = false;
      if(USERS_URL){
        try{
          const resp = await fetch(USERS_URL + '?action=staff');
          const data = await resp.json().catch(()=>null);
          if(!resp.ok || !data || !data.ok) throw new Error((data && data.error) || 'Failed to load staff');
          ownerRecord = data.owner || null;
          moderators = Array.isArray(data.moderators) ? data.moderators : [];
        }catch(_err){
          apiError = true;
        }
      }else{
        apiError = true;
      }
      let fallbackUsers = null;
      if(apiError || !ownerRecord || !moderators.length){
        try{
          fallbackUsers = await fetchUsersFallback();
        }catch(_err){ fallbackUsers = null; }
      }
      if(!ownerRecord && fallbackUsers){
        ownerRecord = getOwnerFromFallback(fallbackUsers);
        usedFallback = true;
      }
      if((!moderators.length) && fallbackUsers){
        const fallbackMods = getModeratorsFromFallback(fallbackUsers);
        if(fallbackMods.length){
          moderators = fallbackMods;
          usedFallback = true;
        }
      }
      if(!ownerRecord){
        ownerRecord = OWNER_USERNAME ? { id: OWNER_USERNAME, username: OWNER_USERNAME } : { id: 'owner', username: '—' };
      }
      staffState.owner = ownerRecord;
      staffState.moderators = moderators;
      ownerEl.textContent = ownerRecord.username || '—';
      if(usedFallback){
        ownerEl.title = 'Loaded from GitHub users file';
      }else{
        ownerEl.removeAttribute('title');
      }
      modsWrap.innerHTML = '';
      if(!moderators.length){
        const span = document.createElement('span');
        span.className = 'staffPill';
        span.textContent = apiError ? 'Staff unavailable' : 'No moderators yet';
        if(apiError) span.classList.add('staffError');
        modsWrap.appendChild(span);
      }else{
        moderators.forEach(mod=>{
          const span = document.createElement('span');
          span.className = 'staffPill';
          span.textContent = mod.username;
          modsWrap.appendChild(span);
        });
        modsWrap.removeAttribute('title');
      }
      updateAddModeratorButton();
      updateStaffConsoleVisibility();
      refreshListView({ refilter:true });
    }

    function updateAddModeratorButton(){
      const btn = document.getElementById('addModeratorBtn');
      if(!btn) return;
      const user = getCurrentUser();
      const ownerName = staffState.owner && staffState.owner.username ? staffState.owner.username.toLowerCase() : '';
      const userMatch = user && user.username ? user.username.toLowerCase() : '';
      const isOwner = !!(user && (user.role === 'owner' || (ownerName && ownerName === userMatch) || (OWNER_USERNAME_LOWER && OWNER_USERNAME_LOWER === userMatch)));
      btn.style.display = isOwner ? 'inline-flex' : 'none';
      if(!isOwner){
        btn.disabled = false;
        btn.textContent = 'Add Moderator';
      }
    }

    async function promoteToModerator(username){
      const targetName = (username || '').trim();
      if(!targetName) throw new Error('username required');
      if(!USERS_URL) throw new Error('Users endpoint unavailable');
      const token = getToken();
      if(!token) throw new Error('Sign in as the owner to add staff');
      const resp = await fetch(USERS_URL + '?action=addModerator', {
        method:'POST',
        headers:{'Content-Type':'application/json','Authorization':'Bearer ' + token},
        body: JSON.stringify({ username: targetName })
      });
      const data = await resp.json().catch(()=>null);
      if(!resp.ok || !data || !data.ok) throw new Error((data && data.error) || 'Failed to update staff');
      return data.user;
    }

    async function demoteModerator(username){
      const targetName = (username || '').trim();
      if(!targetName) throw new Error('username required');
      if(!USERS_URL) throw new Error('Users endpoint unavailable');
      const token = getToken();
      if(!token) throw new Error('Sign in as the owner to update staff');
      const resp = await fetch(USERS_URL + '?action=removeModerator', {
        method:'POST',
        headers:{'Content-Type':'application/json','Authorization':'Bearer ' + token},
        body: JSON.stringify({ username: targetName })
      });
      const data = await resp.json().catch(()=>null);
      if(!resp.ok || !data || !data.ok) throw new Error((data && data.error) || 'Failed to update staff');
      return data.user;
    }

    async function handleAddModeratorClick(){
      const btn = document.getElementById('addModeratorBtn');
      if(!btn) return;
      const input = prompt('Enter username to promote to moderator');
      if(!input) return;
      const target = input.trim();
      if(!target) return;
      const original = btn.textContent;
      btn.disabled = true;
      btn.textContent = 'Adding...';
      try{
        const promoted = await promoteToModerator(target);
        const displayName = promoted && promoted.username ? promoted.username : target;
        addNotification(displayName + ' is now a moderator');
        await refreshStaffDisplay();
      }catch(err){
        alert(err && err.message ? err.message : 'Failed to add moderator');
      }finally{
        btn.disabled = false;
        btn.textContent = original;
      }
    }

    async function runStaffConsoleCommand(command){
      const match = command.match(/^\?(mod|unmod)\s+(.+)$/i);
      if(!match) throw new Error('Use ?mod username or ?unmod username');
      const action = match[1].toLowerCase();
      let target = match[2].trim();
      if(target.startsWith('(') && target.endsWith(')')) target = target.slice(1, -1).trim();
      if(!target) throw new Error('Username required');
      if(action === 'mod'){
        const promoted = await promoteToModerator(target);
        const name = promoted && promoted.username ? promoted.username : target;
        addNotification(name + ' promoted to moderator');
        await refreshStaffDisplay();
        return name + ' promoted to moderator';
      }
      const demoted = await demoteModerator(target);
      const name = demoted && demoted.username ? demoted.username : target;
      addNotification(name + ' removed from moderators');
      await refreshStaffDisplay();
      return name + ' removed from moderators';
    }

    async function handleStaffConsoleSubmit(ev){
      if(ev) ev.preventDefault();
      const inputEl = document.getElementById('staffConsoleInput');
      const statusEl = document.getElementById('staffConsoleStatus');
      if(!inputEl) return;
      const command = inputEl.value.trim();
      if(!command){
        if(statusEl) statusEl.textContent = 'Enter a command';
        return;
      }
      if(statusEl) statusEl.textContent = 'Running...';
      try{
        const resultText = await runStaffConsoleCommand(command);
        if(statusEl) statusEl.textContent = resultText;
        inputEl.value = '';
      }catch(err){
        if(statusEl) statusEl.textContent = err && err.message ? err.message : 'Command failed';
      }
    }

    function updateStaffConsoleVisibility(){
      const consoleBlock = document.getElementById('staffConsoleBlock');
      if(!consoleBlock) return;
      const user = getCurrentUser();
      const normalized = user && user.username ? user.username.toLowerCase() : '';
      const isOwner = !!(user && (user.role === 'owner' || (normalized && (normalized === OWNER_USERNAME_LOWER))));
      consoleBlock.style.display = isOwner ? 'block' : 'none';
      if(!isOwner){
        const statusEl = document.getElementById('staffConsoleStatus');
        if(statusEl) statusEl.textContent = '';
        const inputEl = document.getElementById('staffConsoleInput');
        if(inputEl) inputEl.value = '';
      }
    }

    function normalizeUsernameForPath(username){
      return (username || '').toString().trim().replace(/[^a-z0-9_-]/gi,'_');
    }

    function normalizeUsernameKey(username){
      return normalizeUsernameForPath(username).toLowerCase();
    }

    function getSocialStorageKey(username){
      return 'jjs_social_' + normalizeUsernameKey(username);
    }

    function getAvatarStorageKey(username){
      return 'jjs_avatar_url_' + normalizeUsernameKey(username);
    }

    function getStoredAvatarUrl(username){
      try{
        if(username){
          return localStorage.getItem(getAvatarStorageKey(username)) || '';
        }
        return localStorage.getItem('jjs_avatar_url') || '';
      }catch(_e){
        return '';
      }
    }

    function getAvatarBasePath(){
      const configured = (GITHUB.avatarsPath || '').replace(/^\/+/, '').replace(/\/+$/, '');
      if(configured) return configured;
      const basePath = (GITHUB.path || '').replace(/^\/+/, '').replace(/\/+$/, '');
      return basePath ? `${basePath}/avatars` : 'avatars';
    }

    function buildAvatarUrls(username){
      const safeUser = normalizeUsernameForPath(username);
      if(!safeUser) return [];
      const owner = GITHUB.owner || 'ItzKuroYT';
      const repo = GITHUB.repo || 'JJS-Libraries';
      const branch = GITHUB.branch || 'main';
      const avatarBasePath = getAvatarBasePath();
      const exts = ['png','jpg','jpeg','webp','gif'];
      return exts.map(ext=>{
        const remotePath = avatarBasePath ? `${avatarBasePath}/${safeUser}.${ext}` : `${safeUser}.${ext}`;
        return `https://raw.githubusercontent.com/${owner}/${repo}/${branch}/${encodePathForRaw(remotePath)}`;
      });
    }

    function buildAvatarUrl(username){
      const urls = buildAvatarUrls(username);
      return urls[0] || DEFAULT_AVATAR_URL;
    }

    function getAvatarSourceBundle(username, social){
      const normalizedSocialUrl = social && typeof social.avatar_url === 'string' ? social.avatar_url.trim() : '';
      const storedAvatarUrl = getStoredAvatarUrl(username);
      const candidateUrls = buildAvatarUrls(username);
      const primary = normalizedSocialUrl || storedAvatarUrl || candidateUrls[0] || DEFAULT_AVATAR_URL;
      const fallbackSources = [];
      const seen = new Set([primary, DEFAULT_AVATAR_URL, FALLBACK_AVATAR_DATA_URI]);
      candidateUrls.forEach(url=>{
        if(!url || seen.has(url)) return;
        seen.add(url);
        fallbackSources.push(url);
      });
      return {
        src: primary,
        stage: primary && primary !== DEFAULT_AVATAR_URL && primary !== FALLBACK_AVATAR_DATA_URI ? 'remote' : 'default',
        fallbackSources
      };
    }

    function resolveAvatarUrl(username, social){
      return getAvatarSourceBundle(username, social).src || DEFAULT_AVATAR_URL;
    }

    function setAvatarImage(imgEl, opts = {}){
      if(!imgEl) return;
      const wrapper = opts.wrapper || null;
      const requestedSrc = typeof opts.src === 'string' ? opts.src.trim() : '';
      const resolvedSrc = requestedSrc || DEFAULT_AVATAR_URL;
      const resolvedStage = opts.stage || ((requestedSrc && requestedSrc !== DEFAULT_AVATAR_URL && requestedSrc !== FALLBACK_AVATAR_DATA_URI) ? 'remote' : 'default');
      const fallbackSources = Array.isArray(opts.fallbackSources)
        ? opts.fallbackSources.filter(src=> typeof src === 'string' && src.trim() && src.trim() !== requestedSrc)
        : [];
      const updateWrapper = (filled)=>{
        if(!wrapper) return;
        wrapper.style.background = filled ? 'none' : 'rgba(255,255,255,0.08)';
      };
      const applySource = (srcValue, stageValue)=>{
        imgEl.dataset.avatarStage = stageValue;
        imgEl.src = srcValue;
      };
      imgEl.onload = ()=> updateWrapper(true);
      imgEl.onerror = ()=>{
        const stage = imgEl.dataset.avatarStage || 'remote';
        if(stage === 'remote'){
          if(fallbackSources.length){
            const nextSrc = fallbackSources.shift();
            applySource(nextSrc, 'remote');
            return;
          }
          applySource(DEFAULT_AVATAR_URL, 'default');
          updateWrapper(false);
          return;
        }
        if(stage === 'default'){
          applySource(FALLBACK_AVATAR_DATA_URI, 'inline');
          updateWrapper(false);
          return;
        }
        imgEl.onerror = null;
      };
      applySource(resolvedSrc, resolvedStage);
      updateWrapper(resolvedStage === 'remote');
    }

    // --- Authentication helpers (client-side) ---
    function setToken(tok){
      try{
        if(tok) localStorage.setItem('jjs_token', tok);
        else localStorage.removeItem('jjs_token');
      }catch(e){}
      updateUserLabel();
      updateAddModeratorButton();
      updateStaffConsoleVisibility();
      refreshListView({ refilter:true });
    }
    function getToken(){ try{ return localStorage.getItem('jjs_token'); }catch(e){return null;} }
    function decodeToken(tok){ if(!tok) return null; try{ const parts = tok.split('.'); if(parts.length<2) return null; const payload = parts[1]; const json = JSON.parse(atob(payload.replace(/-/g,'+').replace(/_/g,'/'))); return json; }catch(e){return null;} }
    function getCurrentUser(){
      const tok = getToken();
      const p = decodeToken(tok);
      if(!p || !p.username) return null;
      const role = inferRoleFromPayload(p) || 'member';
      return { username: p.username, id: p.id, role };
    }

    function canDeleteLibrary(user, lib){
      if(!user || !lib) return false;
      if(user.role === 'owner' || user.role === 'moderator') return true;
      return user.username === lib.author;
    }
    function updateUserLabel(){
      const lbl = document.getElementById('userLabel');
      if(!lbl) return;
      const u = getCurrentUser();
      if(u){
        const roleLabel = u.role && u.role !== 'member' ? ` (${u.role})` : '';
        lbl.textContent = `Signed in: ${u.username}${roleLabel}`;
      }else{
        lbl.textContent = '';
      }
    }

    async function authSignup(username,password){
      try{
        const resp = await fetch(USERS_URL + '?action=signup', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ username, password }) });
        const j = await resp.json().catch(()=>null);
        if(!resp.ok) throw new Error(JSON.stringify(j));
        if(j && j.token) setToken(j.token);
        try{ await Promise.all([refreshUserCount(), refreshStaffDisplay()]); }catch(_err){}
        return j;
      }catch(err){ return null; }
    }

    async function authLogin(username,password){
      try{
        const resp = await fetch(USERS_URL + '?action=login', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ username, password }) });
        const j = await resp.json().catch(()=>null);
        if(!resp.ok) throw new Error(JSON.stringify(j));
        if(j && j.token) setToken(j.token);
        try{ await refreshStaffDisplay(); }catch(_err){}
        return j;
      }catch(err){ return null; }
    }

    // attach auth button handlers
    document.getElementById('signupBtn').addEventListener('click', ()=>{
      const u = document.getElementById('authUser').value.trim();
      const p = document.getElementById('authPass').value;
      if(!u||!p) return alert('username and password required');
      authSignup(u,p);
    });
    document.getElementById('loginBtn').addEventListener('click', ()=>{
      const u = document.getElementById('authUser').value.trim();
      const p = document.getElementById('authPass').value;
      if(!u||!p) return alert('username and password required');
      authLogin(u,p);
    });
    updateUserLabel();
    updateStaffConsoleVisibility();

    // --- Tag picker ---
    const PRESET_TAGS = ['Beginner moveset','Intermediate moveset','Advanced moveset','Custom','JJK','Dragonball','Sololeveling','Video-game','OP'];
    function renderTagPicker(){
      const wrap = document.getElementById('tagPicker'); if(!wrap) return;
      wrap.innerHTML = '';
      PRESET_TAGS.forEach(t=>{
        const id = 'tag_' + t.replace(/[^a-z0-9]/gi,'_');
        const label = document.createElement('label'); label.style.display='inline-flex'; label.style.alignItems='center'; label.style.gap='6px';
        const cb = document.createElement('input'); cb.type='checkbox'; cb.value = t; cb.id = id;
        const span = document.createElement('span'); span.textContent = t; span.className='small';
        label.appendChild(cb); label.appendChild(span); wrap.appendChild(label);
      });
    }

    function getSelectedTags(){
      const wrap = document.getElementById('tagPicker'); if(!wrap) return [];
      const checks = Array.from(wrap.querySelectorAll('input[type="checkbox"]'));
      return checks.filter(i=>i.checked).map(i=>i.value);
    }

    function cloneTagPickerElement(){
      const source = document.getElementById('tagPicker');
      if(!source){
        const fallback = document.createElement('div');
        fallback.className = 'tagPicker';
        return fallback;
      }
      const clone = source.cloneNode(true);
      clone.removeAttribute('id');
      return clone;
    }

    function applySelectedTagsToPicker(pickerEl, selectedTags){
      if(!pickerEl) return;
      const selected = new Set((selectedTags || []).map(tag=> (tag || '').toLowerCase()));
      const checkboxes = pickerEl.querySelectorAll('input[type="checkbox"]');
      checkboxes.forEach(cb=>{
        cb.checked = selected.has((cb.value || '').toLowerCase());
      });
    }

    function collectTagsFromPicker(pickerEl){
      if(!pickerEl) return [];
      const checkboxes = Array.from(pickerEl.querySelectorAll('input[type="checkbox"]'));
      return checkboxes.filter(cb=>cb.checked).map(cb=>cb.value);
    }

    function openLibraryModal(options = {}){
      const { mode = 'create', lib = null, onSubmit } = options;
      if(typeof onSubmit !== 'function') throw new Error('onSubmit callback required');
      const isEdit = mode === 'edit';
      const heading = isEdit ? 'Edit Library' : 'Create New Library';
      const submitLabel = isEdit ? 'Save changes' : 'Post';
      const savingLabel = isEdit ? 'Saving...' : 'Posting...';
      const existing = document.getElementById('libraryModal');
      if(existing) existing.remove();
      const modal = document.createElement('div');
      modal.id = 'libraryModal';
      Object.assign(modal.style, {
        position: 'fixed',
        left: '0',
        top: '0',
        width: '100vw',
        height: '100vh',
        background: 'rgba(0,0,0,0.55)',
        zIndex: '9999',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center'
      });
      modal.innerHTML = `<div style="background:var(--card);padding:24px 18px 18px 18px;min-width:340px;max-width:98vw;max-height:90vh;overflow:auto;border-radius:12px;box-shadow:0 8px 32px #000a;position:relative;">
        <button id="closeLibraryModal" style="position:absolute;top:10px;right:10px;" class="ghost" type="button">Close</button>
        <h3 style="margin-top:0">${heading}</h3>
        <form id="libraryForm">
          <div style="margin-bottom:10px"><input id="libraryTitle" placeholder="Title" style="width:100%;padding:8px;border-radius:6px;border:1px solid #333" maxlength="60" required></div>
          <div style="margin-bottom:10px"><textarea id="libraryDesc" placeholder="Description (max 250 chars)" maxlength="250" style="width:100%;min-height:48px;padding:8px;border-radius:6px;border:1px solid #333" required></textarea><div class="smallMuted" id="libraryDescCount"></div></div>
          <div style="margin-bottom:10px"><input id="libraryCredit" placeholder="Credit / original link (optional)" style="width:100%;padding:8px;border-radius:6px;border:1px solid #333"></div>
          <div style="margin-bottom:10px"><textarea id="libraryCode" placeholder="Paste code here" style="width:100%;min-height:80px;padding:8px;border-radius:6px;border:1px solid #333" required></textarea></div>
          <div style="margin-bottom:12px">
            <label class="smallMuted" style="display:block;margin-bottom:4px">Attach a gameplay video (optional, max 60s, under ${formatBytes(VIDEO_MAX_SIZE_BYTES)})</label>
            <input id="libraryVideoInput" type="file" accept="video/mp4,video/webm,video/ogg" style="width:100%;padding:8px;border-radius:6px;border:1px solid #333">
            <div style="display:flex;gap:8px;align-items:center;margin-top:6px">
              <div class="smallMuted" id="libraryVideoStatus"></div>
              <button type="button" class="ghost" id="libraryVideoRemove" style="display:none">Remove video</button>
            </div>
          </div>
          <div style="margin-bottom:12px;display:flex;align-items:center;justify-content:space-between;gap:12px">
            <span class="smallMuted">Visibility</span>
            <button type="button" id="libraryVisibilityToggle" class="ghost" data-visibility="public">Public</button>
          </div>
          <div style="margin-bottom:10px"><span class="smallMuted">Tags: (select below before posting)</span></div>
          <div id="libraryModalTagContainer" style="display:flex;gap:8px;align-items:center;margin-bottom:10px;flex-wrap:wrap"></div>
          <button type="submit" class="ghost" id="librarySubmitBtn">${submitLabel}</button>
        </form>
      </div>`;
      document.body.appendChild(modal);
      const closeBtn = modal.querySelector('#closeLibraryModal');
      if(closeBtn) closeBtn.addEventListener('click', ()=>modal.remove());
      const form = modal.querySelector('#libraryForm');
      const titleInput = form.querySelector('#libraryTitle');
      const descInput = form.querySelector('#libraryDesc');
      const descCount = form.querySelector('#libraryDescCount');
      const creditInput = form.querySelector('#libraryCredit');
      const codeInput = form.querySelector('#libraryCode');
      const submitBtn = form.querySelector('#librarySubmitBtn');
      const visibilityToggleBtn = form.querySelector('#libraryVisibilityToggle');
      const tagContainer = form.querySelector('#libraryModalTagContainer');
      const initial = {
        title: lib && typeof lib.title === 'string' ? lib.title : '',
        description: lib && typeof lib.description === 'string' ? lib.description : '',
        credit: lib && typeof lib.credit === 'string' ? lib.credit : '',
        code: lib && typeof lib.code === 'string' ? lib.code : '',
        tags: Array.isArray(lib && lib.tags) ? lib.tags.slice() : [],
        visibility: normalizeVisibility(lib && lib.visibility)
      };
      titleInput.value = initial.title;
      descInput.value = initial.description;
      if(descCount) descCount.textContent = initial.description ? `${initial.description.length}/250` : '';
      descInput.addEventListener('input', ()=>{
        descCount.textContent = descInput.value.length ? descInput.value.length + '/250' : '';
      });
      creditInput.value = initial.credit;
      codeInput.value = initial.code;
      const modalTagPicker = cloneTagPickerElement();
      if(tagContainer){
        tagContainer.innerHTML = '';
        tagContainer.appendChild(modalTagPicker);
      }
      applySelectedTagsToPicker(modalTagPicker, initial.tags);
      let currentVisibility = initial.visibility;
      const applyVisibilityState = ()=>{
        const isPrivate = currentVisibility === VISIBILITY.PRIVATE;
        visibilityToggleBtn.textContent = isPrivate ? 'Private' : 'Public';
        visibilityToggleBtn.dataset.visibility = currentVisibility;
        visibilityToggleBtn.title = isPrivate ? 'Private — only you can view this post' : 'Public — everyone can see this post';
      };
      visibilityToggleBtn.addEventListener('click', ()=>{
        currentVisibility = currentVisibility === VISIBILITY.PRIVATE ? VISIBILITY.PUBLIC : VISIBILITY.PRIVATE;
        applyVisibilityState();
      });
      applyVisibilityState();
      const videoInput = form.querySelector('#libraryVideoInput');
      const videoStatus = form.querySelector('#libraryVideoStatus');
      const videoRemoveBtn = form.querySelector('#libraryVideoRemove');
      const originalVideo = lib && lib.video ? lib.video : null;
      let selectedVideo = null;
      let videoRemoved = false;
      const describeVideo = (video)=>{
        if(!video) return '';
        const parts = [];
        if(Number.isFinite(video.duration)) parts.push(`Duration ${formatVideoDuration(video.duration)}`);
        if(typeof video.size === 'number') parts.push(formatBytes(video.size));
        if(video.name) parts.push(censorBadWords(video.name));
        return parts.join(' • ');
      };
      const updateVideoStatus = ()=>{
        if(!videoStatus) return;
        if(videoRemoved){
          videoStatus.textContent = 'Video will be removed when you save.';
          if(videoRemoveBtn){
            videoRemoveBtn.style.display = originalVideo ? 'inline-flex' : 'none';
            videoRemoveBtn.textContent = 'Undo remove';
          }
          return;
        }
        if(selectedVideo){
          videoStatus.textContent = describeVideo(selectedVideo) || 'Ready to attach.';
          if(videoRemoveBtn){
            videoRemoveBtn.style.display = 'inline-flex';
            videoRemoveBtn.textContent = originalVideo ? 'Remove video' : 'Clear video';
          }
          return;
        }
        if(originalVideo){
          videoStatus.textContent = describeVideo(originalVideo) || 'Current video attached.';
          if(videoRemoveBtn){
            videoRemoveBtn.style.display = 'inline-flex';
            videoRemoveBtn.textContent = 'Remove video';
          }
          return;
        }
        videoStatus.textContent = 'No video attached.';
        if(videoRemoveBtn){
          videoRemoveBtn.style.display = 'none';
        }
      };
      updateVideoStatus();
      if(videoInput){
        videoInput.addEventListener('change', async ()=>{
          if(!videoInput.files || !videoInput.files[0]){
            selectedVideo = null;
            if(!originalVideo) videoRemoved = false;
            updateVideoStatus();
            return;
          }
          if(videoStatus) videoStatus.textContent = 'Processing video...';
          try{
            selectedVideo = await processVideoFile(videoInput.files[0]);
            videoRemoved = false;
            updateVideoStatus();
          }catch(err){
            alert(err && err.message ? err.message : 'Video processing failed');
            videoInput.value = '';
            selectedVideo = null;
            if(!originalVideo) videoRemoved = false;
            updateVideoStatus();
          }
        });
      }
      if(videoRemoveBtn){
        videoRemoveBtn.addEventListener('click', ()=>{
          if(videoRemoved){
            videoRemoved = false;
            updateVideoStatus();
            return;
          }
          if(selectedVideo){
            selectedVideo = null;
            if(videoInput) videoInput.value = '';
            if(!originalVideo) videoRemoved = false;
            updateVideoStatus();
            return;
          }
          if(originalVideo){
            videoRemoved = true;
            if(videoInput) videoInput.value = '';
            updateVideoStatus();
          }
        });
      }
      form.addEventListener('submit', async (ev)=>{
        ev.preventDefault();
        const payload = {
          title: titleInput.value.trim(),
          description: descInput.value.trim(),
          credit: creditInput.value.trim(),
          code: codeInput.value,
          tags: collectTagsFromPicker(modalTagPicker),
          visibility: currentVisibility,
          video: selectedVideo || (videoRemoved ? null : originalVideo),
          videoRemoved: !!videoRemoved
        };
        if(submitBtn){
          submitBtn.disabled = true;
          submitBtn.textContent = savingLabel;
        }
        try{
          await onSubmit(payload);
          modal.remove();
        }catch(err){
          alert(err && err.message ? err.message : 'Failed to save post');
          if(submitBtn){
            submitBtn.disabled = false;
            submitBtn.textContent = submitLabel;
          }
        }
      });
    }

    document.getElementById('addTagBtn').addEventListener('click', ()=>{
      const v = (document.getElementById('customTag').value||'').trim();
      if(!v) return; const wrap = document.getElementById('tagPicker');
      // avoid duplicates
      const exists = Array.from(wrap.querySelectorAll('input')).some(i=>i.value.toLowerCase()===v.toLowerCase());
      if(exists){ document.getElementById('customTag').value=''; return; }
      const id = 'tag_' + v.replace(/[^a-z0-9]/gi,'_');
      const label = document.createElement('label'); label.style.display='inline-flex'; label.style.alignItems='center'; label.style.gap='6px';
      const cb = document.createElement('input'); cb.type='checkbox'; cb.value = v; cb.id = id; cb.checked = true;
      const span = document.createElement('span'); span.textContent = v; span.className='small';
      label.appendChild(cb); label.appendChild(span); wrap.appendChild(label);
      document.getElementById('customTag').value = '';
    });

    renderTagPicker();

    const addModeratorBtnEl = document.getElementById('addModeratorBtn');
    if(addModeratorBtnEl){
      addModeratorBtnEl.addEventListener('click', handleAddModeratorClick);
    }

    document.getElementById('createEntry').addEventListener('click', ()=>{
      const currentUser = getCurrentUser();
      if(!currentUser) return alert('You must be signed in to create a library.');
      openLibraryModal({
        mode: 'create',
        onSubmit: async (payload)=>{
          const { title, description, credit, code, tags, visibility, video } = payload;
          if(!title) throw new Error('Title required');
          if(!description) throw new Error('Description required');
          if(description.length > 250) throw new Error('Description too long');
          if(!code) throw new Error('Code required');
          const safeTags = (tags || []).map(tag=>censorBadWords(tag));
          const safeLib = {
            id: Date.now().toString(),
            title: censorBadWords(title),
            description: censorBadWords(description),
            author: censorBadWords(currentUser.username),
            credit,
            code,
            tags: safeTags,
            visibility,
            comments: []
          };
          if(video){
            const attachment = buildVideoAttachment(video);
            if(attachment) safeLib.video = attachment;
          }
          const lib = sanitizeLibraryContent(safeLib);
          libs.push(lib);
          notifyFollowersOfNewPost(lib);
          refreshListView({ refilter:true });
          try{
            const persistResult = await persistLibraryFile(lib, { downloadOnMissingConfig: true, downloadOnFailure: true });
            if(persistResult && persistResult.method === 'github'){
              alert('Saved to repository path: ' + (GITHUB.path ? GITHUB.path + '/' : '') + persistResult.filename);
            }else if(persistResult && persistResult.method === 'download'){
              const reason = persistResult.reason && persistResult.reason.message ? persistResult.reason.message : '';
              const videoNote = lib.video ? '\nVideo attachments are large, so configure SERVERLESS_URL or GitHub to publish automatically.' : '';
              alert('Remote save unavailable — downloaded JSON locally for manual upload.' + (reason ? `\nReason: ${reason}` : '') + videoNote);
            }
          }catch(err){
            console.error('persistLibraryFile failed', err);
            const fallbackName = lib.__filename || `${lib.id || Date.now()}-${sanitizeFilename(lib.title || 'library')}.json`;
            downloadJSON(lib, fallbackName);
            alert('Could not save remotely. Downloaded JSON locally for manual upload.');
          }
        }
      });
    });

    // --- Sidebar / Profile / Notifications / DMs ---
    function fileToDataUrl(file){
      return new Promise((resolve, reject)=>{
        const reader = new FileReader();
        reader.onload = ()=>resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    }

    async function applyAvatarUpdate(username, url){
      if(!username || !url) return;
      const normalizedUser = normalizeUsernameKey(username);
      let social = socialCache.get(normalizedUser) || socialCache.get(username);
      if(!social){
        try{ social = JSON.parse(localStorage.getItem(getSocialStorageKey(username)) || localStorage.getItem('jjs_social_' + username) || '{}'); }
        catch(_e){ social = {}; }
      }
      social = social || {};
      social.avatar_url = url;
      await updateSocial(username, social);
      socialCache.set(normalizedUser, social);
      socialCache.set(username, social);
      try{
        localStorage.setItem(getAvatarStorageKey(username), url);
        localStorage.setItem('jjs_avatar_url', url);
      }catch(_e){}
    }

    async function saveAvatarToServer(file){
      const user = getCurrentUser();
      if(!user) throw new Error('Sign in to upload an avatar.');
      if(!file) throw new Error('No file selected.');
      if(file.size && file.size > 1024 * 1024) throw new Error('Avatar max size is 1MB.');
      const dataUrl = await fileToDataUrl(file);
      const username = user.username;
      if(SERVERLESS_URL){
        try{
          const resp = await fetch(SERVERLESS_URL + '?action=uploadAvatar', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ dataUrl, username }) });
          if(resp.ok){
            const j = await resp.json().catch(()=>null);
            const remoteUrl = (j && j.url) || (j && j.result && j.result.content && j.result.content.download_url);
            if(remoteUrl){
              await applyAvatarUpdate(username, remoteUrl);
              return { url: remoteUrl };
            }
          }
        }catch(_err){ /* fall through to local */ }
      }
      await applyAvatarUpdate(username, dataUrl);
      return { url: dataUrl, local: true };
    }

    document.getElementById('avatarFile').addEventListener('change', async (ev)=>{
      const file = ev.target.files && ev.target.files[0];
      if(!file) return;
      try{
        const result = await saveAvatarToServer(file);
        if(result && result.url){
          const avatarEl = document.getElementById('avatarImg');
          const avatarWrapper = document.getElementById('avatarWrap');
          setAvatarImage(avatarEl, { src: result.url, wrapper: avatarWrapper, stage: 'remote' });
          addNotification('Avatar updated');
          refreshListView({});
        }
      }catch(e){
        alert(e && e.message ? e.message : 'Avatar upload failed.');
      }finally{
        ev.target.value = '';
      }
    });

    function renderSidebar(){
      const u = getCurrentUser(); document.getElementById('sideUsername').textContent = u ? u.username : 'Not signed in';
      const avatarEl = document.getElementById('avatarImg');
      const avatarWrapper = document.getElementById('avatarWrap');
      if(avatarEl){
        const avatarSource = u ? getAvatarSourceBundle(u.username) : { src: DEFAULT_AVATAR_URL, stage: 'default', fallbackSources: [] };
        setAvatarImage(avatarEl, {
          src: avatarSource.src || DEFAULT_AVATAR_URL,
          wrapper: avatarWrapper,
          stage: avatarSource.stage,
          fallbackSources: avatarSource.fallbackSources
        });
      }
      const followSummaryEl = document.getElementById('sideFollowSummary');
      if(followSummaryEl){
        if(!u){
          followSummaryEl.textContent = 'Sign in to follow creators';
        }else{
          followSummaryEl.textContent = 'Loading followers...';
          const viewerName = u.username;
          fetchSocial(viewerName).then(s=>{
            const active = getCurrentUser();
            if(!active || active.username !== viewerName) return;
            const followerCount = Array.isArray(s.followers) ? s.followers.length : 0;
            const followingCount = Array.isArray(s.following) ? s.following.length : 0;
            const followerLabel = followerCount === 1 ? 'follower' : 'followers';
            followSummaryEl.textContent = `${followerCount} ${followerLabel} • ${followingCount} following`;
          }).catch(()=>{ followSummaryEl.textContent = 'Followers unavailable'; });
        }
      }
      // my libs
      const myLibsWrap = document.getElementById('myLibs'); myLibsWrap.innerHTML = '';
      const author = u ? u.username : null;
      const my = author ? libs.filter(l=>l.author===author) : [];
      document.getElementById('myLibCount').textContent = my.length;
      my.slice(0,10).forEach(l=>{ const d = document.createElement('div'); d.className='libItem'; d.textContent = censorBadWords(l.title || ''); myLibsWrap.appendChild(d); });
      renderFriendRequests(); renderNotifications(); renderDMList();
      updateStaffConsoleVisibility();
      if(typeof window.__hydrateProfileEditor === 'function'){
        window.__hydrateProfileEditor();
      }
    }

    // Profile edit UI in sidebar
    (function addProfileEditor(){
      const wrap = document.getElementById('sidebar');
      if(!wrap) return;
      const div = document.createElement('div'); div.className='sideSection';
      div.innerHTML = `<div class="smallMuted">Edit Profile</div>
        <div style="margin-top:6px">
          <textarea id="profileBio" placeholder="Bio" style="width:100%;min-height:60px;padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.04)"></textarea>
          <div style="display:flex;gap:6px;margin-top:6px">
            <button id="saveBio" class="ghost">Save Bio</button>
            <button id="saveAvatar" class="ghost">Save Avatar</button>
            <button id="refreshProfile" class="ghost">Refresh</button>
          </div>
          <div style="margin-top:12px">
            <div class="smallMuted">Profile links</div>
            <div id="profileLinksList" class="profileLinksList smallMuted"></div>
            <div style="display:flex;gap:6px;margin-top:6px;flex-wrap:wrap">
              <input id="profileLinkLabel" placeholder="Label" style="flex:1;padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.04)" />
              <input id="profileLinkUrl" placeholder="https://example.com" style="flex:1;padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.04)" />
              <button id="addProfileLink" type="button" class="ghost">Add</button>
            </div>
            <div style="display:flex;gap:6px;margin-top:6px">
              <button id="saveProfileLinks" class="ghost" style="flex:1">Save Links</button>
              <button id="clearProfileLinks" class="ghost" style="flex:1">Clear All</button>
            </div>
          </div>
          <div id="staffConsoleBlock" style="margin-top:10px;display:none">
            <div class="smallMuted">Staff Console (?mod user / ?unmod user)</div>
            <form id="staffConsoleForm" style="display:flex;gap:6px;margin-top:6px">
              <input id="staffConsoleInput" placeholder="?mod username" style="flex:1;padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.04)" />
              <button type="submit" class="ghost">Run</button>
            </form>
            <div class="smallMuted" id="staffConsoleStatus"></div>
          </div>
        </div>`;
      wrap.appendChild(div);
      const bioInput = document.getElementById('profileBio');
      const linkListEl = document.getElementById('profileLinksList');
      const linkLabelInput = document.getElementById('profileLinkLabel');
      const linkUrlInput = document.getElementById('profileLinkUrl');
      const addLinkBtn = document.getElementById('addProfileLink');
      const saveLinksBtn = document.getElementById('saveProfileLinks');
      const clearLinksBtn = document.getElementById('clearProfileLinks');
      let pendingProfileLinks = [];

      function renderProfileLinksEditor(){
        if(!linkListEl) return;
        if(!pendingProfileLinks.length){
          linkListEl.innerHTML = '<div class="smallMuted">No links added yet</div>';
          return;
        }
        linkListEl.innerHTML = '';
        pendingProfileLinks.forEach((link, idx)=>{
          const row = document.createElement('div');
          row.className = 'profileLinkRow';
          const anchor = document.createElement('a');
          anchor.href = link.url;
          anchor.target = '_blank';
          anchor.rel = 'noopener noreferrer';
          anchor.textContent = link.label;
          anchor.className = 'link';
          anchor.style.flex = '1';
          row.appendChild(anchor);
          const removeBtn = document.createElement('button');
          removeBtn.type = 'button';
          removeBtn.className = 'ghost';
          removeBtn.textContent = 'Remove';
          removeBtn.addEventListener('click', ()=>{
            pendingProfileLinks.splice(idx, 1);
            renderProfileLinksEditor();
          });
          row.appendChild(removeBtn);
          linkListEl.appendChild(row);
        });
      }

      function setProfileLinks(list){
        pendingProfileLinks = sanitizeProfileLinks(list || []);
        renderProfileLinksEditor();
      }

      async function hydrateProfileEditor(){
        const me = getCurrentUser();
        if(!me){
          if(bioInput) bioInput.value = '';
          setProfileLinks([]);
          return;
        }
        const social = await fetchSocial(me.username) || {};
        if(bioInput) bioInput.value = social.bio || '';
        setProfileLinks(Array.isArray(social.links) ? social.links : []);
      }

      if(addLinkBtn && linkLabelInput && linkUrlInput){
        addLinkBtn.addEventListener('click', ()=>{
          const raw = { label: linkLabelInput.value, url: linkUrlInput.value };
          const normalized = normalizeProfileLinkEntry(raw);
          if(!normalized) return alert('Enter a valid URL (example: https://example.com)');
          pendingProfileLinks.push(normalized);
          pendingProfileLinks = sanitizeProfileLinks(pendingProfileLinks);
          renderProfileLinksEditor();
          linkLabelInput.value = '';
          linkUrlInput.value = '';
        });
      }

      if(clearLinksBtn){
        clearLinksBtn.addEventListener('click', ()=>{
          pendingProfileLinks = [];
          renderProfileLinksEditor();
        });
      }

      if(saveLinksBtn){
        saveLinksBtn.addEventListener('click', async ()=>{
          const me = getCurrentUser(); if(!me) return alert('Sign in to edit profile');
          const social = await fetchSocial(me.username) || {};
          social.links = sanitizeProfileLinks(pendingProfileLinks);
          await updateSocial(me.username, social);
          addNotification('Profile links saved');
        });
      }

      document.getElementById('saveBio').addEventListener('click', async ()=>{
        const me = getCurrentUser(); if(!me) return alert('Sign in to edit profile');
        const bio = (bioInput && bioInput.value ? bioInput.value : '').trim();
        const social = await fetchSocial(me.username) || {};
        social.bio = bio;
        await updateSocial(me.username, social);
        addNotification('Bio saved');
        refreshListView({});
      });
      document.getElementById('saveAvatar').addEventListener('click', ()=>{
        const me = getCurrentUser(); if(!me) return alert('Sign in to edit profile');
        const picker = document.createElement('input');
        picker.type = 'file';
        picker.accept = 'image/*';
        picker.onchange = async ()=>{
          const file = picker.files && picker.files[0];
          if(!file) return;
          try{
            const result = await saveAvatarToServer(file);
            if(result && result.url){
              const avatarEl = document.getElementById('avatarImg');
              const avatarWrapper = document.getElementById('avatarWrap');
              setAvatarImage(avatarEl, { src: result.url, wrapper: avatarWrapper, stage: 'remote' });
              addNotification('Avatar saved');
              refreshListView({});
            }
          }catch(e){
            alert(e && e.message ? e.message : 'Failed to upload avatar');
          }
        };
        picker.click();
      });
      document.getElementById('refreshProfile').addEventListener('click', ()=>{
        const me = getCurrentUser(); if(!me) return alert('Sign in');
        hydrateProfileEditor();
      });
      const staffForm = document.getElementById('staffConsoleForm');
      if(staffForm){
        staffForm.addEventListener('submit', handleStaffConsoleSubmit);
      }
      updateStaffConsoleVisibility();
      window.__hydrateProfileEditor = hydrateProfileEditor;
      hydrateProfileEditor();
    })();

    // --- Social helpers (friend requests, blocking, profiles) ---
    async function fetchSocial(username){
      if(!username) return {};
      const normalizedUser = normalizeUsernameKey(username);
      if(socialCache.has(normalizedUser)) return socialCache.get(normalizedUser);
      if(socialCache.has(username)) return socialCache.get(username);
      const key = getSocialStorageKey(username);
      const legacyKey = 'jjs_social_' + username;
      if(SERVERLESS_URL){
        try{
          const resp = await fetch(SERVERLESS_URL + '?action=getSocial&username=' + encodeURIComponent(username));
          if(resp.ok){
            const j = await resp.json();
            if(j && j.social){
              try{
                localStorage.setItem(key, JSON.stringify(j.social));
                if(legacyKey !== key) localStorage.setItem(legacyKey, JSON.stringify(j.social));
              }catch(_e){}
              socialCache.set(normalizedUser, j.social);
              socialCache.set(username, j.social);
              return j.social;
            }
          }
        }catch(_err){}
      }
      try{
        const cached = JSON.parse(localStorage.getItem(key) || localStorage.getItem(legacyKey) || '{}');
        socialCache.set(normalizedUser, cached);
        socialCache.set(username, cached);
        return cached;
      }catch(_e){
        return {};
      }
    }

    async function updateSocial(username, social){
      if(!username || !social) return null;
      const normalizedUser = normalizeUsernameKey(username);
      const key = getSocialStorageKey(username);
      const legacyKey = 'jjs_social_' + username;
      try{
        localStorage.setItem(key, JSON.stringify(social));
        if(legacyKey !== key) localStorage.setItem(legacyKey, JSON.stringify(social));
      }catch(_e){}
      socialCache.set(normalizedUser, social);
      socialCache.set(username, social);
      if(SERVERLESS_URL){
        try{
          const resp = await fetch(SERVERLESS_URL + '?action=updateSocial', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ username, social }) });
          if(resp.ok) return await resp.json();
        }catch(_err){}
      }
      return null;
    }

    function normalizeUserList(list){
      if(!Array.isArray(list)) return [];
      const seen = new Set();
      const result = [];
      list.forEach(name=>{
        const trimmed = (name || '').toString().trim();
        if(!trimmed) return;
        const lower = trimmed.toLowerCase();
        if(seen.has(lower)) return;
        seen.add(lower);
        result.push(trimmed);
      });
      return result;
    }

    function removeUserFromList(list, username){
      if(!Array.isArray(list) || !username) return Array.isArray(list) ? list.slice() : [];
      const lower = username.toLowerCase();
      return list.filter(name => (name || '').toLowerCase() !== lower);
    }

    function userIsInList(list, username){
      if(!Array.isArray(list) || !username) return false;
      const lower = username.toLowerCase();
      return list.some(name => (name || '').toLowerCase() === lower);
    }

    function getFollowerUsernames(username){
      if(!username) return [];
      const normalizedUser = normalizeUsernameKey(username);
      const cached = socialCache.get(normalizedUser) || socialCache.get(username);
      if(cached && Array.isArray(cached.followers)){
        return normalizeUserList(cached.followers);
      }
      try{
        const stored = JSON.parse(localStorage.getItem(getSocialStorageKey(username)) || localStorage.getItem('jjs_social_' + username) || '{}');
        return normalizeUserList(Array.isArray(stored.followers) ? stored.followers : []);
      }catch(_e){
        return [];
      }
    }

    async function toggleFollowUser(username){
      const viewer = getCurrentUser();
      if(!viewer) return alert('Sign in to follow users');
      if(!username || viewer.username === username) return alert('You cannot follow yourself.');
      const [mySocialRaw, targetSocialRaw] = await Promise.all([fetchSocial(viewer.username), fetchSocial(username)]);
      const mySocial = mySocialRaw || {};
      const targetSocial = targetSocialRaw || {};
      if(userIsInList(targetSocial.blocked, viewer.username)) return alert('You cannot follow this user.');
      if(userIsInList(mySocial.blocked, username)) return alert('Unblock this user first.');
      const targetFollowers = normalizeUserList(targetSocial.followers || []);
      const myFollowing = normalizeUserList(mySocial.following || []);
      const isFollowing = userIsInList(targetFollowers, viewer.username);
      if(isFollowing){
        targetSocial.followers = removeUserFromList(targetFollowers, viewer.username);
        mySocial.following = removeUserFromList(myFollowing, username);
        await updateSocial(username, targetSocial);
        await updateSocial(viewer.username, mySocial);
        addNotification('Unfollowed ' + username);
      }else{
        targetSocial.followers = normalizeUserList([...targetFollowers, viewer.username]);
        mySocial.following = normalizeUserList([...myFollowing, username]);
        await updateSocial(username, targetSocial);
        await updateSocial(viewer.username, mySocial);
        addNotification('You are now following ' + username);
      }
      renderSidebar();
      openProfile(username);
    }

    function notifyFollowersOfNewPost(lib){
      if(!lib || !lib.author) return;
      if(normalizeVisibility(lib.visibility) === VISIBILITY.PRIVATE) return;
      const followers = normalizeUserList(getFollowerUsernames(lib.author));
      if(!followers.length) return;
      const safeTitle = censorBadWords(lib.title || 'a new library');
      const truncatedTitle = safeTitle.length > 80 ? safeTitle.slice(0,77) + '...' : safeTitle;
      const message = `${lib.author} posted "${truncatedTitle}"`;
      followers.forEach(follower=>{
        if(!follower || follower.toLowerCase() === lib.author.toLowerCase()) return;
        addNotification(message, { targetUser: follower });
      });
    }

    async function sendFriendRequest(to){
      const me = getCurrentUser(); if(!me) return alert('Sign in to add friends');
      const from = me.username; if(from === to) return;
      const mySocial = await fetchSocial(from) || {};
      const theirSocial = await fetchSocial(to) || {};
      if((theirSocial.blocked||[]).includes(from)) return alert('User has blocked you.');
      if((mySocial.blocked||[]).includes(to)) return alert('You have blocked this user.');
      mySocial.outgoingRequests = Array.from(new Set([...(mySocial.outgoingRequests||[]), to]));
      theirSocial.incomingRequests = Array.from(new Set([...(theirSocial.incomingRequests||[]), from]));
      await updateSocial(from, mySocial);
      await updateSocial(to, theirSocial);
      addNotification('Friend request sent to ' + to);
      renderSidebar();
    }

    async function acceptFriendRequest(from){
      const me = getCurrentUser(); if(!me) return alert('Sign in');
      const meName = me.username;
      const mySocial = await fetchSocial(meName) || {};
      const theirSocial = await fetchSocial(from) || {};
      mySocial.incomingRequests = (mySocial.incomingRequests||[]).filter(x=>x!==from);
      theirSocial.outgoingRequests = (theirSocial.outgoingRequests||[]).filter(x=>x!==meName);
      mySocial.friends = Array.from(new Set([...(mySocial.friends||[]), from]));
      theirSocial.friends = Array.from(new Set([...(theirSocial.friends||[]), meName]));
      await updateSocial(meName, mySocial);
      await updateSocial(from, theirSocial);
      addNotification('You and ' + from + ' are now friends');
      renderSidebar();
    }

    async function declineFriendRequest(from){
      const me = getCurrentUser(); if(!me) return alert('Sign in');
      const meName = me.username;
      const mySocial = await fetchSocial(meName) || {};
      const theirSocial = await fetchSocial(from) || {};
      mySocial.incomingRequests = (mySocial.incomingRequests||[]).filter(x=>x!==from);
      theirSocial.outgoingRequests = (theirSocial.outgoingRequests||[]).filter(x=>x!==meName);
      await updateSocial(meName, mySocial);
      await updateSocial(from, theirSocial);
      renderSidebar();
    }

    async function blockUser(target){
      const me = getCurrentUser(); if(!me) return alert('Sign in');
      const meName = me.username; if(meName === target) return;
      const mySocial = await fetchSocial(meName) || {};
      const theirSocial = await fetchSocial(target) || {};
      mySocial.blocked = Array.from(new Set([...(mySocial.blocked||[]), target]));
      mySocial.friends = (mySocial.friends||[]).filter(x=>x!==target);
      mySocial.outgoingRequests = (mySocial.outgoingRequests||[]).filter(x=>x!==target);
      mySocial.incomingRequests = (mySocial.incomingRequests||[]).filter(x=>x!==target);
      mySocial.followers = removeUserFromList(mySocial.followers || [], target);
      mySocial.following = removeUserFromList(mySocial.following || [], target);
      theirSocial.friends = (theirSocial.friends||[]).filter(x=>x!==meName);
      theirSocial.outgoingRequests = (theirSocial.outgoingRequests||[]).filter(x=>x!==meName);
      theirSocial.incomingRequests = (theirSocial.incomingRequests||[]).filter(x=>x!==meName);
      theirSocial.followers = removeUserFromList(theirSocial.followers || [], meName);
      theirSocial.following = removeUserFromList(theirSocial.following || [], meName);
      await updateSocial(meName, mySocial);
      await updateSocial(target, theirSocial);
      addNotification('Blocked ' + target);
      renderSidebar();
    }

    async function unblockUser(target){
      const me = getCurrentUser(); if(!me) return alert('Sign in');
      const meName = me.username;
      const mySocial = await fetchSocial(meName) || {};
      mySocial.blocked = (mySocial.blocked||[]).filter(x=>x!==target);
      await updateSocial(meName, mySocial);
      addNotification('Unblocked ' + target);
      renderSidebar();
    }

    function renderFriendRequests(){
      const wrap = document.getElementById('friendRequests'); if(!wrap) return;
      wrap.innerHTML = '';
      const u = getCurrentUser(); if(!u) { wrap.innerHTML = '<div class="smallMuted">Sign in to manage friends</div>'; return; }
      fetchSocial(u.username).then(s=>{
        const inc = s.incomingRequests||[];
        if(inc.length===0) { wrap.innerHTML = '<div class="smallMuted">No incoming requests</div>'; return; }
        inc.forEach(from=>{
          const row = document.createElement('div'); row.style.display='flex'; row.style.justifyContent='space-between'; row.style.alignItems='center'; row.style.marginBottom='6px';
          const link = document.createElement('a'); link.href = '#'; link.textContent = from; link.className='small'; link.addEventListener('click',(e)=>{ e.preventDefault(); openProfile(from); });
          const left = document.createElement('div'); left.appendChild(link);
          row.appendChild(left);
          const btns = document.createElement('div');
          const a = document.createElement('button'); a.className='ghost'; a.textContent='Accept'; a.addEventListener('click',()=>acceptFriendRequest(from));
          const d = document.createElement('button'); d.className='ghost'; d.textContent='Decline'; d.addEventListener('click',()=>declineFriendRequest(from));
          btns.appendChild(a); btns.appendChild(d); row.appendChild(btns); wrap.appendChild(row);
        });
      });
    }

    async function openProfile(username){
      const social = await fetchSocial(username);
      let modal = document.getElementById('profileModal'); if(!modal){ modal = document.createElement('div'); modal.id='profileModal'; modal.style.position='fixed'; modal.style.left='20px'; modal.style.top='20px'; modal.style.width='320px'; modal.style.maxHeight='80vh'; modal.style.background='var(--card)'; modal.style.padding='12px'; modal.style.borderRadius='10px'; modal.style.boxShadow='0 6px 20px rgba(0,0,0,0.6)'; document.body.appendChild(modal); }
      const avatarSource = getAvatarSourceBundle(username, social);
      const avatarUrl = avatarSource.src || DEFAULT_AVATAR_URL;
      const friends = (social.friends||[]).length || 0;
      const followersCount = Array.isArray(social.followers) ? social.followers.length : 0;
      const safeLinks = sanitizeProfileLinks(social && Array.isArray(social.links) ? social.links : []);
      const bio = social && social.bio ? escapeHtml(social.bio) : '';
      const avatarBlock = `<div class="profileAvatarWrap" style="width:66px;height:66px;overflow:hidden;border-radius:50%;background:rgba(255,255,255,0.03)"><img id="profileAvatar" src="${escapeHtml(avatarUrl)}" style="width:100%;height:100%;object-fit:cover"/></div>`;
      const bioBlock = bio ? `<div class="smallMuted" style="margin-top:4px">${bio}</div>` : '';
      const linksBlock = safeLinks.length ? `<div style="margin-top:10px"><div class="smallMuted" style="letter-spacing:0.12em;text-transform:uppercase;font-size:11px">Links</div><div style="display:flex;flex-direction:column;gap:6px;margin-top:4px">${safeLinks.map(link=>`<a class="link" href="${escapeHtml(link.url)}" target="_blank" rel="noopener noreferrer" style="font-size:13px">${escapeHtml(link.label)}</a>`).join('')}</div></div>` : '';
      const friendLabel = friends === 1 ? 'friend' : 'friends';
      const followerLabel = followersCount === 1 ? 'follower' : 'followers';
      modal.innerHTML = `<div style="display:flex;justify-content:space-between;align-items:center"><div style="display:flex;gap:10px;align-items:center">${avatarBlock}<div><strong>${escapeHtml(username)}</strong><div class="smallMuted">${friends} ${friendLabel} • ${followersCount} ${followerLabel}</div>${bioBlock}${linksBlock}</div></div><button id="closeProfile">Close</button></div><div style="margin-top:10px" id="profileActions"></div><div style="margin-top:10px"><strong>Recent libraries</strong><div id="profileLibs"></div></div>`;
      document.getElementById('closeProfile').addEventListener('click', ()=>modal.remove());
      const profileAvatarImg = document.getElementById('profileAvatar');
      const profileAvatarWrap = modal.querySelector('.profileAvatarWrap');
      setAvatarImage(profileAvatarImg, {
        src: avatarUrl,
        wrapper: profileAvatarWrap,
        stage: avatarSource.stage,
        fallbackSources: avatarSource.fallbackSources
      });
      const me = getCurrentUser(); const actions = document.getElementById('profileActions'); actions.innerHTML='';
      if(me && me.username !== username){
        const mySocial = await fetchSocial(me.username);
        const theirSocial = social || {};
        const isFriend = (mySocial.friends||[]).includes(username);
        const outgoing = (mySocial.outgoingRequests||[]).includes(username);
        const incoming = (mySocial.incomingRequests||[]).includes(username);
        const blocked = (mySocial.blocked||[]).includes(username);
        const theyBlockedMe = Array.isArray(theirSocial.blocked) ? theirSocial.blocked.includes(me.username) : false;
        const isFollowing = userIsInList(mySocial && mySocial.following, username);
        if(theyBlockedMe){
          const note = document.createElement('div');
          note.className = 'smallMuted';
          note.textContent = 'This user has blocked you.';
          actions.appendChild(note);
        }else{
          const followBtn = document.createElement('button');
          followBtn.className = 'ghost';
          followBtn.textContent = isFollowing ? 'Following' : 'Follow';
          if(blocked){
            followBtn.disabled = true;
            followBtn.textContent = 'Unblock to follow';
          }else{
            followBtn.addEventListener('click', ()=> toggleFollowUser(username));
          }
          actions.appendChild(followBtn);
        }
        if(isFriend){ const b = document.createElement('button'); b.className='ghost'; b.textContent='Friends'; actions.appendChild(b); }
        else if(outgoing){ const b = document.createElement('button'); b.className='ghost'; b.textContent='Request sent'; actions.appendChild(b); }
        else if(incoming){ const a = document.createElement('button'); a.className='ghost'; a.textContent='Accept'; a.addEventListener('click', ()=>{ acceptFriendRequest(username); openProfile(username); }); actions.appendChild(a); }
        else { const a = document.createElement('button'); a.className='ghost'; a.textContent='Add friend'; a.addEventListener('click', ()=>{ sendFriendRequest(username); openProfile(username); }); actions.appendChild(a); }
        if(blocked){ const b = document.createElement('button'); b.className='ghost'; b.textContent='Unblock'; b.addEventListener('click', ()=>{ unblockUser(username); openProfile(username); }); actions.appendChild(b); }
        else { const b = document.createElement('button'); b.className='ghost'; b.textContent='Block'; b.addEventListener('click', ()=>{ if(confirm('Block user? This will remove friends and stop messages.')){ blockUser(username); openProfile(username); } }); actions.appendChild(b); }
      }
      const libWrap = document.getElementById('profileLibs'); libWrap.innerHTML=''; libs.filter(l=>l.author===username).slice(0,10).forEach(l=>{ const d = document.createElement('div'); d.className='libItem'; d.textContent = l.title; libWrap.appendChild(d); });
    }

    const NOTIFICATIONS_KEY = 'jjs_notifications';
    const GLOBAL_NOTIFICATION_BUCKET = '__global__';

    function readNotificationStore(){
      try{
        const raw = localStorage.getItem(NOTIFICATIONS_KEY);
        if(!raw) return {};
        const parsed = JSON.parse(raw);
        if(Array.isArray(parsed)) return { [GLOBAL_NOTIFICATION_BUCKET]: parsed };
        return parsed && typeof parsed === 'object' ? parsed : {};
      }catch(_e){
        return {};
      }
    }

    function writeNotificationStore(store){
      try{ localStorage.setItem(NOTIFICATIONS_KEY, JSON.stringify(store)); }
      catch(_e){}
    }

    function addNotification(text, opts = {}){
      if(!text) return;
      const store = readNotificationStore();
      const current = getCurrentUser();
      const targetUser = (opts.targetUser || (current && current.username) || GLOBAL_NOTIFICATION_BUCKET).toLowerCase();
      const list = Array.isArray(store[targetUser]) ? store[targetUser] : [];
      list.unshift({ t: Date.now(), text });
      store[targetUser] = list.slice(0, 50);
      writeNotificationStore(store);
      if(!opts.silent && current && current.username.toLowerCase() === targetUser){
        renderNotifications();
      }
    }

    function renderNotifications(){
      const el = document.getElementById('notifications'); if(!el) return;
      const current = getCurrentUser();
      if(!current){
        el.innerHTML = '<div class="smallMuted">Sign in to view notifications</div>';
        return;
      }
      const store = readNotificationStore();
      let bucket = Array.isArray(store[current.username.toLowerCase()]) ? store[current.username.toLowerCase()] : [];
      if(!bucket.length && Array.isArray(store[GLOBAL_NOTIFICATION_BUCKET])){
        bucket = store[GLOBAL_NOTIFICATION_BUCKET];
      }
      if(!bucket.length){
        el.innerHTML = '<div class="smallMuted">No notifications yet</div>';
        return;
      }
      el.innerHTML = '';
      bucket.forEach(n=>{
        const div = document.createElement('div');
        const stamp = new Date(n.t || Date.now()).toLocaleString();
        div.textContent = stamp + ' — ' + n.text;
        el.appendChild(div);
      });
    }

    const DM_MESSAGE_MAX_LENGTH = 500;

    function sanitizeDmUser(username){
      return (username || '').toString().trim().replace(/[^a-z0-9_-]/gi,'_') || 'anonymous';
    }

    function getDmConvId(userA, userB){
      return [sanitizeDmUser(userA), sanitizeDmUser(userB)].sort((a,b)=>a.localeCompare(b)).join('__');
    }

    async function fetchDmConversation(withUser){
      const me = getCurrentUser();
      if(!me) throw new Error('Sign in to load DMs');
      if(!SERVERLESS_URL) throw new Error('DM server unavailable');
      const convId = getDmConvId(me.username, withUser);
      const resp = await fetch(SERVERLESS_URL + '?action=getDMConversation', {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ convId, participants:[me.username, withUser] })
      });
      const data = await resp.json().catch(()=>null);
      if(!resp.ok || !data || data.error) throw new Error((data && data.error) || 'Failed to load conversation');
      const messages = Array.isArray(data.messages) ? data.messages : [];
      return { convId, messages };
    }

    async function listServerDMs(username){
      if(!SERVERLESS_URL) throw new Error('DM server unavailable');
      const resp = await fetch(SERVERLESS_URL + '?action=listDMs', {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ username })
      });
      const data = await resp.json().catch(()=>null);
      if(!resp.ok || !data || data.error) throw new Error((data && data.error) || 'Failed to load DMs');
      return Array.isArray(data.conversations) ? data.conversations : [];
    }

    async function sendDmMessage(withUser, text){
      const me = getCurrentUser();
      if(!me) throw new Error('Sign in to DM');
      if(!SERVERLESS_URL) throw new Error('DM server unavailable');
      const trimmed = text.trim();
      if(!trimmed) throw new Error('Message required');
      const cleanMessage = censorBadWords(trimmed).slice(0, DM_MESSAGE_MAX_LENGTH);
      const entry = { from: me.username, to: withUser, message: cleanMessage, t: Date.now() };
      const convId = getDmConvId(me.username, withUser);
      const resp = await fetch(SERVERLESS_URL + '?action=saveDM', {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ convId, entry, participants:[me.username, withUser] })
      });
      const data = await resp.json().catch(()=>null);
      if(!resp.ok || !data || data.error) throw new Error((data && data.error) || 'Failed to send message');
      return entry;
    }

    function renderDMList(){
      const wrap = document.getElementById('dmConvos');
      if(!wrap) return;
      const me = getCurrentUser();
      if(!me){
        wrap.innerHTML = '<div class="smallMuted">Sign in to view DMs</div>';
        return;
      }
      if(!SERVERLESS_URL){
        wrap.innerHTML = '<div class="smallMuted">DM server unavailable</div>';
        return;
      }
      wrap.innerHTML = '<div class="smallMuted">Loading...</div>';
      const meKey = sanitizeDmUser(me.username);
      listServerDMs(me.username).then(convos=>{
        if(!convos.length){
          wrap.innerHTML = '<div class="smallMuted">No conversations yet</div>';
          return;
        }
        convos.sort((a,b)=> (b.lastMessage && b.lastMessage.t ? b.lastMessage.t : 0) - (a.lastMessage && a.lastMessage.t ? a.lastMessage.t : 0));
        wrap.innerHTML = '';
        convos.forEach(convo=>{
          const row = document.createElement('div');
          row.className = 'libItem';
          row.style.cursor = 'pointer';
          const previewMsg = (convo.lastMessage && typeof convo.lastMessage.message === 'string') ? censorBadWords(convo.lastMessage.message) : '';
          const previewUser = convo.lastMessage && convo.lastMessage.from ? censorBadWords(convo.lastMessage.from) : '';
          const preview = convo.lastMessage ? `${previewUser}: ${previewMsg.slice(0,60)}`.trim() : 'No messages yet';
          const fallbackUser = (Array.isArray(convo.participants) ? convo.participants : []).find(part=>sanitizeDmUser(part) !== meKey);
          const targetUser = convo.withUser || fallbackUser || '';
          const displayName = targetUser || 'unknown';
          row.innerHTML = `<strong>${escapeHtml(censorBadWords(displayName))}</strong><div class="smallMuted">${escapeHtml(censorBadWords(preview))}</div>`;
          row.addEventListener('click', ()=>{
            if(!targetUser) return alert('Unable to open this conversation');
            openDMWindow(targetUser);
          });
          wrap.appendChild(row);
        });
      }).catch(err=>{
        console.warn('renderDMList error', err);
        wrap.innerHTML = '<div class="smallMuted">Failed to load DMs</div>';
      });
    }

    async function openDMWindow(username){
      const me = getCurrentUser();
      if(!me) return alert('Sign in to DM');
      let mySocial = {};
      let theirSocial = {};
      try{
        [mySocial, theirSocial] = await Promise.all([fetchSocial(me.username), fetchSocial(username)]);
      }catch(err){
        console.warn('openDMWindow social fetch failed', err);
      }
      if((mySocial && mySocial.blocked || []).includes(username)) return alert('You have blocked this user — unblock to message.');
      if((theirSocial && theirSocial.blocked || []).includes(me.username)) return alert('User has blocked you — cannot message.');
      let modal = document.getElementById('dmModal');
      if(!modal){
        modal = document.createElement('div');
        modal.id='dmModal';
        modal.style.position='fixed';
        modal.style.right='20px';
        modal.style.bottom='20px';
        modal.style.width='320px';
        modal.style.maxHeight='60vh';
        modal.style.background='var(--card)';
        modal.style.padding='10px';
        modal.style.borderRadius='10px';
        modal.style.boxShadow='0 6px 20px rgba(0,0,0,0.6)';
        document.body.appendChild(modal);
      }
      modal.innerHTML = `<div style="display:flex;justify-content:space-between;align-items:center"><strong>DM: ${escapeHtml(censorBadWords(username))}</strong><button id="closeDm" class="ghost">Close</button></div><div id="dmStatus" class="smallMuted" style="margin-top:4px"></div><div id="dmMessages" style="max-height:300px;overflow:auto;margin-top:4px"></div><div style="display:flex;gap:8px;margin-top:8px"><input id="dmMsgInput" style="flex:1;padding:8px;border-radius:6px;border:1px solid rgba(255,255,255,0.04)" placeholder="Message (max ${DM_MESSAGE_MAX_LENGTH} chars)"><button id="sendDmBtn" class="ghost">Send</button></div>`;
      document.getElementById('closeDm').addEventListener('click', ()=>modal.remove());
      const statusEl = document.getElementById('dmStatus');
      const messagesEl = document.getElementById('dmMessages');
      const inputEl = document.getElementById('dmMsgInput');
      const sendBtn = document.getElementById('sendDmBtn');

      function renderMessages(msgs){
        messagesEl.innerHTML = '';
        if(!msgs.length){
          messagesEl.innerHTML = '<div class="smallMuted">No messages yet</div>';
          return;
        }
        msgs.forEach(m=>{
          const div = document.createElement('div');
          div.className='libItem';
          div.style.marginBottom='4px';
          const meta = document.createElement('div');
          meta.innerHTML = `<strong>${escapeHtml(censorBadWords(m.from || 'Unknown'))}</strong> <span class="smallMuted">${new Date(m.t || Date.now()).toLocaleString()}</span>`;
          const body = document.createElement('div');
          body.textContent = censorBadWords(m.message || '');
          div.appendChild(meta);
          div.appendChild(body);
          messagesEl.appendChild(div);
        });
        messagesEl.scrollTop = messagesEl.scrollHeight;
      }

      async function refreshConversation(){
        statusEl.textContent = 'Loading conversation...';
        try{
          const { messages } = await fetchDmConversation(username);
          statusEl.textContent = '';
          renderMessages(messages);
        }catch(err){
          statusEl.textContent = 'Failed to load conversation: ' + (err && err.message ? err.message : 'Unknown error');
        }
      }

      sendBtn.addEventListener('click', async ()=>{
        const txt = (inputEl.value || '').trim();
        if(!txt) return;
        if(txt.length > DM_MESSAGE_MAX_LENGTH) return alert('Max ' + DM_MESSAGE_MAX_LENGTH + ' chars');
        sendBtn.disabled = true;
        try{
          await sendDmMessage(username, txt);
          inputEl.value = '';
          await refreshConversation();
          renderDMList();
        }catch(err){
          alert(err && err.message ? err.message : 'Failed to send message');
        }finally{
          sendBtn.disabled = false;
        }
      });

      inputEl.addEventListener('keydown', (ev)=>{
        if(ev.key === 'Enter' && !ev.shiftKey){
          ev.preventDefault();
          sendBtn.click();
        }
      });

      refreshConversation();
    }

    document.getElementById('openDm').addEventListener('click', ()=>{
      const to = document.getElementById('dmTo').value.trim();
      if(!to) return alert('Enter username');
      openDMWindow(to).catch(err=>{
        alert(err && err.message ? err.message : 'Failed to open DM');
      });
      document.getElementById('dmTo').value='';
    });

    // ensure sidebar updates when user/ libs change
    const origRender = render;
    render = function(filtered){ origRender(filtered); renderSidebar(); };

    // Helper: download an object as JSON file (local fallback)
    function downloadJSON(obj, filename){
      const blob = new Blob([JSON.stringify(obj, null, 2)], {type: 'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = filename || 'data.json';
      document.body.appendChild(a); a.click(); a.remove();
      URL.revokeObjectURL(url);
    }

    function sanitizeFilename(name){
      return name.replace(/[^a-z0-9-_. ]/gi,'_').slice(0,60);
    }

    async function persistLibraryFile(lib, opts = {}){
      if(!lib) throw new Error('Missing library data');
      const { downloadOnMissingConfig = false, downloadOnFailure = false } = opts;
      const filename = lib.__filename || `${lib.id || Date.now()}-${sanitizeFilename(lib.title || 'library')}.json`;
      const localBasePath = (GITHUB.path || '').replace(/^\/+/g,'').replace(/\/+$/g,'');
      const toDownloadResult = (reason)=>{
        lib.__filename = filename;
        lib.__path = lib.__path || filename;
        downloadJSON(lib, filename);
        return { filename: lib.__filename, downloaded: true, method: 'download', reason };
      };
      if(SERVERLESS_URL){
        try{
          const resp = await fetch(SERVERLESS_URL, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ lib, filename }) });
          const data = await resp.json().catch(()=>null);
          if(!resp.ok || (data && data.error)) throw new Error((data && data.error) || 'Save failed');
          if(data && data.result && data.result.content && data.result.content.path){
            lib.__path = data.result.content.path;
            lib.__filename = data.result.content.path.split('/').pop() || filename;
          }else{
            lib.__filename = filename;
            lib.__path = lib.__path || (localBasePath ? `${localBasePath}/${filename}` : filename);
          }
          return { filename: lib.__filename, method: 'serverless' };
        }catch(err){
          if(downloadOnFailure) return toDownloadResult(err);
          throw err;
        }
      }
      if(GITHUB.token && GITHUB.owner && GITHUB.repo){
        await saveToGitHub(lib, filename);
        lib.__filename = filename;
        lib.__path = lib.__path || (localBasePath ? `${localBasePath}/${filename}` : filename);
        return { filename: lib.__filename, method: 'github' };
      }
      if(downloadOnMissingConfig) return toDownloadResult();
      return null;
    }

    async function updateLibraryVisibility(lib, nextVisibility){
      if(!lib) throw new Error('Missing library');
      const previousState = normalizeVisibility(lib.visibility);
      const desiredState = normalizeVisibility(nextVisibility);
      if(previousState === desiredState) return;
      lib.visibility = desiredState;
      sanitizeLibraryContent(lib);
      try{
        await persistLibraryFile(lib);
      }catch(err){
        lib.visibility = previousState;
        sanitizeLibraryContent(lib);
        throw err;
      }
    }

    // Save a library file into the configured GitHub repo (creates or updates file)
    async function saveToGitHub(obj, filename){
      const basePath = GITHUB.path ? GITHUB.path.replace(/^\/+|\/+$/g,'') + '/' : '';
      const path = `${basePath}${filename}`;
      const apiBase = `https://api.github.com/repos/${GITHUB.owner}/${GITHUB.repo}/contents/${encodeURIComponent(path)}`;
      const headers = { 'Accept': 'application/vnd.github.v3+json', 'Authorization': `token ${GITHUB.token}` };

      // check if file exists to obtain sha
      let sha = null;
      const getResp = await fetch(apiBase + `?ref=${encodeURIComponent(GITHUB.branch)}`, { headers });
      if(getResp.status === 200){
        const data = await getResp.json(); sha = data.sha;
      }

      const content = toBase64(JSON.stringify(obj, null, 2));
      const body = { message: `Add/Update library ${obj.title}`, content, branch: GITHUB.branch };
      if(sha) body.sha = sha;

      const putResp = await fetch(apiBase, { method: 'PUT', headers: Object.assign({'Content-Type':'application/json'}, headers), body: JSON.stringify(body) });
      if(!putResp.ok) throw new Error('GitHub API error: ' + putResp.status + ' ' + await putResp.text());
      return await putResp.json();
    }

    // Basic unicode-safe base64
    function toBase64(str){
      try{ return btoa(unescape(encodeURIComponent(str))); }catch(e){
        // fallback using TextEncoder
        const bytes = new TextEncoder().encode(str);
        let binary = '';
        bytes.forEach(b=>binary += String.fromCharCode(b));
        return btoa(binary);
      }
    }

    // Load remote libraries (if any) then render
    async function loadRemoteLibs(){
      const diagnostics = document.getElementById('diagnostics');
      if(diagnostics) diagnostics.textContent = 'Loading remote libraries...';
      const owner = (typeof GITHUB !== 'undefined' && GITHUB.owner) ? GITHUB.owner : 'ItzKuroYT';
      const repo = (typeof GITHUB !== 'undefined' && GITHUB.repo) ? GITHUB.repo : 'JJS-Libraries';
      const path = (typeof GITHUB !== 'undefined' && GITHUB.path) ? GITHUB.path : 'libs';
      const api = `https://api.github.com/repos/${owner}/${repo}/contents/${path}`;
      try{
        const listResp = await fetch(api);
        if(!listResp.ok){
          if(diagnostics) diagnostics.textContent = `Failed to list remote libs: ${listResp.status} ${await listResp.text()}`;
          refreshListView({ refilter:true });
          return;
        }
        const list = await listResp.json();
        if(!Array.isArray(list)){ if(diagnostics) diagnostics.textContent = 'No remote files found.'; refreshListView({ refilter:true }); return; }
        let added = 0;
        for(const item of list){
          if(item.type==='file' && item.name.endsWith('.json')){
            try{
              const j = await fetch(item.download_url).then(r=>r.json());
              if(j){
                sanitizeLibraryContent(j);
                // attach filename/path so client can edit/delete
                j.__filename = item.name;
                j.__path = item.path || (path + '/' + item.name);
                let inserted = false;
                if(j.id && !libs.some(l=>l.id===j.id)) { libs.push(j); added++; inserted = true; }
                else if(!j.id){ j.id = Date.now().toString() + Math.random().toString(36).slice(2,6); libs.push(j); added++; inserted = true; }
                if(inserted && remoteLibsInitialized){ notifyFollowersOfNewPost(j); }
              }
            }catch(e){ /* ignore load error */ }
          }
        }
        if(diagnostics) diagnostics.textContent = `Loaded ${added} remote libraries from ${owner}/${repo}/${path}.`;
        refreshListView({ refilter:true });
        remoteLibsInitialized = true;
      }catch(err){
        if(diagnostics) diagnostics.textContent = 'Error loading remote libs: ' + String(err);
        refreshListView({ refilter:true });
      }
    }

    refreshListView({ refilter:true, resetPage:true });
    loadRemoteLibs();
    refreshUserCount();
    refreshStaffDisplay();
    updateStaffConsoleVisibility();
  </script>
</body>
</html>
